'''
## Aliyun ROS ESS Construct Library

This module is part of the AliCloud ROS Cloud Development Kit (ROS CDK) project.

```python
import * as ESS from '@alicloud/ros-cdk-ess';
```
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import ros_cdk_core as _ros_cdk_core_7adfd82f


class AlarmTask(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.AlarmTask",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::AlarmTask``, which is used to create a metric-based alarm task.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosAlarmTask``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-alarmtask
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["AlarmTaskProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__764fd1e9940f9a4c2bd11667c7fcd7ef227eff77dfff31f08b24eeba648816c2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrAlarmTaskId")
    def attr_alarm_task_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute AlarmTaskId: The alarm task ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAlarmTaskId"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__656bc8e7e2cd713b40829edb78f9902c139c66957afc8c05cff0ebebfca02b79)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb45a08e208657a480c1fdf7b01a768809d02dcd7d42d16ed8b6d17e86c14e8f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "AlarmTaskProps":
        return typing.cast("AlarmTaskProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "AlarmTaskProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eac56b8808d25d8bfa2204143ec8e0a3047367d208aacf5cca935ac9474d1012)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2f5f766a2bae3e866252f519cf401c35c47c1d90d31303666a9a3808f344c46)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


class AlarmTaskEnable(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.AlarmTaskEnable",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::AlarmTaskEnable``, which is used to start an alarm task.

    You can call this operation to enable alarm tasks when the task is stopped.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosAlarmTaskEnable``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-alarmtaskenable
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["AlarmTaskEnableProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77a2d7f90f91a5d104a5e4d7bfb6465099d560e28e764973f09d0ece596d4cb8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__808106288d1b399e6a867d2d2745bef36cc84b0ed54ff1d8bfeea4aa309f9e6e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__104bfdbaa6e4d77aae32090f49b8a36df8a781bcfc8c724f4dd7392ec70543e1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "AlarmTaskEnableProps":
        return typing.cast("AlarmTaskEnableProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "AlarmTaskEnableProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2346f974467e3fd4cf93a8382d83a01a3cf05d1a6b753ee7124480bf7fbb069)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d2f05e307b73d87e2b480ebc998658ad8cda47c0860e336a70e6f9a185b62cf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.AlarmTaskEnableProps",
    jsii_struct_bases=[],
    name_mapping={"alarm_task_id": "alarmTaskId", "enable": "enable"},
)
class AlarmTaskEnableProps:
    def __init__(
        self,
        *,
        alarm_task_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        enable: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``AlarmTaskEnable``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-alarmtaskenable

        :param alarm_task_id: Property alarmTaskId: The id of alarm task.
        :param enable: Property enable: Enable alarm task or not.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75a8133c27a4af819b5d126cd149ee508c1190e31b974a1e5fc006293bc5a9dd)
            check_type(argname="argument alarm_task_id", value=alarm_task_id, expected_type=type_hints["alarm_task_id"])
            check_type(argname="argument enable", value=enable, expected_type=type_hints["enable"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "alarm_task_id": alarm_task_id,
            "enable": enable,
        }

    @builtins.property
    def alarm_task_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property alarmTaskId: The id of alarm task.'''
        result = self._values.get("alarm_task_id")
        assert result is not None, "Required property 'alarm_task_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def enable(self) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property enable: Enable alarm task or not.'''
        result = self._values.get("enable")
        assert result is not None, "Required property 'enable' is missing"
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmTaskEnableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.AlarmTaskProps",
    jsii_struct_bases=[],
    name_mapping={
        "alarm_action": "alarmAction",
        "metric_name": "metricName",
        "scaling_group_id": "scalingGroupId",
        "threshold": "threshold",
        "comparison_operator": "comparisonOperator",
        "description": "description",
        "dimensions": "dimensions",
        "evaluation_count": "evaluationCount",
        "group_id": "groupId",
        "metric_type": "metricType",
        "name": "name",
        "period": "period",
        "statistics": "statistics",
    },
)
class AlarmTaskProps:
    def __init__(
        self,
        *,
        alarm_action: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
        metric_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        threshold: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        comparison_operator: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        dimensions: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosAlarmTask.DimensionsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        group_id: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        metric_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        statistics: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``AlarmTask``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-alarmtask

        :param alarm_action: Property alarmAction: Alarm Actions.
        :param metric_name: Property metricName: Metric Name.
        :param scaling_group_id: Property scalingGroupId: The ID of the scaling group.
        :param threshold: Property threshold: Threshold.
        :param comparison_operator: Property comparisonOperator: Comparison Operator.
        :param description: Property description: Description.
        :param dimensions: Property dimensions: Dimensions.
        :param evaluation_count: Property evaluationCount: Evaluation Count.
        :param group_id: Property groupId: Group Id.
        :param metric_type: Property metricType: Metric Type.
        :param name: Property name: Name.
        :param period: Property period: Period.
        :param statistics: Property statistics: Statistics.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe1bbef50f679260f65ae6805fe47532b6529a1892faf30864bd62d2686929dc)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument dimensions", value=dimensions, expected_type=type_hints["dimensions"])
            check_type(argname="argument evaluation_count", value=evaluation_count, expected_type=type_hints["evaluation_count"])
            check_type(argname="argument group_id", value=group_id, expected_type=type_hints["group_id"])
            check_type(argname="argument metric_type", value=metric_type, expected_type=type_hints["metric_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument statistics", value=statistics, expected_type=type_hints["statistics"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "alarm_action": alarm_action,
            "metric_name": metric_name,
            "scaling_group_id": scaling_group_id,
            "threshold": threshold,
        }
        if comparison_operator is not None:
            self._values["comparison_operator"] = comparison_operator
        if description is not None:
            self._values["description"] = description
        if dimensions is not None:
            self._values["dimensions"] = dimensions
        if evaluation_count is not None:
            self._values["evaluation_count"] = evaluation_count
        if group_id is not None:
            self._values["group_id"] = group_id
        if metric_type is not None:
            self._values["metric_type"] = metric_type
        if name is not None:
            self._values["name"] = name
        if period is not None:
            self._values["period"] = period
        if statistics is not None:
            self._values["statistics"] = statistics

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''Property alarmAction: Alarm Actions.'''
        result = self._values.get("alarm_action")
        assert result is not None, "Required property 'alarm_action' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], result)

    @builtins.property
    def metric_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property metricName: Metric Name.'''
        result = self._values.get("metric_name")
        assert result is not None, "Required property 'metric_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: The ID of the scaling group.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def threshold(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property threshold: Threshold.'''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def comparison_operator(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property comparisonOperator: Comparison Operator.'''
        result = self._values.get("comparison_operator")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Description.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def dimensions(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosAlarmTask.DimensionsProperty"]]]]:
        '''Property dimensions: Dimensions.'''
        result = self._values.get("dimensions")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosAlarmTask.DimensionsProperty"]]]], result)

    @builtins.property
    def evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property evaluationCount: Evaluation Count.'''
        result = self._values.get("evaluation_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def group_id(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property groupId: Group Id.'''
        result = self._values.get("group_id")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def metric_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property metricType: Metric Type.'''
        result = self._values.get("metric_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: Name.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property period: Period.'''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def statistics(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property statistics: Statistics.'''
        result = self._values.get("statistics")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EciScalingConfiguration(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.EciScalingConfiguration",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::EciScalingConfiguration``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosEciScalingConfiguration``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-eciscalingconfiguration
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["EciScalingConfigurationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39109add3ecef7540ac58097bf0b39ab67f7bf2f374548a64bb835cf8ab52f10)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrScalingConfigurationId")
    def attr_scaling_configuration_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingConfigurationId: The ID of the elastic container instance.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingConfigurationId"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__917dd3344f5fb5b15c588d85800130336cda7e8d397c433eefa1203128e42e07)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98c2802e5cf090b5c362a1a3c8eeb42a21ddf0e4f45798018b048026289292c0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "EciScalingConfigurationProps":
        return typing.cast("EciScalingConfigurationProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "EciScalingConfigurationProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1a6f2dee81fef2fe00513b0e56c04d1d3a21c7a4240fd469d48a4757b1ed45a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61c7f70fe419399ae79938b3af56e2520701645dca0d4af4aa40117e5ff4899d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.EciScalingConfigurationProps",
    jsii_struct_bases=[],
    name_mapping={
        "container_group_name": "containerGroupName",
        "scaling_configuration_name": "scalingConfigurationName",
        "scaling_group_id": "scalingGroupId",
        "security_group_id": "securityGroupId",
        "acr_registry_infos": "acrRegistryInfos",
        "active_deadline_seconds": "activeDeadlineSeconds",
        "auto_create_eip": "autoCreateEip",
        "auto_match_image_cache": "autoMatchImageCache",
        "containers": "containers",
        "cost_optimization": "costOptimization",
        "cpu": "cpu",
        "cpu_options_core": "cpuOptionsCore",
        "cpu_options_threads_per_core": "cpuOptionsThreadsPerCore",
        "data_cache_bucket": "dataCacheBucket",
        "data_cache_bursting_enabled": "dataCacheBurstingEnabled",
        "data_cache_pl": "dataCachePl",
        "data_cache_provisioned_iops": "dataCacheProvisionedIops",
        "dns_config_name_servers": "dnsConfigNameServers",
        "dns_config_options": "dnsConfigOptions",
        "dns_config_searches": "dnsConfigSearches",
        "dns_policy": "dnsPolicy",
        "egress_bandwidth": "egressBandwidth",
        "eip_bandwidth": "eipBandwidth",
        "ephemeral_storage": "ephemeralStorage",
        "host_aliases": "hostAliases",
        "host_name": "hostName",
        "image_registry_credentials": "imageRegistryCredentials",
        "image_snapshot_id": "imageSnapshotId",
        "ingress_bandwidth": "ingressBandwidth",
        "init_containers": "initContainers",
        "instance_family_level": "instanceFamilyLevel",
        "instance_types": "instanceTypes",
        "ipv6_address_count": "ipv6AddressCount",
        "load_balancer_weight": "loadBalancerWeight",
        "memory": "memory",
        "ntp_servers": "ntpServers",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "restart_policy": "restartPolicy",
        "security_context_sysctls": "securityContextSysctls",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "tags": "tags",
        "termination_grace_period_seconds": "terminationGracePeriodSeconds",
        "volumes": "volumes",
    },
)
class EciScalingConfigurationProps:
    def __init__(
        self,
        *,
        container_group_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        scaling_configuration_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        security_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        acr_registry_infos: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.AcrRegistryInfosProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        active_deadline_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        auto_create_eip: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        auto_match_image_cache: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        containers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.ContainersProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        cost_optimization: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cpu_options_core: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cpu_options_threads_per_core: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        data_cache_bucket: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        data_cache_bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        data_cache_pl: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        data_cache_provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        dns_config_name_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        dns_config_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.DnsConfigOptionsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        dns_config_searches: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        dns_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        egress_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        eip_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ephemeral_storage: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        host_aliases: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.HostAliasesProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        host_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_registry_credentials: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.ImageRegistryCredentialsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        image_snapshot_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ingress_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        init_containers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.InitContainersProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        instance_family_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        ipv6_address_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        load_balancer_weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ntp_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        ram_role_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        restart_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_context_sysctls: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.SecurityContextSysctlsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["RosEciScalingConfiguration.TagsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        termination_grace_period_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        volumes: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.VolumesProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''Properties for defining a ``EciScalingConfiguration``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-eciscalingconfiguration

        :param container_group_name: Property containerGroupName: The name of the elastic container instance.
        :param scaling_configuration_name: Property scalingConfigurationName: The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (_), hyphens (-), and periods (.). The name must start with a letter or a digit. The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
        :param scaling_group_id: Property scalingGroupId: The ID of the scaling group for which you want to create the scaling configuration.
        :param security_group_id: Property securityGroupId: The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other. If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group and adds the declared container protocols and port numbers to the inbound rules of the security group.
        :param acr_registry_infos: Property acrRegistryInfos:.
        :param active_deadline_seconds: Property activeDeadlineSeconds: The validity period of the scaling configuration. Unit: seconds.
        :param auto_create_eip: Property autoCreateEip: Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.
        :param auto_match_image_cache: Property autoMatchImageCache: Specifies whether to automatically match the image cache. Valid values: true false Default value: false.
        :param containers: Property containers:.
        :param cost_optimization: Property costOptimization: Specifies whether to enable the Cost Optimization feature. Valid values: true false Default value: false.
        :param cpu: Property cpu: The number of vCPUs that you want to allocate to the elastic container instance.
        :param cpu_options_core: Property cpuOptionsCore: The number of physical CPU cores. You can specify this parameter for only specific instance types. For more information, see Specify custom CPU options.
        :param cpu_options_threads_per_core: Property cpuOptionsThreadsPerCore: The number of threads per core. You can specify this parameter for only specific instance types. If you set this parameter to 1, Hyper-Threading is disabled. For more information, see Specify custom CPU options.
        :param data_cache_bucket: Property dataCacheBucket: The bucket that stores data caches.
        :param data_cache_bursting_enabled: Property dataCacheBurstingEnabled: Specifies whether to enable the Performance Burst feature for the ESSD AutoPL disk used for data caching. Valid values: true false Default value: false. Note For more information about ESSD AutoPL disks, see ESSD AutoPL disks.
        :param data_cache_pl: Property dataCachePl: The performance level (PL) of the disk used for data caching. We recommend that you use ESSDs. Valid values if you use ESSDs: PL0: An ESSD can provide up to 10,000 random read/write IOPS. PL1: An ESSD can provide up to 50,000 random read/write IOPS. PL2: An ESSD can provide up to 100,000 random read/write IOPS. PL3: An ESSD can provide up to 1,000,000 random read/write IOPS. Default value: PL1. Note For more information about ESSDs, see ESSDs.
        :param data_cache_provisioned_iops: Property dataCacheProvisionedIops: The IOPS provisioned for the ESSD AutoPL disk used for data caching. Valid values: 0 to min{50000, 1000 × Capacity - Baseline IOPS}, where Baseline IOPS = min{1800 + 50 × Capacity - 50000}. Note For more information about ESSD AutoPL disks, see ESSD AutoPL disks.
        :param dns_config_name_servers: Property dnsConfigNameServers: The IP addresses of the DNS servers.
        :param dns_config_options: Property dnsConfigOptions:.
        :param dns_config_searches: Property dnsConfigSearches: The search domains of the DNS server.
        :param dns_policy: Property dnsPolicy: The Domain Name System (DNS) policy. Valid values: None: uses the DNS that is specified by DnsConfig. Default: uses the DNS that is specified for the runtime environment.
        :param egress_bandwidth: Property egressBandwidth: The maximum outbound bandwidth. Unit: bytes.
        :param eip_bandwidth: Property eipBandwidth: The bandwidth of the EIP. Default value: 5. Unit: Mbit/s.
        :param ephemeral_storage: Property ephemeralStorage: The size of the temporary storage space. By default, an enhanced SSD (ESSD) of the PL1 level is used. Unit: GiB.
        :param host_aliases: Property hostAliases:.
        :param host_name: Property hostName: The hostname of the elastic container instance.
        :param image_registry_credentials: Property imageRegistryCredentials:.
        :param image_snapshot_id: Property imageSnapshotId: The ID of the image cache snapshot.
        :param ingress_bandwidth: Property ingressBandwidth: The maximum inbound bandwidth. Unit: bytes.
        :param init_containers: Property initContainers:.
        :param instance_family_level: Property instanceFamilyLevel: The level of the instance family. You can use this parameter to filter instance types that meet the specified criteria. This parameter takes effect only if you set CostOptimization to true. Valid values: EntryLevel: entry level (shared instance types) Instance types of this level are the most cost-effective but may not provide stable computing performance. Instance types of this level are suitable for scenarios in which CPU utilization is low. For more information, see Shared instance families. EnterpriseLevel: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability. For more information, see Overview of instance families. CreditEntryLevel: credit entry level (burstable instance types). CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which CPU utilization is low but may fluctuate in specific scenarios. For more information, see Overview of burstable instances.
        :param instance_types: Property instanceTypes: The specified ECS instance types. You can specify up to five ECS instance types. For more information, see Specify ECS instance types to create an elastic container instance.
        :param ipv6_address_count: Property ipv6AddressCount: The number of IPv6 addresses.
        :param load_balancer_weight: Property loadBalancerWeight: The weight of the elastic container instance as a backend server. Valid values: 1 to 100. Default value: 50.
        :param memory: Property memory: The memory size that you want to allocate to the elastic container instance. Unit: GiB.
        :param ntp_servers: Property ntpServers: The Network Time Protocol (NTP) server.
        :param ram_role_name: Property ramRoleName: The name of the Resource Access Management (RAM) role that you want to assign to the elastic container instance. Elastic container instances and Elastic Compute Service (ECS) instances can share the same RAM role. For more information, see Use an instance RAM role by calling API operations.
        :param resource_group_id: Property resourceGroupId: The ID of the resource group.
        :param restart_policy: Property restartPolicy: The restart policy of the elastic container instance. Valid values: Always: always restarts the elastic container instance. Never: never restarts the elastic container instance. OnFailure: restarts the elastic container instance upon failures. Default value: Always.
        :param security_context_sysctls: Property securityContextSysctls:.
        :param spot_price_limit: Property spotPriceLimit: The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places. If you set SpotStrategy to SpotWithPriceLimit, you must specify SpotPriceLimit.
        :param spot_strategy: Property spotStrategy: The bidding policy of the instance. Valid values: NoSpot: The instance is created as a pay-as-you-go instance. SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price. SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is used as the bid price. Default value: NoSpot.
        :param tags: Property tags:.
        :param termination_grace_period_seconds: Property terminationGracePeriodSeconds: The buffer period during which a program handles operations before the program is stopped. Unit: seconds.
        :param volumes: Property volumes:.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b78155524ac74038acaeb38336f9eaeeb5bef2f32e15fafca07ef8fa222f89a4)
            check_type(argname="argument container_group_name", value=container_group_name, expected_type=type_hints["container_group_name"])
            check_type(argname="argument scaling_configuration_name", value=scaling_configuration_name, expected_type=type_hints["scaling_configuration_name"])
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument security_group_id", value=security_group_id, expected_type=type_hints["security_group_id"])
            check_type(argname="argument acr_registry_infos", value=acr_registry_infos, expected_type=type_hints["acr_registry_infos"])
            check_type(argname="argument active_deadline_seconds", value=active_deadline_seconds, expected_type=type_hints["active_deadline_seconds"])
            check_type(argname="argument auto_create_eip", value=auto_create_eip, expected_type=type_hints["auto_create_eip"])
            check_type(argname="argument auto_match_image_cache", value=auto_match_image_cache, expected_type=type_hints["auto_match_image_cache"])
            check_type(argname="argument containers", value=containers, expected_type=type_hints["containers"])
            check_type(argname="argument cost_optimization", value=cost_optimization, expected_type=type_hints["cost_optimization"])
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            check_type(argname="argument cpu_options_core", value=cpu_options_core, expected_type=type_hints["cpu_options_core"])
            check_type(argname="argument cpu_options_threads_per_core", value=cpu_options_threads_per_core, expected_type=type_hints["cpu_options_threads_per_core"])
            check_type(argname="argument data_cache_bucket", value=data_cache_bucket, expected_type=type_hints["data_cache_bucket"])
            check_type(argname="argument data_cache_bursting_enabled", value=data_cache_bursting_enabled, expected_type=type_hints["data_cache_bursting_enabled"])
            check_type(argname="argument data_cache_pl", value=data_cache_pl, expected_type=type_hints["data_cache_pl"])
            check_type(argname="argument data_cache_provisioned_iops", value=data_cache_provisioned_iops, expected_type=type_hints["data_cache_provisioned_iops"])
            check_type(argname="argument dns_config_name_servers", value=dns_config_name_servers, expected_type=type_hints["dns_config_name_servers"])
            check_type(argname="argument dns_config_options", value=dns_config_options, expected_type=type_hints["dns_config_options"])
            check_type(argname="argument dns_config_searches", value=dns_config_searches, expected_type=type_hints["dns_config_searches"])
            check_type(argname="argument dns_policy", value=dns_policy, expected_type=type_hints["dns_policy"])
            check_type(argname="argument egress_bandwidth", value=egress_bandwidth, expected_type=type_hints["egress_bandwidth"])
            check_type(argname="argument eip_bandwidth", value=eip_bandwidth, expected_type=type_hints["eip_bandwidth"])
            check_type(argname="argument ephemeral_storage", value=ephemeral_storage, expected_type=type_hints["ephemeral_storage"])
            check_type(argname="argument host_aliases", value=host_aliases, expected_type=type_hints["host_aliases"])
            check_type(argname="argument host_name", value=host_name, expected_type=type_hints["host_name"])
            check_type(argname="argument image_registry_credentials", value=image_registry_credentials, expected_type=type_hints["image_registry_credentials"])
            check_type(argname="argument image_snapshot_id", value=image_snapshot_id, expected_type=type_hints["image_snapshot_id"])
            check_type(argname="argument ingress_bandwidth", value=ingress_bandwidth, expected_type=type_hints["ingress_bandwidth"])
            check_type(argname="argument init_containers", value=init_containers, expected_type=type_hints["init_containers"])
            check_type(argname="argument instance_family_level", value=instance_family_level, expected_type=type_hints["instance_family_level"])
            check_type(argname="argument instance_types", value=instance_types, expected_type=type_hints["instance_types"])
            check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
            check_type(argname="argument load_balancer_weight", value=load_balancer_weight, expected_type=type_hints["load_balancer_weight"])
            check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
            check_type(argname="argument ntp_servers", value=ntp_servers, expected_type=type_hints["ntp_servers"])
            check_type(argname="argument ram_role_name", value=ram_role_name, expected_type=type_hints["ram_role_name"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument restart_policy", value=restart_policy, expected_type=type_hints["restart_policy"])
            check_type(argname="argument security_context_sysctls", value=security_context_sysctls, expected_type=type_hints["security_context_sysctls"])
            check_type(argname="argument spot_price_limit", value=spot_price_limit, expected_type=type_hints["spot_price_limit"])
            check_type(argname="argument spot_strategy", value=spot_strategy, expected_type=type_hints["spot_strategy"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument termination_grace_period_seconds", value=termination_grace_period_seconds, expected_type=type_hints["termination_grace_period_seconds"])
            check_type(argname="argument volumes", value=volumes, expected_type=type_hints["volumes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "container_group_name": container_group_name,
            "scaling_configuration_name": scaling_configuration_name,
            "scaling_group_id": scaling_group_id,
            "security_group_id": security_group_id,
        }
        if acr_registry_infos is not None:
            self._values["acr_registry_infos"] = acr_registry_infos
        if active_deadline_seconds is not None:
            self._values["active_deadline_seconds"] = active_deadline_seconds
        if auto_create_eip is not None:
            self._values["auto_create_eip"] = auto_create_eip
        if auto_match_image_cache is not None:
            self._values["auto_match_image_cache"] = auto_match_image_cache
        if containers is not None:
            self._values["containers"] = containers
        if cost_optimization is not None:
            self._values["cost_optimization"] = cost_optimization
        if cpu is not None:
            self._values["cpu"] = cpu
        if cpu_options_core is not None:
            self._values["cpu_options_core"] = cpu_options_core
        if cpu_options_threads_per_core is not None:
            self._values["cpu_options_threads_per_core"] = cpu_options_threads_per_core
        if data_cache_bucket is not None:
            self._values["data_cache_bucket"] = data_cache_bucket
        if data_cache_bursting_enabled is not None:
            self._values["data_cache_bursting_enabled"] = data_cache_bursting_enabled
        if data_cache_pl is not None:
            self._values["data_cache_pl"] = data_cache_pl
        if data_cache_provisioned_iops is not None:
            self._values["data_cache_provisioned_iops"] = data_cache_provisioned_iops
        if dns_config_name_servers is not None:
            self._values["dns_config_name_servers"] = dns_config_name_servers
        if dns_config_options is not None:
            self._values["dns_config_options"] = dns_config_options
        if dns_config_searches is not None:
            self._values["dns_config_searches"] = dns_config_searches
        if dns_policy is not None:
            self._values["dns_policy"] = dns_policy
        if egress_bandwidth is not None:
            self._values["egress_bandwidth"] = egress_bandwidth
        if eip_bandwidth is not None:
            self._values["eip_bandwidth"] = eip_bandwidth
        if ephemeral_storage is not None:
            self._values["ephemeral_storage"] = ephemeral_storage
        if host_aliases is not None:
            self._values["host_aliases"] = host_aliases
        if host_name is not None:
            self._values["host_name"] = host_name
        if image_registry_credentials is not None:
            self._values["image_registry_credentials"] = image_registry_credentials
        if image_snapshot_id is not None:
            self._values["image_snapshot_id"] = image_snapshot_id
        if ingress_bandwidth is not None:
            self._values["ingress_bandwidth"] = ingress_bandwidth
        if init_containers is not None:
            self._values["init_containers"] = init_containers
        if instance_family_level is not None:
            self._values["instance_family_level"] = instance_family_level
        if instance_types is not None:
            self._values["instance_types"] = instance_types
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if load_balancer_weight is not None:
            self._values["load_balancer_weight"] = load_balancer_weight
        if memory is not None:
            self._values["memory"] = memory
        if ntp_servers is not None:
            self._values["ntp_servers"] = ntp_servers
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if restart_policy is not None:
            self._values["restart_policy"] = restart_policy
        if security_context_sysctls is not None:
            self._values["security_context_sysctls"] = security_context_sysctls
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if tags is not None:
            self._values["tags"] = tags
        if termination_grace_period_seconds is not None:
            self._values["termination_grace_period_seconds"] = termination_grace_period_seconds
        if volumes is not None:
            self._values["volumes"] = volumes

    @builtins.property
    def container_group_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property containerGroupName: The name of the elastic container instance.'''
        result = self._values.get("container_group_name")
        assert result is not None, "Required property 'container_group_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def scaling_configuration_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingConfigurationName: The name of the scaling configuration.

        The name must be 2 to 64 characters in length and can contain letters, digits, underscores (_), hyphens (-), and periods (.). The name must start with a letter or a digit.
        The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
        '''
        result = self._values.get("scaling_configuration_name")
        assert result is not None, "Required property 'scaling_configuration_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: The ID of the scaling group for which you want to create the scaling configuration.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def security_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property securityGroupId: The ID of the security group with which you want to associate the elastic container instance.

        Elastic container instances that are associated with the same security group can access each other.
        If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group and adds the declared container protocols and port numbers to the inbound rules of the security group.
        '''
        result = self._values.get("security_group_id")
        assert result is not None, "Required property 'security_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def acr_registry_infos(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.AcrRegistryInfosProperty"]]]]:
        '''Property acrRegistryInfos:.'''
        result = self._values.get("acr_registry_infos")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.AcrRegistryInfosProperty"]]]], result)

    @builtins.property
    def active_deadline_seconds(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property activeDeadlineSeconds: The validity period of the scaling configuration.

        Unit: seconds.
        '''
        result = self._values.get("active_deadline_seconds")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def auto_create_eip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoCreateEip: Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.'''
        result = self._values.get("auto_create_eip")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def auto_match_image_cache(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoMatchImageCache: Specifies whether to automatically match the image cache.

        Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("auto_match_image_cache")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def containers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ContainersProperty"]]]]:
        '''Property containers:.'''
        result = self._values.get("containers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ContainersProperty"]]]], result)

    @builtins.property
    def cost_optimization(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property costOptimization: Specifies whether to enable the Cost Optimization feature.

        Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("cost_optimization")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cpu(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property cpu: The number of vCPUs that you want to allocate to the elastic container instance.'''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cpu_options_core(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property cpuOptionsCore: The number of physical CPU cores.

        You can specify this parameter for only specific instance types. For more information, see Specify custom CPU options.
        '''
        result = self._values.get("cpu_options_core")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cpu_options_threads_per_core(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property cpuOptionsThreadsPerCore: The number of threads per core.

        You can specify this parameter for only specific instance types. If you set this parameter to 1, Hyper-Threading is disabled. For more information, see Specify custom CPU options.
        '''
        result = self._values.get("cpu_options_threads_per_core")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def data_cache_bucket(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property dataCacheBucket: The bucket that stores data caches.'''
        result = self._values.get("data_cache_bucket")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def data_cache_bursting_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property dataCacheBurstingEnabled: Specifies whether to enable the Performance Burst feature for the ESSD AutoPL disk used for data caching.

        Valid values:
        true
        false
        Default value: false.
        Note
        For more information about ESSD AutoPL disks, see ESSD AutoPL disks.
        '''
        result = self._values.get("data_cache_bursting_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def data_cache_pl(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property dataCachePl: The performance level (PL) of the disk used for data caching.

        We recommend that you use ESSDs. Valid values if you use ESSDs:
        PL0: An ESSD can provide up to 10,000 random read/write IOPS.
        PL1: An ESSD can provide up to 50,000 random read/write IOPS.
        PL2: An ESSD can provide up to 100,000 random read/write IOPS.
        PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
        Default value: PL1.
        Note
        For more information about ESSDs, see ESSDs.
        '''
        result = self._values.get("data_cache_pl")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def data_cache_provisioned_iops(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property dataCacheProvisionedIops: The IOPS provisioned for the ESSD AutoPL disk used for data caching.

        Valid values: 0 to min{50000, 1000 × Capacity - Baseline IOPS}, where Baseline IOPS = min{1800 + 50 × Capacity - 50000}.
        Note
        For more information about ESSD AutoPL disks, see ESSD AutoPL disks.
        '''
        result = self._values.get("data_cache_provisioned_iops")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def dns_config_name_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property dnsConfigNameServers: The IP addresses of the DNS servers.'''
        result = self._values.get("dns_config_name_servers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def dns_config_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.DnsConfigOptionsProperty"]]]]:
        '''Property dnsConfigOptions:.'''
        result = self._values.get("dns_config_options")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.DnsConfigOptionsProperty"]]]], result)

    @builtins.property
    def dns_config_searches(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property dnsConfigSearches: The search domains of the DNS server.'''
        result = self._values.get("dns_config_searches")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def dns_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property dnsPolicy: The Domain Name System (DNS) policy.

        Valid values:
        None: uses the DNS that is specified by DnsConfig.
        Default: uses the DNS that is specified for the runtime environment.
        '''
        result = self._values.get("dns_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def egress_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property egressBandwidth: The maximum outbound bandwidth.

        Unit: bytes.
        '''
        result = self._values.get("egress_bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def eip_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property eipBandwidth: The bandwidth of the EIP.

        Default value: 5. Unit: Mbit/s.
        '''
        result = self._values.get("eip_bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ephemeral_storage(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ephemeralStorage: The size of the temporary storage space.

        By default, an enhanced SSD (ESSD) of the PL1 level is used. Unit: GiB.
        '''
        result = self._values.get("ephemeral_storage")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def host_aliases(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.HostAliasesProperty"]]]]:
        '''Property hostAliases:.'''
        result = self._values.get("host_aliases")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.HostAliasesProperty"]]]], result)

    @builtins.property
    def host_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property hostName: The hostname of the elastic container instance.'''
        result = self._values.get("host_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_registry_credentials(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ImageRegistryCredentialsProperty"]]]]:
        '''Property imageRegistryCredentials:.'''
        result = self._values.get("image_registry_credentials")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ImageRegistryCredentialsProperty"]]]], result)

    @builtins.property
    def image_snapshot_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property imageSnapshotId: The ID of the image cache snapshot.'''
        result = self._values.get("image_snapshot_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ingress_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ingressBandwidth: The maximum inbound bandwidth.

        Unit: bytes.
        '''
        result = self._values.get("ingress_bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def init_containers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainersProperty"]]]]:
        '''Property initContainers:.'''
        result = self._values.get("init_containers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainersProperty"]]]], result)

    @builtins.property
    def instance_family_level(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceFamilyLevel: The level of the instance family.

        You can use this parameter to filter instance types that meet the specified criteria. This parameter takes effect only if you set CostOptimization to true. Valid values:
        EntryLevel: entry level (shared instance types) Instance types of this level are the most cost-effective but may not provide stable computing performance. Instance types of this level are suitable for scenarios in which CPU utilization is low. For more information, see Shared instance families.
        EnterpriseLevel: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability. For more information, see Overview of instance families.
        CreditEntryLevel: credit entry level (burstable instance types). CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which CPU utilization is low but may fluctuate in specific scenarios. For more information, see Overview of burstable instances.
        '''
        result = self._values.get("instance_family_level")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property instanceTypes: The specified ECS instance types.

        You can specify up to five ECS instance types. For more information, see Specify ECS instance types to create an elastic container instance.
        '''
        result = self._values.get("instance_types")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def ipv6_address_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ipv6AddressCount: The number of IPv6 addresses.'''
        result = self._values.get("ipv6_address_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def load_balancer_weight(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property loadBalancerWeight: The weight of the elastic container instance as a backend server.

        Valid values: 1 to 100.
        Default value: 50.
        '''
        result = self._values.get("load_balancer_weight")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def memory(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property memory: The memory size that you want to allocate to the elastic container instance.

        Unit: GiB.
        '''
        result = self._values.get("memory")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ntp_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property ntpServers: The Network Time Protocol (NTP) server.'''
        result = self._values.get("ntp_servers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def ram_role_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ramRoleName: The name of the Resource Access Management (RAM) role that you want to assign to the elastic container instance.

        Elastic container instances and Elastic Compute Service (ECS) instances can share the same RAM role. For more information, see Use an instance RAM role by calling API operations.
        '''
        result = self._values.get("ram_role_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: The ID of the resource group.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def restart_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property restartPolicy: The restart policy of the elastic container instance.

        Valid values:
        Always: always restarts the elastic container instance.
        Never: never restarts the elastic container instance.
        OnFailure: restarts the elastic container instance upon failures.
        Default value: Always.
        '''
        result = self._values.get("restart_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_context_sysctls(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.SecurityContextSysctlsProperty"]]]]:
        '''Property securityContextSysctls:.'''
        result = self._values.get("security_context_sysctls")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.SecurityContextSysctlsProperty"]]]], result)

    @builtins.property
    def spot_price_limit(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotPriceLimit: The maximum hourly price of the preemptible elastic container instance.

        The value can be accurate to three decimal places.
        If you set SpotStrategy to SpotWithPriceLimit, you must specify SpotPriceLimit.
        '''
        result = self._values.get("spot_price_limit")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotStrategy: The bidding policy of the instance.

        Valid values:
        NoSpot: The instance is created as a pay-as-you-go instance.
        SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
        SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is used as the bid price.
        Default value: NoSpot.
        '''
        result = self._values.get("spot_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List["RosEciScalingConfiguration.TagsProperty"]]:
        '''Property tags:.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["RosEciScalingConfiguration.TagsProperty"]], result)

    @builtins.property
    def termination_grace_period_seconds(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property terminationGracePeriodSeconds: The buffer period during which a program handles operations before the program is stopped.

        Unit: seconds.
        '''
        result = self._values.get("termination_grace_period_seconds")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def volumes(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.VolumesProperty"]]]]:
        '''Property volumes:.'''
        result = self._values.get("volumes")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.VolumesProperty"]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EciScalingConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LifecycleHook(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.LifecycleHook",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::LifecycleHook``, which is used to create a lifecycle hook for a scaling group.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosLifecycleHook``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-lifecyclehook
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["LifecycleHookProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a46acbc5eea4a5d296bd421987f038384ed987aab61df47d148ad1b4a2652d98)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrLifecycleHookId")
    def attr_lifecycle_hook_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute LifecycleHookId: The lifecycle hook ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrLifecycleHookId"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingGroupId: The id of the scaling group to which the lifecycle hook belongs.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9af4bc06b84894559ee64939b8493f1f755461c8790a4b0dc1bc0b21a5147036)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff221ff9e556df1d9fc72b3f40ab3dd40db965ab7f0e14d09b55370b3d1a36d0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "LifecycleHookProps":
        return typing.cast("LifecycleHookProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "LifecycleHookProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4aa3f16e803b3cd0cc4eb4a6751c60f5baebfebd7280c4056034163aa459fa9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ad588985aca96043418aa5c3f2a5b04f9b207dfff2c57da644276053f28d34f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.LifecycleHookProps",
    jsii_struct_bases=[],
    name_mapping={
        "lifecycle_transition": "lifecycleTransition",
        "scaling_group_id": "scalingGroupId",
        "default_result": "defaultResult",
        "heartbeat_timeout": "heartbeatTimeout",
        "lifecycle_hook_name": "lifecycleHookName",
        "notification_arn": "notificationArn",
        "notification_metadata": "notificationMetadata",
    },
)
class LifecycleHookProps:
    def __init__(
        self,
        *,
        lifecycle_transition: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        default_result: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        heartbeat_timeout: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        lifecycle_hook_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        notification_arn: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        notification_metadata: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``LifecycleHook``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-lifecyclehook

        :param lifecycle_transition: Property lifecycleTransition: The scaling activities to which lifecycle hooks apply Value range: SCALE_OUT: scale-out event SCALE_IN: scale-in event.
        :param scaling_group_id: Property scalingGroupId: The ID of the scaling group.
        :param default_result: Property defaultResult: The action that the scaling group takes when the lifecycle hook times out. Value range: CONTINUE: the scaling group continues with the scale-in or scale-out process. ABANDON: the scaling group stops any remaining action of the scale-in or scale-out event. Default value: CONTINUE If the scaling group has multiple lifecycle hooks and one of them is terminated by the DefaultResult=ABANDON parameter during a scale-in event (SCALE_IN), the remaining lifecycle hooks under the same scaling group will also be terminated. Otherwise, the action following the wait state is the next action, as specified in the parameter DefaultResult, after the last lifecycle event under the same scaling group.
        :param heartbeat_timeout: Property heartbeatTimeout: The time, in seconds, that can elapse before the lifecycle hook times out. If the lifecycle hook times out, the scaling group performs the default action (DefaultResult). The range is from 30 to 86400 seconds. The default value is 600 seconds. You can prevent the lifecycle hook from timing out by calling the RecordLifecycleActionHeartbeat operation. You can also terminate the lifecycle action by calling the CompleteLifecycleAction operation.
        :param lifecycle_hook_name: Property lifecycleHookName: The name of the lifecycle hook. Each name must be unique within a scaling group. The name must be 2 to 64 characters in length and can contain letters, numbers, Chinese characters, and special characters including underscores (_), hyphens (-) and periods (.). Default value: Lifecycle Hook ID
        :param notification_arn: Property notificationArn: The Alibaba Cloud Resource Name (ARN) of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This target can be either an MNS queue or an MNS topic. The format of the parameter value is acs:ess:{region}:{account-id}:{resource-relative-id}. region: the region to which the scaling group locates account-id: Alibaba Cloud ID For example: MNS queue: acs:ess:{region}:{account-id}:queue/{queuename} MNS topic: acs:ess:{region}:{account-id}:topic/{topicname} OOS template: acs:ess:{region}:{account-id}:oos/{templatename}
        :param notification_metadata: Property notificationMetadata: The fixed string that you want to include when Auto Scaling sends a message about the wait state of the scaling activity to the notification target. The length of the parameter can be up to 4096 characters. Auto Scaling will send the specified NotificationMetadata parameter along with the notification message so that you can easily categorize your notifications. The NotificationMetadata parameter will only take effect after you specify the NotificationArn parameter.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39288e4e5a908e6823a89dff616afc7789d49b00d3caa357804e5bc122c3e567)
            check_type(argname="argument lifecycle_transition", value=lifecycle_transition, expected_type=type_hints["lifecycle_transition"])
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument default_result", value=default_result, expected_type=type_hints["default_result"])
            check_type(argname="argument heartbeat_timeout", value=heartbeat_timeout, expected_type=type_hints["heartbeat_timeout"])
            check_type(argname="argument lifecycle_hook_name", value=lifecycle_hook_name, expected_type=type_hints["lifecycle_hook_name"])
            check_type(argname="argument notification_arn", value=notification_arn, expected_type=type_hints["notification_arn"])
            check_type(argname="argument notification_metadata", value=notification_metadata, expected_type=type_hints["notification_metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "lifecycle_transition": lifecycle_transition,
            "scaling_group_id": scaling_group_id,
        }
        if default_result is not None:
            self._values["default_result"] = default_result
        if heartbeat_timeout is not None:
            self._values["heartbeat_timeout"] = heartbeat_timeout
        if lifecycle_hook_name is not None:
            self._values["lifecycle_hook_name"] = lifecycle_hook_name
        if notification_arn is not None:
            self._values["notification_arn"] = notification_arn
        if notification_metadata is not None:
            self._values["notification_metadata"] = notification_metadata

    @builtins.property
    def lifecycle_transition(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property lifecycleTransition: The scaling activities to which lifecycle hooks apply Value range:   SCALE_OUT: scale-out event   SCALE_IN: scale-in event.'''
        result = self._values.get("lifecycle_transition")
        assert result is not None, "Required property 'lifecycle_transition' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: The ID of the scaling group.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def default_result(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property defaultResult: The action that the scaling group takes when the lifecycle hook times out.

        Value range:
        CONTINUE: the scaling group continues with the scale-in or scale-out process.
        ABANDON: the scaling group stops any remaining action of the scale-in or scale-out event.
        Default value: CONTINUE
        If the scaling group has multiple lifecycle hooks and one of them is terminated by the DefaultResult=ABANDON parameter during a scale-in event (SCALE_IN), the remaining lifecycle hooks under the same scaling group will also be terminated. Otherwise, the action following the wait state is the next action, as specified in the parameter DefaultResult, after the last lifecycle event under the same scaling group.
        '''
        result = self._values.get("default_result")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def heartbeat_timeout(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property heartbeatTimeout: The time, in seconds, that can elapse before the lifecycle hook times out.

        If the lifecycle hook times out, the scaling group performs the default action (DefaultResult). The range is from 30 to 86400 seconds. The default value is 600 seconds.
        You can prevent the lifecycle hook from timing out by calling the RecordLifecycleActionHeartbeat operation. You can also terminate the lifecycle action by calling the CompleteLifecycleAction operation.
        '''
        result = self._values.get("heartbeat_timeout")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def lifecycle_hook_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property lifecycleHookName: The name of the lifecycle hook.

        Each name must be unique within a scaling group. The name must be 2 to 64 characters in length and can contain letters, numbers, Chinese characters, and special characters including underscores (_), hyphens (-) and periods (.).
        Default value: Lifecycle Hook ID
        '''
        result = self._values.get("lifecycle_hook_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def notification_arn(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property notificationArn: The Alibaba Cloud Resource Name (ARN) of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook.

        This target can be either an MNS queue or an MNS topic. The format of the parameter value is acs:ess:{region}:{account-id}:{resource-relative-id}.
        region: the region to which the scaling group locates
        account-id: Alibaba Cloud ID
        For example:
        MNS queue: acs:ess:{region}:{account-id}:queue/{queuename}
        MNS topic: acs:ess:{region}:{account-id}:topic/{topicname}
        OOS template: acs:ess:{region}:{account-id}:oos/{templatename}
        '''
        result = self._values.get("notification_arn")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def notification_metadata(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property notificationMetadata: The fixed string that you want to include when Auto Scaling sends a message about the wait state of the scaling activity to the notification target.

        The length of the parameter can be up to 4096 characters. Auto Scaling will send the specified NotificationMetadata parameter along with the notification message so that you can easily categorize your notifications. The NotificationMetadata parameter will only take effect after you specify the NotificationArn parameter.
        '''
        result = self._values.get("notification_metadata")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LifecycleHookProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LoadBalancerAttachment(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.LoadBalancerAttachment",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::LoadBalancerAttachment``, which is used to add one or more Server Load Balancer (SLB) instances.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosLoadBalancerAttachment``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-loadbalancerattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["LoadBalancerAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62fe53d34abac965cf63ba70dddd384ffbbf6e7b88df744d6e4ffb35e5650dd7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__746e2946fec566d7a4484982a19c7f0f25accc40e0884075b2b7ce5396b07236)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e4aeecc6037f428cdb9d9c87874e97f65168f12b2981eda77e4ba9ec1ff59b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "LoadBalancerAttachmentProps":
        return typing.cast("LoadBalancerAttachmentProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "LoadBalancerAttachmentProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3eca8a0e5809818dce2237b196af6018ff7b701e40abeffce8116216048e3d88)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89eca0685b8edc16d985a3cf31377c841c0bb6b7cbc36188a9186ab8734bab72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.LoadBalancerAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "force_attach": "forceAttach",
        "load_balancer_configs": "loadBalancerConfigs",
        "load_balancers": "loadBalancers",
    },
)
class LoadBalancerAttachmentProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        load_balancer_configs: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosLoadBalancerAttachment.LoadBalancerConfigsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        load_balancers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ) -> None:
        '''Properties for defining a ``LoadBalancerAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-loadbalancerattachment

        :param scaling_group_id: Property scalingGroupId: The ID of the scaling group.
        :param force_attach: Property forceAttach: Specifies whether to add all instances in the current scaling group to the backend server groups of the attached CLB instance. Valid values: true false Default value: false.
        :param load_balancer_configs: Property loadBalancerConfigs: Load balancer configuration list.
        :param load_balancers: Property loadBalancers: The ID of CLB instance N that you want to attach to the scaling group. Valid values of N: 1 to 5.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d1ebb0e99a7f927dbf70ef94f674316b18b4477d2490cd795522db1f39bae62)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument force_attach", value=force_attach, expected_type=type_hints["force_attach"])
            check_type(argname="argument load_balancer_configs", value=load_balancer_configs, expected_type=type_hints["load_balancer_configs"])
            check_type(argname="argument load_balancers", value=load_balancers, expected_type=type_hints["load_balancers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
        }
        if force_attach is not None:
            self._values["force_attach"] = force_attach
        if load_balancer_configs is not None:
            self._values["load_balancer_configs"] = load_balancer_configs
        if load_balancers is not None:
            self._values["load_balancers"] = load_balancers

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: The ID of the scaling group.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property forceAttach: Specifies whether to add all instances in the current scaling group to the backend server groups of the attached CLB instance.

        Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("force_attach")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def load_balancer_configs(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosLoadBalancerAttachment.LoadBalancerConfigsProperty"]]]]:
        '''Property loadBalancerConfigs: Load balancer configuration list.'''
        result = self._values.get("load_balancer_configs")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosLoadBalancerAttachment.LoadBalancerConfigsProperty"]]]], result)

    @builtins.property
    def load_balancers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property loadBalancers: The ID of CLB instance N that you want to attach to the scaling group.

        Valid values of N: 1 to 5.
        '''
        result = self._values.get("load_balancers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LoadBalancerAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosAlarmTask(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosAlarmTask",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::AlarmTask``, which is used to create a metric-based alarm task.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``AlarmTask`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-alarmtask
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosAlarmTaskProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3eb80b3c31c2b41e5d5e8306df2ab31c4ff39f81b50fe27869f0670ea1bfb40a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6796c5bba06fb562ed8b27c1c6fc84b2909c57695b8e15e7830e8839fb9387fb)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrAlarmTaskId")
    def attr_alarm_task_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: AlarmTaskId: The alarm task ID
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAlarmTaskId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="alarmAction")
    def alarm_action(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''
        :Property: alarmAction: Alarm Actions
        '''
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], jsii.get(self, "alarmAction"))

    @alarm_action.setter
    def alarm_action(
        self,
        value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d13091f926f7657bec2ab7c0cd1af9a4512f4bc5ffa61c0cd120418385223df8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "alarmAction", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5be23e1c30e0fbae43c2696d9b53c74a9a5e2b247c81f3466d5a127a799d60f0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="metricName")
    def metric_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: metricName: Metric Name
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "metricName"))

    @metric_name.setter
    def metric_name(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f9dfdbb38418540a3d26cd424eeb263ef91660ec877023f7c95d7c0e12fd5a1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "metricName", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8136464bf45f1d4649f7aa3ce5212fb707030b8defb693fadf82de892c2a11c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="threshold")
    def threshold(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: threshold: Threshold
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "threshold"))

    @threshold.setter
    def threshold(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e63f19e679a5784a82c81a2b5b95a27fdff751e74206b3b98c7b1ae69249c615)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "threshold", value)

    @builtins.property
    @jsii.member(jsii_name="comparisonOperator")
    def comparison_operator(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: comparisonOperator: Comparison Operator
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "comparisonOperator"))

    @comparison_operator.setter
    def comparison_operator(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f04064a2f89e1ac709550173c46556bc9ae4907a64088c2ba0ec7ad51e7563e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "comparisonOperator", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Description
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d678fc56c0f275e2b7d239bb27d284ca197989f69738f6d40b4f02d2f721aeeb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="dimensions")
    def dimensions(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosAlarmTask.DimensionsProperty"]]]]:
        '''
        :Property: dimensions: Dimensions
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosAlarmTask.DimensionsProperty"]]]], jsii.get(self, "dimensions"))

    @dimensions.setter
    def dimensions(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosAlarmTask.DimensionsProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bf48aa27bda8ead168e18ce80b7e0a45dc2cfcc6ebd5e3edc02bc3d44bc578d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dimensions", value)

    @builtins.property
    @jsii.member(jsii_name="evaluationCount")
    def evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: evaluationCount: Evaluation Count
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "evaluationCount"))

    @evaluation_count.setter
    def evaluation_count(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ab01163c87782e041f2f0bfbf071af73581984504f002b705c2722f362b25ab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "evaluationCount", value)

    @builtins.property
    @jsii.member(jsii_name="groupId")
    def group_id(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: groupId: Group Id
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "groupId"))

    @group_id.setter
    def group_id(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17931261e9b56f5f58c5171c0f60301ccb8a2bcefb7a3b3eb833044ed170ac59)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "groupId", value)

    @builtins.property
    @jsii.member(jsii_name="metricType")
    def metric_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: metricType: Metric Type
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "metricType"))

    @metric_type.setter
    def metric_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccc57156b5d9f1d2228b9ac46f7627fecfeea0acec4ace57edb6317bc70badc0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "metricType", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: Name
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a013839a3b7b21230a3f8e9e7325093061786b809abb176f5dda53d02e2a5405)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="period")
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: period: Period
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "period"))

    @period.setter
    def period(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1cdfaba7837beb53a11dbaf264a0b400a5c20ef658526e476b8a8282fa48cbea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "period", value)

    @builtins.property
    @jsii.member(jsii_name="statistics")
    def statistics(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: statistics: Statistics
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "statistics"))

    @statistics.setter
    def statistics(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c54d43d13fd887073f924482638470f8912d843b7ed472754f29ec8d2a24da77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "statistics", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosAlarmTask.DimensionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "dimension_key": "dimensionKey",
            "dimension_value": "dimensionValue",
        },
    )
    class DimensionsProperty:
        def __init__(
            self,
            *,
            dimension_key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            dimension_value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ) -> None:
            '''
            :param dimension_key: 
            :param dimension_value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__927873148fe5fdcb8f53aef85bccbbe2b446c081291af2be6a7f5f9232e9895a)
                check_type(argname="argument dimension_key", value=dimension_key, expected_type=type_hints["dimension_key"])
                check_type(argname="argument dimension_value", value=dimension_value, expected_type=type_hints["dimension_value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "dimension_key": dimension_key,
                "dimension_value": dimension_value,
            }

        @builtins.property
        def dimension_key(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: dimensionKey: DimensionKey
            '''
            result = self._values.get("dimension_key")
            assert result is not None, "Required property 'dimension_key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def dimension_value(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: dimensionValue: DimensionValue
            '''
            result = self._values.get("dimension_value")
            assert result is not None, "Required property 'dimension_value' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DimensionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosAlarmTaskEnable(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosAlarmTaskEnable",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::AlarmTaskEnable``, which is used to start an alarm task.

    You can call this operation to enable alarm tasks when the task is stopped.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``AlarmTaskEnable`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-alarmtaskenable
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosAlarmTaskEnableProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86714b938065c8c7d6551a5b836f5b46d7cf74e5faccc01f30939895d0504650)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1970446a951382325d8bec921e95b93e0485e8f35b67350dc17f65380c338d2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="alarmTaskId")
    def alarm_task_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: alarmTaskId: The id of alarm task.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "alarmTaskId"))

    @alarm_task_id.setter
    def alarm_task_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34b3fadf57d5228431617808f59a3be4380027130b828d42a521dfb6de499dc5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "alarmTaskId", value)

    @builtins.property
    @jsii.member(jsii_name="enable")
    def enable(self) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: enable: Enable alarm task or not
        '''
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "enable"))

    @enable.setter
    def enable(
        self,
        value: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79d619ff674ae5d503a6a7fa65e2e003480eaedefc0f4a732de13c065df2eaa5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enable", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e31943b5be512c8bde7ae0e7022c0afe238ce1916157a33ea595a13e8c320b3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosAlarmTaskEnableProps",
    jsii_struct_bases=[],
    name_mapping={"alarm_task_id": "alarmTaskId", "enable": "enable"},
)
class RosAlarmTaskEnableProps:
    def __init__(
        self,
        *,
        alarm_task_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        enable: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``RosAlarmTaskEnable``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-alarmtaskenable

        :param alarm_task_id: 
        :param enable: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2de0f32081aceab0bd1817d06a630419b7a6bbb55ef1059547c5a925dd800847)
            check_type(argname="argument alarm_task_id", value=alarm_task_id, expected_type=type_hints["alarm_task_id"])
            check_type(argname="argument enable", value=enable, expected_type=type_hints["enable"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "alarm_task_id": alarm_task_id,
            "enable": enable,
        }

    @builtins.property
    def alarm_task_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: alarmTaskId: The id of alarm task.
        '''
        result = self._values.get("alarm_task_id")
        assert result is not None, "Required property 'alarm_task_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def enable(self) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: enable: Enable alarm task or not
        '''
        result = self._values.get("enable")
        assert result is not None, "Required property 'enable' is missing"
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosAlarmTaskEnableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosAlarmTaskProps",
    jsii_struct_bases=[],
    name_mapping={
        "alarm_action": "alarmAction",
        "metric_name": "metricName",
        "scaling_group_id": "scalingGroupId",
        "threshold": "threshold",
        "comparison_operator": "comparisonOperator",
        "description": "description",
        "dimensions": "dimensions",
        "evaluation_count": "evaluationCount",
        "group_id": "groupId",
        "metric_type": "metricType",
        "name": "name",
        "period": "period",
        "statistics": "statistics",
    },
)
class RosAlarmTaskProps:
    def __init__(
        self,
        *,
        alarm_action: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
        metric_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        threshold: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        comparison_operator: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        dimensions: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosAlarmTask.DimensionsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        group_id: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        metric_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        statistics: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosAlarmTask``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-alarmtask

        :param alarm_action: 
        :param metric_name: 
        :param scaling_group_id: 
        :param threshold: 
        :param comparison_operator: 
        :param description: 
        :param dimensions: 
        :param evaluation_count: 
        :param group_id: 
        :param metric_type: 
        :param name: 
        :param period: 
        :param statistics: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0c045eb527f889a67d502b0666891d9bb0b606496d0933a7ee0844124901b24)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument dimensions", value=dimensions, expected_type=type_hints["dimensions"])
            check_type(argname="argument evaluation_count", value=evaluation_count, expected_type=type_hints["evaluation_count"])
            check_type(argname="argument group_id", value=group_id, expected_type=type_hints["group_id"])
            check_type(argname="argument metric_type", value=metric_type, expected_type=type_hints["metric_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument statistics", value=statistics, expected_type=type_hints["statistics"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "alarm_action": alarm_action,
            "metric_name": metric_name,
            "scaling_group_id": scaling_group_id,
            "threshold": threshold,
        }
        if comparison_operator is not None:
            self._values["comparison_operator"] = comparison_operator
        if description is not None:
            self._values["description"] = description
        if dimensions is not None:
            self._values["dimensions"] = dimensions
        if evaluation_count is not None:
            self._values["evaluation_count"] = evaluation_count
        if group_id is not None:
            self._values["group_id"] = group_id
        if metric_type is not None:
            self._values["metric_type"] = metric_type
        if name is not None:
            self._values["name"] = name
        if period is not None:
            self._values["period"] = period
        if statistics is not None:
            self._values["statistics"] = statistics

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''
        :Property: alarmAction: Alarm Actions
        '''
        result = self._values.get("alarm_action")
        assert result is not None, "Required property 'alarm_action' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], result)

    @builtins.property
    def metric_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: metricName: Metric Name
        '''
        result = self._values.get("metric_name")
        assert result is not None, "Required property 'metric_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def threshold(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: threshold: Threshold
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def comparison_operator(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: comparisonOperator: Comparison Operator
        '''
        result = self._values.get("comparison_operator")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def dimensions(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosAlarmTask.DimensionsProperty]]]]:
        '''
        :Property: dimensions: Dimensions
        '''
        result = self._values.get("dimensions")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosAlarmTask.DimensionsProperty]]]], result)

    @builtins.property
    def evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: evaluationCount: Evaluation Count
        '''
        result = self._values.get("evaluation_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def group_id(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: groupId: Group Id
        '''
        result = self._values.get("group_id")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def metric_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: metricType: Metric Type
        '''
        result = self._values.get("metric_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: Name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: period: Period
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def statistics(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: statistics: Statistics
        '''
        result = self._values.get("statistics")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosAlarmTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosEciScalingConfiguration(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::EciScalingConfiguration``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``EciScalingConfiguration`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-eciscalingconfiguration
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosEciScalingConfigurationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5c1d94e48e33f7c11cff82fa747cc05fcbee422c36ac85018b8998da9e5330a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a3e3294dbf857cc26d0ad249e1f1b8b9cee070ec11e23b04db4d18205129ffd)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingConfigurationId")
    def attr_scaling_configuration_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingConfigurationId: The ID of the elastic container instance.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingConfigurationId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="containerGroupName")
    def container_group_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: containerGroupName: The name of the elastic container instance.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "containerGroupName"))

    @container_group_name.setter
    def container_group_name(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1595b8ec5e3da517ddace113991e16e62d1b107fa5987e8bbc78ba09415ad084)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "containerGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72927c36addd5fa805153680e32f83e92782374d6a9147bf1a126c2f9a71ea3a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="scalingConfigurationName")
    def scaling_configuration_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        scalingConfigurationName: The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (_), hyphens (-), and periods (.). The name must start with a letter or a digit.
        The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingConfigurationName"))

    @scaling_configuration_name.setter
    def scaling_configuration_name(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94f6e933d6afe07f84353132c90b2c0ee4fe8351b48f7349aa2afe4f59304c7e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingConfigurationName", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group for which you want to create the scaling configuration.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dde602ec77cd02f6692bd27676aae7f8111565e0eec9c81235161b31c8973f0b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        securityGroupId: The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other.
        If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group and adds the declared container protocols and port numbers to the inbound rules of the security group.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "securityGroupId"))

    @security_group_id.setter
    def security_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3583b534df7dd65037666c0286c6363790ecaa6ea04cf6aa5be3f5060b8de8bb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="acrRegistryInfos")
    def acr_registry_infos(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.AcrRegistryInfosProperty"]]]]:
        '''
        :Property: acrRegistryInfos:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.AcrRegistryInfosProperty"]]]], jsii.get(self, "acrRegistryInfos"))

    @acr_registry_infos.setter
    def acr_registry_infos(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.AcrRegistryInfosProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42111fcfbee6e8903c4f61cf9cdb4de02c197e1c631edb2ad8e1e3401a42aeef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "acrRegistryInfos", value)

    @builtins.property
    @jsii.member(jsii_name="activeDeadlineSeconds")
    def active_deadline_seconds(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: activeDeadlineSeconds: The validity period of the scaling configuration. Unit: seconds.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "activeDeadlineSeconds"))

    @active_deadline_seconds.setter
    def active_deadline_seconds(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e63dc0c8d127b685f76869b976495db17f20e3199302e0c79321197c4d13ae39)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "activeDeadlineSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="autoCreateEip")
    def auto_create_eip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: autoCreateEip: Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoCreateEip"))

    @auto_create_eip.setter
    def auto_create_eip(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8757955c0cf1cc3e869168b326a422a2cba4b5793de85f1d5f3df722c82b3fc0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoCreateEip", value)

    @builtins.property
    @jsii.member(jsii_name="autoMatchImageCache")
    def auto_match_image_cache(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoMatchImageCache: Specifies whether to automatically match the image cache. Valid values:
        true
        false
        Default value: false.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoMatchImageCache"))

    @auto_match_image_cache.setter
    def auto_match_image_cache(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88db3b098d11a0e5ef570688afa5c70e361e87be936e85349590ff30c1200f72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoMatchImageCache", value)

    @builtins.property
    @jsii.member(jsii_name="containers")
    def containers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ContainersProperty"]]]]:
        '''
        :Property: containers:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ContainersProperty"]]]], jsii.get(self, "containers"))

    @containers.setter
    def containers(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ContainersProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5516e351022bc8f40e28ff7051321cef8ca3780483f0b0cc54b1c258f164a21)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "containers", value)

    @builtins.property
    @jsii.member(jsii_name="costOptimization")
    def cost_optimization(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        costOptimization: Specifies whether to enable the Cost Optimization feature. Valid values:
        true
        false
        Default value: false.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "costOptimization"))

    @cost_optimization.setter
    def cost_optimization(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7a172789d99e1f9e20f43f8e0b2de99781427287dd96ca9f30ff9c126905bcb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "costOptimization", value)

    @builtins.property
    @jsii.member(jsii_name="cpu")
    def cpu(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: cpu: The number of vCPUs that you want to allocate to the elastic container instance.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "cpu"))

    @cpu.setter
    def cpu(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__902a3a398b334da43384a2979e01b8b06dae114cf3161f3f0c8e5a7511ea6c04)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpu", value)

    @builtins.property
    @jsii.member(jsii_name="cpuOptionsCore")
    def cpu_options_core(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: cpuOptionsCore: The number of physical CPU cores. You can specify this parameter for only specific instance types. For more information, see Specify custom CPU options.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "cpuOptionsCore"))

    @cpu_options_core.setter
    def cpu_options_core(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4956467311e5c365b2c53cd45bb5c970e4b243a305b90e8f660a9eda1679cf07)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpuOptionsCore", value)

    @builtins.property
    @jsii.member(jsii_name="cpuOptionsThreadsPerCore")
    def cpu_options_threads_per_core(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: cpuOptionsThreadsPerCore: The number of threads per core. You can specify this parameter for only specific instance types. If you set this parameter to 1, Hyper-Threading is disabled. For more information, see Specify custom CPU options.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "cpuOptionsThreadsPerCore"))

    @cpu_options_threads_per_core.setter
    def cpu_options_threads_per_core(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c614f008a578647d4a412bcd1e04f2ccf5a91b92950183820dddc5e0bd7ebd9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpuOptionsThreadsPerCore", value)

    @builtins.property
    @jsii.member(jsii_name="dataCacheBucket")
    def data_cache_bucket(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: dataCacheBucket: The bucket that stores data caches.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "dataCacheBucket"))

    @data_cache_bucket.setter
    def data_cache_bucket(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6462fa76bd6299f1707f61143118800858865af0efa9797e6ef6d471622f3e2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dataCacheBucket", value)

    @builtins.property
    @jsii.member(jsii_name="dataCacheBurstingEnabled")
    def data_cache_bursting_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dataCacheBurstingEnabled: Specifies whether to enable the Performance Burst feature for the ESSD AutoPL disk used for data caching. Valid values:
        true
        false
        Default value: false.
        Note
        For more information about ESSD AutoPL disks, see ESSD AutoPL disks.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "dataCacheBurstingEnabled"))

    @data_cache_bursting_enabled.setter
    def data_cache_bursting_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28ab08981010c07df6f5846d7baeffd912824407b74d334e2c85ff040ec92f22)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dataCacheBurstingEnabled", value)

    @builtins.property
    @jsii.member(jsii_name="dataCachePl")
    def data_cache_pl(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dataCachePl: The performance level (PL) of the disk used for data caching. We recommend that you use ESSDs. Valid values if you use ESSDs:
        PL0: An ESSD can provide up to 10,000 random read/write IOPS.
        PL1: An ESSD can provide up to 50,000 random read/write IOPS.
        PL2: An ESSD can provide up to 100,000 random read/write IOPS.
        PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
        Default value: PL1.
        Note
        For more information about ESSDs, see ESSDs.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "dataCachePl"))

    @data_cache_pl.setter
    def data_cache_pl(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc78e6dcb307e70c2de75fa9c29dd6fad33d839c8ef19b9d1f6792135603b97d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dataCachePl", value)

    @builtins.property
    @jsii.member(jsii_name="dataCacheProvisionedIops")
    def data_cache_provisioned_iops(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dataCacheProvisionedIops: The IOPS provisioned for the ESSD AutoPL disk used for data caching. Valid values: 0 to min{50000, 1000 × Capacity - Baseline IOPS}, where Baseline IOPS = min{1800 + 50 × Capacity - 50000}.
        Note
        For more information about ESSD AutoPL disks, see ESSD AutoPL disks.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "dataCacheProvisionedIops"))

    @data_cache_provisioned_iops.setter
    def data_cache_provisioned_iops(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adf18b16be00a0fa4b04b5e86a445a88ff719230e167031ae6f44e28ade7cadc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dataCacheProvisionedIops", value)

    @builtins.property
    @jsii.member(jsii_name="dnsConfigNameServers")
    def dns_config_name_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: dnsConfigNameServers: The IP addresses of the DNS servers.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "dnsConfigNameServers"))

    @dns_config_name_servers.setter
    def dns_config_name_servers(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__691bff489f315813d8c476193056b568b4d4aa6edc5360d7f869577882d98a09)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dnsConfigNameServers", value)

    @builtins.property
    @jsii.member(jsii_name="dnsConfigOptions")
    def dns_config_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.DnsConfigOptionsProperty"]]]]:
        '''
        :Property: dnsConfigOptions:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.DnsConfigOptionsProperty"]]]], jsii.get(self, "dnsConfigOptions"))

    @dns_config_options.setter
    def dns_config_options(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.DnsConfigOptionsProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9987613d95bf4fdde8ceb05188229da7135a6033a0a8de66664cd9b2cabdb78a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dnsConfigOptions", value)

    @builtins.property
    @jsii.member(jsii_name="dnsConfigSearches")
    def dns_config_searches(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: dnsConfigSearches: The search domains of the DNS server.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "dnsConfigSearches"))

    @dns_config_searches.setter
    def dns_config_searches(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd64aab24843f9f7cc07c8200033042422e592ea2d71f7beea3c099b2deddb53)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dnsConfigSearches", value)

    @builtins.property
    @jsii.member(jsii_name="dnsPolicy")
    def dns_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dnsPolicy: The Domain Name System (DNS) policy. Valid values:
        None: uses the DNS that is specified by DnsConfig.
        Default: uses the DNS that is specified for the runtime environment.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "dnsPolicy"))

    @dns_policy.setter
    def dns_policy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af8fb157cecd753253ed5705e919281efd7475c51a569c96b7c5d91633274702)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dnsPolicy", value)

    @builtins.property
    @jsii.member(jsii_name="egressBandwidth")
    def egress_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: egressBandwidth: The maximum outbound bandwidth. Unit: bytes.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "egressBandwidth"))

    @egress_bandwidth.setter
    def egress_bandwidth(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9688d2b9e7e41ee9fc41379f5b0b865267b294813ff15442f5e230acf67a9b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "egressBandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="eipBandwidth")
    def eip_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: eipBandwidth: The bandwidth of the EIP. Default value: 5. Unit: Mbit/s.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "eipBandwidth"))

    @eip_bandwidth.setter
    def eip_bandwidth(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5b9a2f7d5dfd55e285dc20bc33844be609fb08cfdcf31df2dc441e390102b70)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "eipBandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="ephemeralStorage")
    def ephemeral_storage(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ephemeralStorage: The size of the temporary storage space. By default, an enhanced SSD (ESSD) of the PL1 level is used. Unit: GiB.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ephemeralStorage"))

    @ephemeral_storage.setter
    def ephemeral_storage(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f330a91967ee74512abca49e70ef3981a53d6b183f40dc1821c78633add371b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ephemeralStorage", value)

    @builtins.property
    @jsii.member(jsii_name="hostAliases")
    def host_aliases(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.HostAliasesProperty"]]]]:
        '''
        :Property: hostAliases:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.HostAliasesProperty"]]]], jsii.get(self, "hostAliases"))

    @host_aliases.setter
    def host_aliases(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.HostAliasesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f10803aace714c609259512b015d4b968f6852d898fc5979e82e2963cf09a9f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hostAliases", value)

    @builtins.property
    @jsii.member(jsii_name="hostName")
    def host_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: hostName: The hostname of the elastic container instance.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "hostName"))

    @host_name.setter
    def host_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09559f30fd79d7881f7c5a58c0ba7e7323d087ff06084807f5c696180d35e796)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hostName", value)

    @builtins.property
    @jsii.member(jsii_name="imageRegistryCredentials")
    def image_registry_credentials(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ImageRegistryCredentialsProperty"]]]]:
        '''
        :Property: imageRegistryCredentials:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ImageRegistryCredentialsProperty"]]]], jsii.get(self, "imageRegistryCredentials"))

    @image_registry_credentials.setter
    def image_registry_credentials(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ImageRegistryCredentialsProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__051082393b01b48fba2c600d4549f3f05d9e9bb46937ba7f8b70a58deba52af9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageRegistryCredentials", value)

    @builtins.property
    @jsii.member(jsii_name="imageSnapshotId")
    def image_snapshot_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: imageSnapshotId: The ID of the image cache snapshot.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "imageSnapshotId"))

    @image_snapshot_id.setter
    def image_snapshot_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b139b8a2372e89acb4a7e6f117f9712b3f6aefb1fc2cbf8b946b589ea656eafa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageSnapshotId", value)

    @builtins.property
    @jsii.member(jsii_name="ingressBandwidth")
    def ingress_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ingressBandwidth: The maximum inbound bandwidth. Unit: bytes.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ingressBandwidth"))

    @ingress_bandwidth.setter
    def ingress_bandwidth(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7a88b415c60df09821be0bbec34114ae1ad44b87ff9305896878c67cd4852ec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ingressBandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="initContainers")
    def init_containers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainersProperty"]]]]:
        '''
        :Property: initContainers:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainersProperty"]]]], jsii.get(self, "initContainers"))

    @init_containers.setter
    def init_containers(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainersProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c69aec5915dad12a97a657096c044663095c5975528b2539515603ed2377edd7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "initContainers", value)

    @builtins.property
    @jsii.member(jsii_name="instanceFamilyLevel")
    def instance_family_level(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        instanceFamilyLevel: The level of the instance family. You can use this parameter to filter instance types that meet the specified criteria. This parameter takes effect only if you set CostOptimization to true. Valid values:
        EntryLevel: entry level (shared instance types) Instance types of this level are the most cost-effective but may not provide stable computing performance. Instance types of this level are suitable for scenarios in which CPU utilization is low. For more information, see Shared instance families.
        EnterpriseLevel: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability. For more information, see Overview of instance families.
        CreditEntryLevel: credit entry level (burstable instance types). CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which CPU utilization is low but may fluctuate in specific scenarios. For more information, see Overview of burstable instances.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceFamilyLevel"))

    @instance_family_level.setter
    def instance_family_level(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0765a982548e8019b4cc835d12b495dd6686df931cde340be744774de190808)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceFamilyLevel", value)

    @builtins.property
    @jsii.member(jsii_name="instanceTypes")
    def instance_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: instanceTypes: The specified ECS instance types. You can specify up to five ECS instance types. For more information, see Specify ECS instance types to create an elastic container instance.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "instanceTypes"))

    @instance_types.setter
    def instance_types(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0766ca54140ce9f286c0a5d4390196da15f7c50ec5bab58119a411bb2b6ab94)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceTypes", value)

    @builtins.property
    @jsii.member(jsii_name="ipv6AddressCount")
    def ipv6_address_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipv6AddressCount: The number of IPv6 addresses.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ipv6AddressCount"))

    @ipv6_address_count.setter
    def ipv6_address_count(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6ecd64860aeffee7d3dd0d028ae6d50568440acfd770605fe2279fe94b3397c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipv6AddressCount", value)

    @builtins.property
    @jsii.member(jsii_name="loadBalancerWeight")
    def load_balancer_weight(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        loadBalancerWeight: The weight of the elastic container instance as a backend server. Valid values: 1 to 100.
        Default value: 50.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "loadBalancerWeight"))

    @load_balancer_weight.setter
    def load_balancer_weight(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5651e4badd54d1c278f026f1c3b650aff370ea7d5994c22b4e2550772a794335)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loadBalancerWeight", value)

    @builtins.property
    @jsii.member(jsii_name="memory")
    def memory(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: memory: The memory size that you want to allocate to the elastic container instance. Unit: GiB.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "memory"))

    @memory.setter
    def memory(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__604e64f92e92a95bce3e77875844beaad21cb43c659eb9dadb509c96f9103b13)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "memory", value)

    @builtins.property
    @jsii.member(jsii_name="ntpServers")
    def ntp_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: ntpServers: The Network Time Protocol (NTP) server.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "ntpServers"))

    @ntp_servers.setter
    def ntp_servers(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1904679c97e96f6e3e2a578d338e55a936e23f253d8139d00e7223221fd28676)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ntpServers", value)

    @builtins.property
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ramRoleName: The name of the Resource Access Management (RAM) role that you want to assign to the elastic container instance. Elastic container instances and Elastic Compute Service (ECS) instances can share the same RAM role. For more information, see Use an instance RAM role by calling API operations.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ramRoleName"))

    @ram_role_name.setter
    def ram_role_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b939e8a62fd22d50f7e3bbbf04e8bd190477b580a1a6017bf04f62c3d5fce1c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ramRoleName", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e6ff50eb2b3fd06f75a7d580e47cf7260bc428733fa5ee1bbdd2d8ed18e7a96)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="restartPolicy")
    def restart_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        restartPolicy: The restart policy of the elastic container instance. Valid values:
        Always: always restarts the elastic container instance.
        Never: never restarts the elastic container instance.
        OnFailure: restarts the elastic container instance upon failures.
        Default value: Always.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "restartPolicy"))

    @restart_policy.setter
    def restart_policy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3aeb9eeffa8af2804227b16c12ee7457a4a25eaf4886e67a552976b6ff63e170)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "restartPolicy", value)

    @builtins.property
    @jsii.member(jsii_name="securityContextSysctls")
    def security_context_sysctls(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.SecurityContextSysctlsProperty"]]]]:
        '''
        :Property: securityContextSysctls:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.SecurityContextSysctlsProperty"]]]], jsii.get(self, "securityContextSysctls"))

    @security_context_sysctls.setter
    def security_context_sysctls(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.SecurityContextSysctlsProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eeb197eebe6c1d30ac58f865ad36473558e213cfb4f3cdaeef465c57f77666d0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityContextSysctls", value)

    @builtins.property
    @jsii.member(jsii_name="spotPriceLimit")
    def spot_price_limit(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotPriceLimit: The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places.
        If you set SpotStrategy to SpotWithPriceLimit, you must specify SpotPriceLimit.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotPriceLimit"))

    @spot_price_limit.setter
    def spot_price_limit(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f832f5175c578e5c76a5de2e20c3fca71a08e83a21d3003273219f1cd2aa3b7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotPriceLimit", value)

    @builtins.property
    @jsii.member(jsii_name="spotStrategy")
    def spot_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotStrategy: The bidding policy of the instance. Valid values:
        NoSpot: The instance is created as a pay-as-you-go instance.
        SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
        SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is used as the bid price.
        Default value: NoSpot.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotStrategy"))

    @spot_strategy.setter
    def spot_strategy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98a84689628f1be8faf60c63ea4078da47c4ada57f1e3e716ee70f76444d1c19)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotStrategy", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(
        self,
    ) -> typing.Optional[typing.List["RosEciScalingConfiguration.TagsProperty"]]:
        '''
        :Property: tags:
        '''
        return typing.cast(typing.Optional[typing.List["RosEciScalingConfiguration.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosEciScalingConfiguration.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09dd498a8613c77a13c0cacc2d7c0c236e7c95ed31f7975dec9a0bb84d2c4933)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @builtins.property
    @jsii.member(jsii_name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: terminationGracePeriodSeconds: The buffer period during which a program handles operations before the program is stopped. Unit: seconds.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "terminationGracePeriodSeconds"))

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__750e2f6a89e95b266866b93549b02571282af0889311af450d32b0dea9cef258)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terminationGracePeriodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="volumes")
    def volumes(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.VolumesProperty"]]]]:
        '''
        :Property: volumes:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.VolumesProperty"]]]], jsii.get(self, "volumes"))

    @volumes.setter
    def volumes(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.VolumesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62c38703c1d958c2ece5966398176faf79d5456d3d855808a9a0d8d4d46b214b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "volumes", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.AcrRegistryInfosProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instance_id": "instanceId",
            "domains": "domains",
            "instance_name": "instanceName",
            "region_id": "regionId",
        },
    )
    class AcrRegistryInfosProperty:
        def __init__(
            self,
            *,
            instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            domains: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            instance_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param instance_id: 
            :param domains: 
            :param instance_name: 
            :param region_id: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0bafeb7b65a226e8881fa92dd717db233d3ba7b39fb180ffe980555366f7476c)
                check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
                check_type(argname="argument domains", value=domains, expected_type=type_hints["domains"])
                check_type(argname="argument instance_name", value=instance_name, expected_type=type_hints["instance_name"])
                check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "instance_id": instance_id,
            }
            if domains is not None:
                self._values["domains"] = domains
            if instance_name is not None:
                self._values["instance_name"] = instance_name
            if region_id is not None:
                self._values["region_id"] = region_id

        @builtins.property
        def instance_id(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: instanceId: The ID of the Container Registry Enterprise Edition instance.
            '''
            result = self._values.get("instance_id")
            assert result is not None, "Required property 'instance_id' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def domains(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property: domains: The domain names of the Container Registry Enterprise Edition instance. By default, all domain names of the instance are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).
            '''
            result = self._values.get("domains")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def instance_name(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: instanceName: The name of the Container Registry Enterprise Edition instance.
            '''
            result = self._values.get("instance_name")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def region_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: regionId: The region ID of the Container Registry Enterprise Edition instance.
            '''
            result = self._values.get("region_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcrRegistryInfosProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.ConfigFileVolumeConfigFileToPathsProperty",
        jsii_struct_bases=[],
        name_mapping={"path": "path", "content": "content", "mode": "mode"},
    )
    class ConfigFileVolumeConfigFileToPathsProperty:
        def __init__(
            self,
            *,
            path: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            content: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            mode: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param path: 
            :param content: 
            :param mode: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__887853bfac1a566d05500956a325457df796764eb16d9292ce95bc979b258a70)
                check_type(argname="argument path", value=path, expected_type=type_hints["path"])
                check_type(argname="argument content", value=content, expected_type=type_hints["content"])
                check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "path": path,
            }
            if content is not None:
                self._values["content"] = content
            if mode is not None:
                self._values["mode"] = mode

        @builtins.property
        def path(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: path: The relative path to the configuration file.
            '''
            result = self._values.get("path")
            assert result is not None, "Required property 'path' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def content(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: content: The content of the configuration file (32 KB).
            '''
            result = self._values.get("content")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def mode(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: mode: The permissions on the ConfigFileVolume directory.
            '''
            result = self._values.get("mode")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConfigFileVolumeConfigFileToPathsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.ContainersProperty",
        jsii_struct_bases=[],
        name_mapping={
            "image": "image",
            "name": "name",
            "args": "args",
            "commands": "commands",
            "cpu": "cpu",
            "environment_vars": "environmentVars",
            "gpu": "gpu",
            "image_pull_policy": "imagePullPolicy",
            "liveness_probe_exec_commands": "livenessProbeExecCommands",
            "liveness_probe_failure_threshold": "livenessProbeFailureThreshold",
            "liveness_probe_http_get_path": "livenessProbeHttpGetPath",
            "liveness_probe_http_get_port": "livenessProbeHttpGetPort",
            "liveness_probe_http_get_scheme": "livenessProbeHttpGetScheme",
            "liveness_probe_initial_delay_seconds": "livenessProbeInitialDelaySeconds",
            "liveness_probe_period_seconds": "livenessProbePeriodSeconds",
            "liveness_probe_success_threshold": "livenessProbeSuccessThreshold",
            "liveness_probe_tcp_socket_port": "livenessProbeTcpSocketPort",
            "liveness_probe_timeout_seconds": "livenessProbeTimeoutSeconds",
            "memory": "memory",
            "ports": "ports",
            "readiness_probe_exec_commands": "readinessProbeExecCommands",
            "readiness_probe_failure_threshold": "readinessProbeFailureThreshold",
            "readiness_probe_http_get_path": "readinessProbeHttpGetPath",
            "readiness_probe_http_get_port": "readinessProbeHttpGetPort",
            "readiness_probe_http_get_scheme": "readinessProbeHttpGetScheme",
            "readiness_probe_initial_delay_seconds": "readinessProbeInitialDelaySeconds",
            "readiness_probe_period_seconds": "readinessProbePeriodSeconds",
            "readiness_probe_success_threshold": "readinessProbeSuccessThreshold",
            "readiness_probe_tcp_socket_port": "readinessProbeTcpSocketPort",
            "readiness_probe_timeout_seconds": "readinessProbeTimeoutSeconds",
            "security_context_capabilities_add": "securityContextCapabilitiesAdd",
            "security_context_run_as_user": "securityContextRunAsUser",
            "stdin": "stdin",
            "stdin_once": "stdinOnce",
            "tty": "tty",
            "volume_mounts": "volumeMounts",
            "working_dir": "workingDir",
        },
    )
    class ContainersProperty:
        def __init__(
            self,
            *,
            image: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            args: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            commands: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            environment_vars: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.EnvironmentVarsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            gpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            image_pull_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_exec_commands: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            liveness_probe_failure_threshold: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_http_get_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_http_get_port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_http_get_scheme: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_initial_delay_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_period_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_success_threshold: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_tcp_socket_port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            liveness_probe_timeout_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ports: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.PortsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            readiness_probe_exec_commands: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            readiness_probe_failure_threshold: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            readiness_probe_http_get_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            readiness_probe_http_get_port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            readiness_probe_http_get_scheme: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            readiness_probe_initial_delay_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            readiness_probe_period_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            readiness_probe_success_threshold: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            readiness_probe_tcp_socket_port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            readiness_probe_timeout_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            security_context_capabilities_add: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            security_context_run_as_user: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            stdin: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            stdin_once: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            tty: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            volume_mounts: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.VolumeMountsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            working_dir: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param image: 
            :param name: 
            :param args: 
            :param commands: 
            :param cpu: 
            :param environment_vars: 
            :param gpu: 
            :param image_pull_policy: 
            :param liveness_probe_exec_commands: 
            :param liveness_probe_failure_threshold: 
            :param liveness_probe_http_get_path: 
            :param liveness_probe_http_get_port: 
            :param liveness_probe_http_get_scheme: 
            :param liveness_probe_initial_delay_seconds: 
            :param liveness_probe_period_seconds: 
            :param liveness_probe_success_threshold: 
            :param liveness_probe_tcp_socket_port: 
            :param liveness_probe_timeout_seconds: 
            :param memory: 
            :param ports: 
            :param readiness_probe_exec_commands: 
            :param readiness_probe_failure_threshold: 
            :param readiness_probe_http_get_path: 
            :param readiness_probe_http_get_port: 
            :param readiness_probe_http_get_scheme: 
            :param readiness_probe_initial_delay_seconds: 
            :param readiness_probe_period_seconds: 
            :param readiness_probe_success_threshold: 
            :param readiness_probe_tcp_socket_port: 
            :param readiness_probe_timeout_seconds: 
            :param security_context_capabilities_add: 
            :param security_context_run_as_user: 
            :param stdin: 
            :param stdin_once: 
            :param tty: 
            :param volume_mounts: 
            :param working_dir: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ef2b673e79853fd0265c258438c46538e47388664e7daf462f9825035a092956)
                check_type(argname="argument image", value=image, expected_type=type_hints["image"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument args", value=args, expected_type=type_hints["args"])
                check_type(argname="argument commands", value=commands, expected_type=type_hints["commands"])
                check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
                check_type(argname="argument environment_vars", value=environment_vars, expected_type=type_hints["environment_vars"])
                check_type(argname="argument gpu", value=gpu, expected_type=type_hints["gpu"])
                check_type(argname="argument image_pull_policy", value=image_pull_policy, expected_type=type_hints["image_pull_policy"])
                check_type(argname="argument liveness_probe_exec_commands", value=liveness_probe_exec_commands, expected_type=type_hints["liveness_probe_exec_commands"])
                check_type(argname="argument liveness_probe_failure_threshold", value=liveness_probe_failure_threshold, expected_type=type_hints["liveness_probe_failure_threshold"])
                check_type(argname="argument liveness_probe_http_get_path", value=liveness_probe_http_get_path, expected_type=type_hints["liveness_probe_http_get_path"])
                check_type(argname="argument liveness_probe_http_get_port", value=liveness_probe_http_get_port, expected_type=type_hints["liveness_probe_http_get_port"])
                check_type(argname="argument liveness_probe_http_get_scheme", value=liveness_probe_http_get_scheme, expected_type=type_hints["liveness_probe_http_get_scheme"])
                check_type(argname="argument liveness_probe_initial_delay_seconds", value=liveness_probe_initial_delay_seconds, expected_type=type_hints["liveness_probe_initial_delay_seconds"])
                check_type(argname="argument liveness_probe_period_seconds", value=liveness_probe_period_seconds, expected_type=type_hints["liveness_probe_period_seconds"])
                check_type(argname="argument liveness_probe_success_threshold", value=liveness_probe_success_threshold, expected_type=type_hints["liveness_probe_success_threshold"])
                check_type(argname="argument liveness_probe_tcp_socket_port", value=liveness_probe_tcp_socket_port, expected_type=type_hints["liveness_probe_tcp_socket_port"])
                check_type(argname="argument liveness_probe_timeout_seconds", value=liveness_probe_timeout_seconds, expected_type=type_hints["liveness_probe_timeout_seconds"])
                check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
                check_type(argname="argument ports", value=ports, expected_type=type_hints["ports"])
                check_type(argname="argument readiness_probe_exec_commands", value=readiness_probe_exec_commands, expected_type=type_hints["readiness_probe_exec_commands"])
                check_type(argname="argument readiness_probe_failure_threshold", value=readiness_probe_failure_threshold, expected_type=type_hints["readiness_probe_failure_threshold"])
                check_type(argname="argument readiness_probe_http_get_path", value=readiness_probe_http_get_path, expected_type=type_hints["readiness_probe_http_get_path"])
                check_type(argname="argument readiness_probe_http_get_port", value=readiness_probe_http_get_port, expected_type=type_hints["readiness_probe_http_get_port"])
                check_type(argname="argument readiness_probe_http_get_scheme", value=readiness_probe_http_get_scheme, expected_type=type_hints["readiness_probe_http_get_scheme"])
                check_type(argname="argument readiness_probe_initial_delay_seconds", value=readiness_probe_initial_delay_seconds, expected_type=type_hints["readiness_probe_initial_delay_seconds"])
                check_type(argname="argument readiness_probe_period_seconds", value=readiness_probe_period_seconds, expected_type=type_hints["readiness_probe_period_seconds"])
                check_type(argname="argument readiness_probe_success_threshold", value=readiness_probe_success_threshold, expected_type=type_hints["readiness_probe_success_threshold"])
                check_type(argname="argument readiness_probe_tcp_socket_port", value=readiness_probe_tcp_socket_port, expected_type=type_hints["readiness_probe_tcp_socket_port"])
                check_type(argname="argument readiness_probe_timeout_seconds", value=readiness_probe_timeout_seconds, expected_type=type_hints["readiness_probe_timeout_seconds"])
                check_type(argname="argument security_context_capabilities_add", value=security_context_capabilities_add, expected_type=type_hints["security_context_capabilities_add"])
                check_type(argname="argument security_context_run_as_user", value=security_context_run_as_user, expected_type=type_hints["security_context_run_as_user"])
                check_type(argname="argument stdin", value=stdin, expected_type=type_hints["stdin"])
                check_type(argname="argument stdin_once", value=stdin_once, expected_type=type_hints["stdin_once"])
                check_type(argname="argument tty", value=tty, expected_type=type_hints["tty"])
                check_type(argname="argument volume_mounts", value=volume_mounts, expected_type=type_hints["volume_mounts"])
                check_type(argname="argument working_dir", value=working_dir, expected_type=type_hints["working_dir"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "image": image,
                "name": name,
            }
            if args is not None:
                self._values["args"] = args
            if commands is not None:
                self._values["commands"] = commands
            if cpu is not None:
                self._values["cpu"] = cpu
            if environment_vars is not None:
                self._values["environment_vars"] = environment_vars
            if gpu is not None:
                self._values["gpu"] = gpu
            if image_pull_policy is not None:
                self._values["image_pull_policy"] = image_pull_policy
            if liveness_probe_exec_commands is not None:
                self._values["liveness_probe_exec_commands"] = liveness_probe_exec_commands
            if liveness_probe_failure_threshold is not None:
                self._values["liveness_probe_failure_threshold"] = liveness_probe_failure_threshold
            if liveness_probe_http_get_path is not None:
                self._values["liveness_probe_http_get_path"] = liveness_probe_http_get_path
            if liveness_probe_http_get_port is not None:
                self._values["liveness_probe_http_get_port"] = liveness_probe_http_get_port
            if liveness_probe_http_get_scheme is not None:
                self._values["liveness_probe_http_get_scheme"] = liveness_probe_http_get_scheme
            if liveness_probe_initial_delay_seconds is not None:
                self._values["liveness_probe_initial_delay_seconds"] = liveness_probe_initial_delay_seconds
            if liveness_probe_period_seconds is not None:
                self._values["liveness_probe_period_seconds"] = liveness_probe_period_seconds
            if liveness_probe_success_threshold is not None:
                self._values["liveness_probe_success_threshold"] = liveness_probe_success_threshold
            if liveness_probe_tcp_socket_port is not None:
                self._values["liveness_probe_tcp_socket_port"] = liveness_probe_tcp_socket_port
            if liveness_probe_timeout_seconds is not None:
                self._values["liveness_probe_timeout_seconds"] = liveness_probe_timeout_seconds
            if memory is not None:
                self._values["memory"] = memory
            if ports is not None:
                self._values["ports"] = ports
            if readiness_probe_exec_commands is not None:
                self._values["readiness_probe_exec_commands"] = readiness_probe_exec_commands
            if readiness_probe_failure_threshold is not None:
                self._values["readiness_probe_failure_threshold"] = readiness_probe_failure_threshold
            if readiness_probe_http_get_path is not None:
                self._values["readiness_probe_http_get_path"] = readiness_probe_http_get_path
            if readiness_probe_http_get_port is not None:
                self._values["readiness_probe_http_get_port"] = readiness_probe_http_get_port
            if readiness_probe_http_get_scheme is not None:
                self._values["readiness_probe_http_get_scheme"] = readiness_probe_http_get_scheme
            if readiness_probe_initial_delay_seconds is not None:
                self._values["readiness_probe_initial_delay_seconds"] = readiness_probe_initial_delay_seconds
            if readiness_probe_period_seconds is not None:
                self._values["readiness_probe_period_seconds"] = readiness_probe_period_seconds
            if readiness_probe_success_threshold is not None:
                self._values["readiness_probe_success_threshold"] = readiness_probe_success_threshold
            if readiness_probe_tcp_socket_port is not None:
                self._values["readiness_probe_tcp_socket_port"] = readiness_probe_tcp_socket_port
            if readiness_probe_timeout_seconds is not None:
                self._values["readiness_probe_timeout_seconds"] = readiness_probe_timeout_seconds
            if security_context_capabilities_add is not None:
                self._values["security_context_capabilities_add"] = security_context_capabilities_add
            if security_context_run_as_user is not None:
                self._values["security_context_run_as_user"] = security_context_run_as_user
            if stdin is not None:
                self._values["stdin"] = stdin
            if stdin_once is not None:
                self._values["stdin_once"] = stdin_once
            if tty is not None:
                self._values["tty"] = tty
            if volume_mounts is not None:
                self._values["volume_mounts"] = volume_mounts
            if working_dir is not None:
                self._values["working_dir"] = working_dir

        @builtins.property
        def image(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: image: The image of the container.
            '''
            result = self._values.get("image")
            assert result is not None, "Required property 'image' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def name(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: name: The image name of the container.
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def args(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property: args: The container startup arguments. You can specify up to 10 arguments.
            '''
            result = self._values.get("args")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def commands(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property: commands: The container startup commands. You can specify up to 20 commands. Each command can contain up to 256 characters.
            '''
            result = self._values.get("commands")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def cpu(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: cpu: The number of CPU cores that you want to allocate to the container.
            '''
            result = self._values.get("cpu")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def environment_vars(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.EnvironmentVarsProperty"]]]]:
            '''
            :Property: environmentVars:
            '''
            result = self._values.get("environment_vars")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.EnvironmentVarsProperty"]]]], result)

        @builtins.property
        def gpu(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: gpu: The number of GPUs that you want to allocate to the container.
            '''
            result = self._values.get("gpu")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def image_pull_policy(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            imagePullPolicy: The image pulling policy. Valid values:
            Always: Each time instances are created, image pulling is performed.
            IfNotPresent: Image pulling is performed as needed. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
            Never: Image pulling is not performed. On-premises images are always used.
            '''
            result = self._values.get("image_pull_policy")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_exec_commands(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property: livenessProbeExecCommands: The command that you want to run by using the CLI in the container to perform liveness probes.
            '''
            result = self._values.get("liveness_probe_exec_commands")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def liveness_probe_failure_threshold(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            livenessProbeFailureThreshold: The minimum number of consecutive failures before a successful liveness probe is considered failed.
            Default value: 3.
            '''
            result = self._values.get("liveness_probe_failure_threshold")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_http_get_path(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: livenessProbeHttpGetPath: The path to which HTTP GET requests are sent when you use the HTTP GET requests to perform liveness probes.
            '''
            result = self._values.get("liveness_probe_http_get_path")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_http_get_port(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: livenessProbeHttpGetPort: The port to which HTTP GET requests are sent when you use the HTTP GET requests to perform liveness probes.
            '''
            result = self._values.get("liveness_probe_http_get_port")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_http_get_scheme(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            livenessProbeHttpGetScheme: The protocol type of the HTTP GET requests that you use to perform liveness probes. Valid values:
            HTTP
            HTTPS
            '''
            result = self._values.get("liveness_probe_http_get_scheme")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_initial_delay_seconds(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: livenessProbeInitialDelaySeconds: The number of seconds that elapses from the startup of the container to the start time of a liveness probe. Unit: seconds.
            '''
            result = self._values.get("liveness_probe_initial_delay_seconds")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_period_seconds(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: livenessProbePeriodSeconds: The interval at which liveness probes are performed. Unit: seconds. Default value: 10. Minimum value: 1.
            '''
            result = self._values.get("liveness_probe_period_seconds")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_success_threshold(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: livenessProbeSuccessThreshold: The minimum number of consecutive successes before a failed liveness probe is considered successful. Default value: 1. Set the value to 1.
            '''
            result = self._values.get("liveness_probe_success_threshold")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_tcp_socket_port(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: livenessProbeTcpSocketPort: The port detected by TCP sockets when you use the TCP sockets to perform liveness probes.
            '''
            result = self._values.get("liveness_probe_tcp_socket_port")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def liveness_probe_timeout_seconds(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: livenessProbeTimeoutSeconds: The timeout period for a liveness probe. Unit: seconds. Default value: 1. Minimum value: 1.
            '''
            result = self._values.get("liveness_probe_timeout_seconds")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def memory(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: memory: The memory size that you want to allocate to the container. Unit: GiB.
            '''
            result = self._values.get("memory")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ports(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.PortsProperty"]]]]:
            '''
            :Property: ports:
            '''
            result = self._values.get("ports")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.PortsProperty"]]]], result)

        @builtins.property
        def readiness_probe_exec_commands(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property: readinessProbeExecCommands: The command that you want to run by using the command line interface (CLI) in the container to perform readiness probes.
            '''
            result = self._values.get("readiness_probe_exec_commands")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def readiness_probe_failure_threshold(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: readinessProbeFailureThreshold: The minimum number of consecutive failures before a successful readiness probe is considered failed. Default value: 3.
            '''
            result = self._values.get("readiness_probe_failure_threshold")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def readiness_probe_http_get_path(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: readinessProbeHttpGetPath: The path to which HTTP GET requests are sent when you use the HTTP GET requests to perform readiness probes.
            '''
            result = self._values.get("readiness_probe_http_get_path")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def readiness_probe_http_get_port(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: readinessProbeHttpGetPort: The port to which HTTP GET requests are sent when you use the HTTP GET requests to perform readiness probes.
            '''
            result = self._values.get("readiness_probe_http_get_port")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def readiness_probe_http_get_scheme(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            readinessProbeHttpGetScheme: The protocol type of the HTTP GET requests that you use to perform readiness probes. Valid values:
            HTTP
            HTTPS
            '''
            result = self._values.get("readiness_probe_http_get_scheme")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def readiness_probe_initial_delay_seconds(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: readinessProbeInitialDelaySeconds: The number of seconds that elapses from the startup of the container to the start time of a readiness probe. Unit: seconds.
            '''
            result = self._values.get("readiness_probe_initial_delay_seconds")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def readiness_probe_period_seconds(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: readinessProbePeriodSeconds: The interval at which readiness probes are performed. Unit: seconds. Default value: 10. Minimum value: 1.
            '''
            result = self._values.get("readiness_probe_period_seconds")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def readiness_probe_success_threshold(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: readinessProbeSuccessThreshold: The minimum number of consecutive successes before a failed readiness probe is considered successful. Default value: 1. Set the value to 1.
            '''
            result = self._values.get("readiness_probe_success_threshold")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def readiness_probe_tcp_socket_port(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: readinessProbeTcpSocketPort: The port that is detected by TCP sockets when you use the TCP sockets to perform readiness probes.
            '''
            result = self._values.get("readiness_probe_tcp_socket_port")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def readiness_probe_timeout_seconds(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: readinessProbeTimeoutSeconds: The timeout period for a readiness probe. Unit: seconds. Default value: 1. Minimum value: 1.
            '''
            result = self._values.get("readiness_probe_timeout_seconds")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def security_context_capabilities_add(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property:

            securityContextCapabilitiesAdd: The permissions that are granted to the processes in the container. Only NET_ADMIN and NET_RAW are supported.
            Note
            If you want to use NET_RAW, submit a ticket.
            '''
            result = self._values.get("security_context_capabilities_add")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def security_context_run_as_user(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: securityContextRunAsUser: The ID of the user that runs the container.
            '''
            result = self._values.get("security_context_run_as_user")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def stdin(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            stdin: Specifies whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error occurs.
            Default value: false.
            '''
            result = self._values.get("stdin")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def stdin_once(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            stdinOnce: Specifies whether standard input streams remain connected during multiple sessions when Container.N.StdinOnce is set to true.
            If you set Container.N.StdinOnce to true, standard input streams are connected after the container is started and remain idle until a client is connected to receive data. After the client is disconnected, the standard input streams are also disconnected and remain disconnected until the container is restarted.
            '''
            result = self._values.get("stdin_once")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def tty(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            tty: Specifies whether to enable interaction. Valid values:
            true
            false
            Default value: false.
            If the command is a /bin/bash command, set the value to true.
            '''
            result = self._values.get("tty")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def volume_mounts(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.VolumeMountsProperty"]]]]:
            '''
            :Property: volumeMounts:
            '''
            result = self._values.get("volume_mounts")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.VolumeMountsProperty"]]]], result)

        @builtins.property
        def working_dir(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: workingDir: The working directory of the container.
            '''
            result = self._values.get("working_dir")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContainersProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.DnsConfigOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name", "value": "value"},
    )
    class DnsConfigOptionsProperty:
        def __init__(
            self,
            *,
            name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ) -> None:
            '''
            :param name: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e4552ceca2e0aa9aa04175ed7b3a498970fad83a02a24e5c7bfece86fc6abedf)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "name": name,
                "value": value,
            }

        @builtins.property
        def name(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: name: The variable name of the option.
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: value: The variable value of the option.
            '''
            result = self._values.get("value")
            assert result is not None, "Required property 'value' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DnsConfigOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.EnvironmentVarsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class EnvironmentVarsProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3d29abef720cee450a827324af882dc91cf773d9ca0592924b58786338d1afc0)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: key: The name of the environment variable. The name must be 1 to 128 characters in length. Specify the value in the [0-9a-zA-Z] format. The name can contain underscores and cannot start with a digit.
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: The value of the environment variable. The value can be up to 256 characters in length.
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnvironmentVarsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.HostAliasesProperty",
        jsii_struct_bases=[],
        name_mapping={"ip": "ip", "hostnames": "hostnames"},
    )
    class HostAliasesProperty:
        def __init__(
            self,
            *,
            ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            hostnames: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        ) -> None:
            '''
            :param ip: 
            :param hostnames: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6e259bad51f461cdea1146866233a1e864009a39e22527e67c2cd66ea418bdd3)
                check_type(argname="argument ip", value=ip, expected_type=type_hints["ip"])
                check_type(argname="argument hostnames", value=hostnames, expected_type=type_hints["hostnames"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "ip": ip,
            }
            if hostnames is not None:
                self._values["hostnames"] = hostnames

        @builtins.property
        def ip(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: ip: The IP address of the host that you want to add.
            '''
            result = self._values.get("ip")
            assert result is not None, "Required property 'ip' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def hostnames(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property: hostnames: The name of the host that you want to add.
            '''
            result = self._values.get("hostnames")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HostAliasesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.ImageRegistryCredentialsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "password": "password",
            "server": "server",
            "user_name": "userName",
        },
    )
    class ImageRegistryCredentialsProperty:
        def __init__(
            self,
            *,
            password: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            server: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            user_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ) -> None:
            '''
            :param password: 
            :param server: 
            :param user_name: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a86573574f449fa3687b2285951ad1ce8cee97f6f90841d75f394b5f440e3eeb)
                check_type(argname="argument password", value=password, expected_type=type_hints["password"])
                check_type(argname="argument server", value=server, expected_type=type_hints["server"])
                check_type(argname="argument user_name", value=user_name, expected_type=type_hints["user_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "password": password,
                "server": server,
                "user_name": user_name,
            }

        @builtins.property
        def password(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: password: The password of the image repository.
            '''
            result = self._values.get("password")
            assert result is not None, "Required property 'password' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def server(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: server: The registered address of the image repository.
            '''
            result = self._values.get("server")
            assert result is not None, "Required property 'server' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def user_name(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: userName: The username of the image repository.
            '''
            result = self._values.get("user_name")
            assert result is not None, "Required property 'user_name' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ImageRegistryCredentialsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.InitContainerEnvironmentVarsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class InitContainerEnvironmentVarsProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__885a60b86b8cc49c77ff00dd75a856bdb27b864bc96215db131b08d7709784d0)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: key: The name of the environment variable. The name must be 1 to 128 characters in length. Specify the name in the [0-9a-zA-Z] format. The name can contain underscores and cannot start with a digit.
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: The value of the environment variable. The value can be up to 256 characters in length.
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InitContainerEnvironmentVarsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.InitContainerVolumeMountsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "name": "name",
            "mount_path": "mountPath",
            "mount_propagation": "mountPropagation",
            "read_only": "readOnly",
            "sub_path": "subPath",
        },
    )
    class InitContainerVolumeMountsProperty:
        def __init__(
            self,
            *,
            name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            mount_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            mount_propagation: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            read_only: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            sub_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param name: 
            :param mount_path: 
            :param mount_propagation: 
            :param read_only: 
            :param sub_path: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0a0d7f06a62f52c062dc5590f87d60b48e8817a5443277d9820b5957923db460)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
                check_type(argname="argument mount_propagation", value=mount_propagation, expected_type=type_hints["mount_propagation"])
                check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
                check_type(argname="argument sub_path", value=sub_path, expected_type=type_hints["sub_path"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "name": name,
            }
            if mount_path is not None:
                self._values["mount_path"] = mount_path
            if mount_propagation is not None:
                self._values["mount_propagation"] = mount_propagation
            if read_only is not None:
                self._values["read_only"] = read_only
            if sub_path is not None:
                self._values["sub_path"] = sub_path

        @builtins.property
        def name(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: name: The name of the mounted volume.
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def mount_path(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: mountPath: The directory on which the volume is mounted. Data in this directory is overwritten by the data of the volume.
            '''
            result = self._values.get("mount_path")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def mount_propagation(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            mountPropagation: The mount propagation setting of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:
            None: The volume mount does not receive subsequent mounts that are mounted to the volume or the subdirectories of the volume.
            HostToCotainer: The volume mount receives all subsequent mounts that are mounted to the volume or the subdirectories of the volume.
            Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to the volume or its subdirectories. In addition, all volume mounts that are mounted on the container are propagated back to the instance and to all containers of all pods that use the same volume.
            '''
            result = self._values.get("mount_propagation")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def read_only(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            readOnly: Specifies whether the mount directory is read-only.
            Default value: false.
            '''
            result = self._values.get("read_only")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def sub_path(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: subPath: The subdirectory of the volume. The pod can mount different directories of the same volume to different directories of the init container.
            '''
            result = self._values.get("sub_path")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InitContainerVolumeMountsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.InitContainersProperty",
        jsii_struct_bases=[],
        name_mapping={
            "image": "image",
            "name": "name",
            "args": "args",
            "commands": "commands",
            "cpu": "cpu",
            "gpu": "gpu",
            "image_pull_policy": "imagePullPolicy",
            "init_container_environment_vars": "initContainerEnvironmentVars",
            "init_container_volume_mounts": "initContainerVolumeMounts",
            "memory": "memory",
            "security_context_capabilities_add": "securityContextCapabilitiesAdd",
            "security_context_run_as_user": "securityContextRunAsUser",
            "working_dir": "workingDir",
        },
    )
    class InitContainersProperty:
        def __init__(
            self,
            *,
            image: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            args: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            commands: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            gpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            image_pull_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            init_container_environment_vars: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.InitContainerEnvironmentVarsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            init_container_volume_mounts: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.InitContainerVolumeMountsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            security_context_capabilities_add: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            security_context_run_as_user: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            working_dir: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param image: 
            :param name: 
            :param args: 
            :param commands: 
            :param cpu: 
            :param gpu: 
            :param image_pull_policy: 
            :param init_container_environment_vars: 
            :param init_container_volume_mounts: 
            :param memory: 
            :param security_context_capabilities_add: 
            :param security_context_run_as_user: 
            :param working_dir: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f017c9ad7ada79531dabc892f37ae9c555c876ef1cef11f3df9be1d6221db21b)
                check_type(argname="argument image", value=image, expected_type=type_hints["image"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument args", value=args, expected_type=type_hints["args"])
                check_type(argname="argument commands", value=commands, expected_type=type_hints["commands"])
                check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
                check_type(argname="argument gpu", value=gpu, expected_type=type_hints["gpu"])
                check_type(argname="argument image_pull_policy", value=image_pull_policy, expected_type=type_hints["image_pull_policy"])
                check_type(argname="argument init_container_environment_vars", value=init_container_environment_vars, expected_type=type_hints["init_container_environment_vars"])
                check_type(argname="argument init_container_volume_mounts", value=init_container_volume_mounts, expected_type=type_hints["init_container_volume_mounts"])
                check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
                check_type(argname="argument security_context_capabilities_add", value=security_context_capabilities_add, expected_type=type_hints["security_context_capabilities_add"])
                check_type(argname="argument security_context_run_as_user", value=security_context_run_as_user, expected_type=type_hints["security_context_run_as_user"])
                check_type(argname="argument working_dir", value=working_dir, expected_type=type_hints["working_dir"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "image": image,
                "name": name,
            }
            if args is not None:
                self._values["args"] = args
            if commands is not None:
                self._values["commands"] = commands
            if cpu is not None:
                self._values["cpu"] = cpu
            if gpu is not None:
                self._values["gpu"] = gpu
            if image_pull_policy is not None:
                self._values["image_pull_policy"] = image_pull_policy
            if init_container_environment_vars is not None:
                self._values["init_container_environment_vars"] = init_container_environment_vars
            if init_container_volume_mounts is not None:
                self._values["init_container_volume_mounts"] = init_container_volume_mounts
            if memory is not None:
                self._values["memory"] = memory
            if security_context_capabilities_add is not None:
                self._values["security_context_capabilities_add"] = security_context_capabilities_add
            if security_context_run_as_user is not None:
                self._values["security_context_run_as_user"] = security_context_run_as_user
            if working_dir is not None:
                self._values["working_dir"] = working_dir

        @builtins.property
        def image(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: image: The image of the init container.
            '''
            result = self._values.get("image")
            assert result is not None, "Required property 'image' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def name(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: name: The name of the init container.
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def args(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property: args: The container startup arguments.
            '''
            result = self._values.get("args")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def commands(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property: commands: The container startup commands.
            '''
            result = self._values.get("commands")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def cpu(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: cpu: The number of vCPUs that you want to allocate to the init container.
            '''
            result = self._values.get("cpu")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def gpu(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: gpu: The number of GPUs that you want to allocate to the init container.
            '''
            result = self._values.get("gpu")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def image_pull_policy(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: imagePullPolicy: The image pulling policy.
            '''
            result = self._values.get("image_pull_policy")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def init_container_environment_vars(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainerEnvironmentVarsProperty"]]]]:
            '''
            :Property: initContainerEnvironmentVars:
            '''
            result = self._values.get("init_container_environment_vars")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainerEnvironmentVarsProperty"]]]], result)

        @builtins.property
        def init_container_volume_mounts(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainerVolumeMountsProperty"]]]]:
            '''
            :Property: initContainerVolumeMounts:
            '''
            result = self._values.get("init_container_volume_mounts")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.InitContainerVolumeMountsProperty"]]]], result)

        @builtins.property
        def memory(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: memory: The memory size that you want to allocate to the init container. Unit: GiB.
            '''
            result = self._values.get("memory")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def security_context_capabilities_add(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property:

            securityContextCapabilitiesAdd: The permissions that are granted to the processes in the init container. Only NET_ADMIN and NET_RAW are supported.
            Note
            If you want to use NET_RAW, submit a ticket.
            '''
            result = self._values.get("security_context_capabilities_add")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def security_context_run_as_user(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: securityContextRunAsUser: The ID of the user that runs the init container.
            '''
            result = self._values.get("security_context_run_as_user")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def working_dir(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: workingDir: The working directory of the init container.
            '''
            result = self._values.get("working_dir")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InitContainersProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.PortsProperty",
        jsii_struct_bases=[],
        name_mapping={"port": "port", "protocol": "protocol"},
    )
    class PortsProperty:
        def __init__(
            self,
            *,
            port: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
            protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ) -> None:
            '''
            :param port: 
            :param protocol: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__70e67a5ca07333e8321bd0b9e226cc03ca0045ae37c4b0fc429a9029c95e05a0)
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "port": port,
                "protocol": protocol,
            }

        @builtins.property
        def port(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: port: The port number. Valid values: 1 to 65535.
            '''
            result = self._values.get("port")
            assert result is not None, "Required property 'port' is missing"
            return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def protocol(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            protocol: The protocol type. Valid values:
            TCP
            UDP
            '''
            result = self._values.get("protocol")
            assert result is not None, "Required property 'protocol' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PortsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.SecurityContextSysctlsProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name", "value": "value"},
    )
    class SecurityContextSysctlsProperty:
        def __init__(
            self,
            *,
            name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param name: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fb506c9af7ae01f50b06d9cec92c7636e5732c0e339ed057e05e79834c6f1bf9)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "name": name,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def name(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: name: The system name of the security context in which the elastic container instance runs.
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: The variable value of the security context in which the elastic container instance runs.
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SecurityContextSysctlsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ee399228c1d63e998cccab53248ddf5785ca9c39fc2d92dc9784ea81c3f20cb3)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            key: The tag key of the elastic container instance. You can specify 1 to 20 tags.
            You cannot specify an empty string as a tag key. The tag key can be up to 128 characters in length and cannot contain http:// or https://. The tag key cannot start with acs: or aliyun.
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            value: The tag value of the elastic container instance. You can specify 1 to 20 tags.
            You can specify an empty string as a tag value. The tag value can be up to 128 characters in length and cannot contain http:// or https://. The tag value cannot start with acs:.
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.VolumeMountsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "mount_path": "mountPath",
            "mount_propagation": "mountPropagation",
            "name": "name",
            "read_only": "readOnly",
            "sub_path": "subPath",
        },
    )
    class VolumeMountsProperty:
        def __init__(
            self,
            *,
            mount_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            mount_propagation: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            read_only: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            sub_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param mount_path: 
            :param mount_propagation: 
            :param name: 
            :param read_only: 
            :param sub_path: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3e841ead24d9b47e35466acd9743b3e12b44eaab1168b4d6dd3e55545ce57906)
                check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
                check_type(argname="argument mount_propagation", value=mount_propagation, expected_type=type_hints["mount_propagation"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
                check_type(argname="argument sub_path", value=sub_path, expected_type=type_hints["sub_path"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if mount_path is not None:
                self._values["mount_path"] = mount_path
            if mount_propagation is not None:
                self._values["mount_propagation"] = mount_propagation
            if name is not None:
                self._values["name"] = name
            if read_only is not None:
                self._values["read_only"] = read_only
            if sub_path is not None:
                self._values["sub_path"] = sub_path

        @builtins.property
        def mount_path(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            mountPath: The directory on which the volume is mounted.
            Note
            Data in this directory is overwritten by the data on the volume. Proceed with caution if you specify this parameter.
            '''
            result = self._values.get("mount_path")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def mount_propagation(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            mountPropagation: The mount propagation setting of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:
            None: The volume mount does not receive subsequent mounts that are mounted to the volume or the subdirectories of the volume.
            HostToCotainer: The volume mount receives all subsequent mounts that are mounted to the volume or its subdirectories.
            Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to the volume or its subdirectories. In addition, all volume mounts that are mounted on the container are propagated back to the instance and to all containers of all pods that use the same volume.
            Default value: None.
            '''
            result = self._values.get("mount_propagation")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def name(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: name: The volume name. The value of this parameter is the same as the value of Volume.N.Name.
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def read_only(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            readOnly: Specifies whether the volume is read-only. Valid values:
            true
            false
            Default value: false.
            '''
            result = self._values.get("read_only")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def sub_path(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: subPath: The subdirectory of the volume.
            '''
            result = self._values.get("sub_path")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VolumeMountsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfiguration.VolumesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "name": "name",
            "type": "type",
            "config_file_volume_config_file_to_paths": "configFileVolumeConfigFileToPaths",
            "config_file_volume_default_mode": "configFileVolumeDefaultMode",
            "disk_volume_disk_id": "diskVolumeDiskId",
            "disk_volume_disk_size": "diskVolumeDiskSize",
            "empty_dir_volume_medium": "emptyDirVolumeMedium",
            "empty_dir_volume_size_limit": "emptyDirVolumeSizeLimit",
            "flex_volume_driver": "flexVolumeDriver",
            "flex_volume_fs_type": "flexVolumeFsType",
            "flex_volume_options": "flexVolumeOptions",
            "host_path_volume_path": "hostPathVolumePath",
            "host_path_volume_type": "hostPathVolumeType",
            "nfs_volume_path": "nfsVolumePath",
            "nfs_volume_read_only": "nfsVolumeReadOnly",
            "nfs_volume_server": "nfsVolumeServer",
        },
    )
    class VolumesProperty:
        def __init__(
            self,
            *,
            name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            config_file_volume_config_file_to_paths: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosEciScalingConfiguration.ConfigFileVolumeConfigFileToPathsProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            config_file_volume_default_mode: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            disk_volume_disk_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            disk_volume_disk_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            empty_dir_volume_medium: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            empty_dir_volume_size_limit: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            flex_volume_driver: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            flex_volume_fs_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            flex_volume_options: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            host_path_volume_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            host_path_volume_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            nfs_volume_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            nfs_volume_read_only: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            nfs_volume_server: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param name: 
            :param type: 
            :param config_file_volume_config_file_to_paths: 
            :param config_file_volume_default_mode: 
            :param disk_volume_disk_id: 
            :param disk_volume_disk_size: 
            :param empty_dir_volume_medium: 
            :param empty_dir_volume_size_limit: 
            :param flex_volume_driver: 
            :param flex_volume_fs_type: 
            :param flex_volume_options: 
            :param host_path_volume_path: 
            :param host_path_volume_type: 
            :param nfs_volume_path: 
            :param nfs_volume_read_only: 
            :param nfs_volume_server: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bbd9283c90fdeb3c67159528b37d03751c5875aa6da2cb5d47fce1ca609f87e3)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
                check_type(argname="argument config_file_volume_config_file_to_paths", value=config_file_volume_config_file_to_paths, expected_type=type_hints["config_file_volume_config_file_to_paths"])
                check_type(argname="argument config_file_volume_default_mode", value=config_file_volume_default_mode, expected_type=type_hints["config_file_volume_default_mode"])
                check_type(argname="argument disk_volume_disk_id", value=disk_volume_disk_id, expected_type=type_hints["disk_volume_disk_id"])
                check_type(argname="argument disk_volume_disk_size", value=disk_volume_disk_size, expected_type=type_hints["disk_volume_disk_size"])
                check_type(argname="argument empty_dir_volume_medium", value=empty_dir_volume_medium, expected_type=type_hints["empty_dir_volume_medium"])
                check_type(argname="argument empty_dir_volume_size_limit", value=empty_dir_volume_size_limit, expected_type=type_hints["empty_dir_volume_size_limit"])
                check_type(argname="argument flex_volume_driver", value=flex_volume_driver, expected_type=type_hints["flex_volume_driver"])
                check_type(argname="argument flex_volume_fs_type", value=flex_volume_fs_type, expected_type=type_hints["flex_volume_fs_type"])
                check_type(argname="argument flex_volume_options", value=flex_volume_options, expected_type=type_hints["flex_volume_options"])
                check_type(argname="argument host_path_volume_path", value=host_path_volume_path, expected_type=type_hints["host_path_volume_path"])
                check_type(argname="argument host_path_volume_type", value=host_path_volume_type, expected_type=type_hints["host_path_volume_type"])
                check_type(argname="argument nfs_volume_path", value=nfs_volume_path, expected_type=type_hints["nfs_volume_path"])
                check_type(argname="argument nfs_volume_read_only", value=nfs_volume_read_only, expected_type=type_hints["nfs_volume_read_only"])
                check_type(argname="argument nfs_volume_server", value=nfs_volume_server, expected_type=type_hints["nfs_volume_server"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "name": name,
                "type": type,
            }
            if config_file_volume_config_file_to_paths is not None:
                self._values["config_file_volume_config_file_to_paths"] = config_file_volume_config_file_to_paths
            if config_file_volume_default_mode is not None:
                self._values["config_file_volume_default_mode"] = config_file_volume_default_mode
            if disk_volume_disk_id is not None:
                self._values["disk_volume_disk_id"] = disk_volume_disk_id
            if disk_volume_disk_size is not None:
                self._values["disk_volume_disk_size"] = disk_volume_disk_size
            if empty_dir_volume_medium is not None:
                self._values["empty_dir_volume_medium"] = empty_dir_volume_medium
            if empty_dir_volume_size_limit is not None:
                self._values["empty_dir_volume_size_limit"] = empty_dir_volume_size_limit
            if flex_volume_driver is not None:
                self._values["flex_volume_driver"] = flex_volume_driver
            if flex_volume_fs_type is not None:
                self._values["flex_volume_fs_type"] = flex_volume_fs_type
            if flex_volume_options is not None:
                self._values["flex_volume_options"] = flex_volume_options
            if host_path_volume_path is not None:
                self._values["host_path_volume_path"] = host_path_volume_path
            if host_path_volume_type is not None:
                self._values["host_path_volume_type"] = host_path_volume_type
            if nfs_volume_path is not None:
                self._values["nfs_volume_path"] = nfs_volume_path
            if nfs_volume_read_only is not None:
                self._values["nfs_volume_read_only"] = nfs_volume_read_only
            if nfs_volume_server is not None:
                self._values["nfs_volume_server"] = nfs_volume_server

        @builtins.property
        def name(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: name: The volume name.
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def type(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            type: The volume type. Valid values:
            EmptyDirVolume: an empty volume.
            NFSVolume: a network file system (NFS) volume.
            ConfigFileVolume: a configuration file.
            FlexVolume: a volume that uses the FlexVolume plug-in to extend storage and supports disks.
            HostPathVolume: a file or path of the host node.
            DiskVolume: a disk volume. This value is not recommended. We recommend that you set Volume.N.Type to FlexVolume.
            '''
            result = self._values.get("type")
            assert result is not None, "Required property 'type' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def config_file_volume_config_file_to_paths(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ConfigFileVolumeConfigFileToPathsProperty"]]]]:
            '''
            :Property: configFileVolumeConfigFileToPaths:
            '''
            result = self._values.get("config_file_volume_config_file_to_paths")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosEciScalingConfiguration.ConfigFileVolumeConfigFileToPathsProperty"]]]], result)

        @builtins.property
        def config_file_volume_default_mode(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: configFileVolumeDefaultMode: The default permissions on the ConfigFileVolume-typed volume.
            '''
            result = self._values.get("config_file_volume_default_mode")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def disk_volume_disk_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: diskVolumeDiskId: The ID of the DiskVolume-typed volume.
            '''
            result = self._values.get("disk_volume_disk_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def disk_volume_disk_size(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: diskVolumeDiskSize: The storage size of the DiskVolume-typed volume. Unit: GiB.
            '''
            result = self._values.get("disk_volume_disk_size")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def empty_dir_volume_medium(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: emptyDirVolumeMedium: The storage medium of the EmptyDirVolume-typed volume. If you leave this parameter empty, the file system that backs the node is used as the storage medium. If you set this parameter to memory, the memory is used as the storage medium.
            '''
            result = self._values.get("empty_dir_volume_medium")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def empty_dir_volume_size_limit(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: emptyDirVolumeSizeLimit: The storage size of the EmptyDirVolume-typed volume. Unit: GiB or MiB.
            '''
            result = self._values.get("empty_dir_volume_size_limit")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def flex_volume_driver(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: flexVolumeDriver: The driver name of the FlexVolume-typed volume.
            '''
            result = self._values.get("flex_volume_driver")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def flex_volume_fs_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: flexVolumeFsType: The file system type of the FlexVolume-typed volume. The default value is determined by the script of the FlexVolume plug-in.
            '''
            result = self._values.get("flex_volume_fs_type")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def flex_volume_options(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            flexVolumeOptions: The options of the FlexVolume-typed volume. Each option is a key-value pair contained in a JSON string.
            When you use the FlexVolume plug-in to mount a disk, specify the options in the {"volumeId":"d-2zehdahrwoa7srg****","performanceLevel": "PL2"} format.
            '''
            result = self._values.get("flex_volume_options")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def host_path_volume_path(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: hostPathVolumePath: The absolute path on the host.
            '''
            result = self._values.get("host_path_volume_path")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def host_path_volume_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: hostPathVolumeType: The type of the Host directory. Examples: File, Directory, and Socket.
            '''
            result = self._values.get("host_path_volume_type")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def nfs_volume_path(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: nfsVolumePath: The path to the NFSVolume-typed volume.
            '''
            result = self._values.get("nfs_volume_path")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def nfs_volume_read_only(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            nfsVolumeReadOnly: Specifies whether the NFSVolume-typed volume is read-only. Valid values:
            true
            false
            Default value: false.
            '''
            result = self._values.get("nfs_volume_read_only")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def nfs_volume_server(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: nfsVolumeServer: The address of the NFS server.
            '''
            result = self._values.get("nfs_volume_server")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VolumesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosEciScalingConfigurationProps",
    jsii_struct_bases=[],
    name_mapping={
        "container_group_name": "containerGroupName",
        "scaling_configuration_name": "scalingConfigurationName",
        "scaling_group_id": "scalingGroupId",
        "security_group_id": "securityGroupId",
        "acr_registry_infos": "acrRegistryInfos",
        "active_deadline_seconds": "activeDeadlineSeconds",
        "auto_create_eip": "autoCreateEip",
        "auto_match_image_cache": "autoMatchImageCache",
        "containers": "containers",
        "cost_optimization": "costOptimization",
        "cpu": "cpu",
        "cpu_options_core": "cpuOptionsCore",
        "cpu_options_threads_per_core": "cpuOptionsThreadsPerCore",
        "data_cache_bucket": "dataCacheBucket",
        "data_cache_bursting_enabled": "dataCacheBurstingEnabled",
        "data_cache_pl": "dataCachePl",
        "data_cache_provisioned_iops": "dataCacheProvisionedIops",
        "dns_config_name_servers": "dnsConfigNameServers",
        "dns_config_options": "dnsConfigOptions",
        "dns_config_searches": "dnsConfigSearches",
        "dns_policy": "dnsPolicy",
        "egress_bandwidth": "egressBandwidth",
        "eip_bandwidth": "eipBandwidth",
        "ephemeral_storage": "ephemeralStorage",
        "host_aliases": "hostAliases",
        "host_name": "hostName",
        "image_registry_credentials": "imageRegistryCredentials",
        "image_snapshot_id": "imageSnapshotId",
        "ingress_bandwidth": "ingressBandwidth",
        "init_containers": "initContainers",
        "instance_family_level": "instanceFamilyLevel",
        "instance_types": "instanceTypes",
        "ipv6_address_count": "ipv6AddressCount",
        "load_balancer_weight": "loadBalancerWeight",
        "memory": "memory",
        "ntp_servers": "ntpServers",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "restart_policy": "restartPolicy",
        "security_context_sysctls": "securityContextSysctls",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "tags": "tags",
        "termination_grace_period_seconds": "terminationGracePeriodSeconds",
        "volumes": "volumes",
    },
)
class RosEciScalingConfigurationProps:
    def __init__(
        self,
        *,
        container_group_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        scaling_configuration_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        security_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        acr_registry_infos: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.AcrRegistryInfosProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        active_deadline_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        auto_create_eip: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        auto_match_image_cache: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        containers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.ContainersProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        cost_optimization: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cpu_options_core: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cpu_options_threads_per_core: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        data_cache_bucket: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        data_cache_bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        data_cache_pl: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        data_cache_provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        dns_config_name_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        dns_config_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.DnsConfigOptionsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        dns_config_searches: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        dns_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        egress_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        eip_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ephemeral_storage: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        host_aliases: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.HostAliasesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        host_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_registry_credentials: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.ImageRegistryCredentialsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        image_snapshot_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ingress_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        init_containers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.InitContainersProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        instance_family_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        ipv6_address_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        load_balancer_weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ntp_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        ram_role_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        restart_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_context_sysctls: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.SecurityContextSysctlsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosEciScalingConfiguration.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        termination_grace_period_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        volumes: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.VolumesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosEciScalingConfiguration``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-eciscalingconfiguration

        :param container_group_name: 
        :param scaling_configuration_name: 
        :param scaling_group_id: 
        :param security_group_id: 
        :param acr_registry_infos: 
        :param active_deadline_seconds: 
        :param auto_create_eip: 
        :param auto_match_image_cache: 
        :param containers: 
        :param cost_optimization: 
        :param cpu: 
        :param cpu_options_core: 
        :param cpu_options_threads_per_core: 
        :param data_cache_bucket: 
        :param data_cache_bursting_enabled: 
        :param data_cache_pl: 
        :param data_cache_provisioned_iops: 
        :param dns_config_name_servers: 
        :param dns_config_options: 
        :param dns_config_searches: 
        :param dns_policy: 
        :param egress_bandwidth: 
        :param eip_bandwidth: 
        :param ephemeral_storage: 
        :param host_aliases: 
        :param host_name: 
        :param image_registry_credentials: 
        :param image_snapshot_id: 
        :param ingress_bandwidth: 
        :param init_containers: 
        :param instance_family_level: 
        :param instance_types: 
        :param ipv6_address_count: 
        :param load_balancer_weight: 
        :param memory: 
        :param ntp_servers: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param restart_policy: 
        :param security_context_sysctls: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param tags: 
        :param termination_grace_period_seconds: 
        :param volumes: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fa9c01f03cf393a6f19aee8bf6ad4d48077b24466f0bd3101d65c5015470b47)
            check_type(argname="argument container_group_name", value=container_group_name, expected_type=type_hints["container_group_name"])
            check_type(argname="argument scaling_configuration_name", value=scaling_configuration_name, expected_type=type_hints["scaling_configuration_name"])
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument security_group_id", value=security_group_id, expected_type=type_hints["security_group_id"])
            check_type(argname="argument acr_registry_infos", value=acr_registry_infos, expected_type=type_hints["acr_registry_infos"])
            check_type(argname="argument active_deadline_seconds", value=active_deadline_seconds, expected_type=type_hints["active_deadline_seconds"])
            check_type(argname="argument auto_create_eip", value=auto_create_eip, expected_type=type_hints["auto_create_eip"])
            check_type(argname="argument auto_match_image_cache", value=auto_match_image_cache, expected_type=type_hints["auto_match_image_cache"])
            check_type(argname="argument containers", value=containers, expected_type=type_hints["containers"])
            check_type(argname="argument cost_optimization", value=cost_optimization, expected_type=type_hints["cost_optimization"])
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            check_type(argname="argument cpu_options_core", value=cpu_options_core, expected_type=type_hints["cpu_options_core"])
            check_type(argname="argument cpu_options_threads_per_core", value=cpu_options_threads_per_core, expected_type=type_hints["cpu_options_threads_per_core"])
            check_type(argname="argument data_cache_bucket", value=data_cache_bucket, expected_type=type_hints["data_cache_bucket"])
            check_type(argname="argument data_cache_bursting_enabled", value=data_cache_bursting_enabled, expected_type=type_hints["data_cache_bursting_enabled"])
            check_type(argname="argument data_cache_pl", value=data_cache_pl, expected_type=type_hints["data_cache_pl"])
            check_type(argname="argument data_cache_provisioned_iops", value=data_cache_provisioned_iops, expected_type=type_hints["data_cache_provisioned_iops"])
            check_type(argname="argument dns_config_name_servers", value=dns_config_name_servers, expected_type=type_hints["dns_config_name_servers"])
            check_type(argname="argument dns_config_options", value=dns_config_options, expected_type=type_hints["dns_config_options"])
            check_type(argname="argument dns_config_searches", value=dns_config_searches, expected_type=type_hints["dns_config_searches"])
            check_type(argname="argument dns_policy", value=dns_policy, expected_type=type_hints["dns_policy"])
            check_type(argname="argument egress_bandwidth", value=egress_bandwidth, expected_type=type_hints["egress_bandwidth"])
            check_type(argname="argument eip_bandwidth", value=eip_bandwidth, expected_type=type_hints["eip_bandwidth"])
            check_type(argname="argument ephemeral_storage", value=ephemeral_storage, expected_type=type_hints["ephemeral_storage"])
            check_type(argname="argument host_aliases", value=host_aliases, expected_type=type_hints["host_aliases"])
            check_type(argname="argument host_name", value=host_name, expected_type=type_hints["host_name"])
            check_type(argname="argument image_registry_credentials", value=image_registry_credentials, expected_type=type_hints["image_registry_credentials"])
            check_type(argname="argument image_snapshot_id", value=image_snapshot_id, expected_type=type_hints["image_snapshot_id"])
            check_type(argname="argument ingress_bandwidth", value=ingress_bandwidth, expected_type=type_hints["ingress_bandwidth"])
            check_type(argname="argument init_containers", value=init_containers, expected_type=type_hints["init_containers"])
            check_type(argname="argument instance_family_level", value=instance_family_level, expected_type=type_hints["instance_family_level"])
            check_type(argname="argument instance_types", value=instance_types, expected_type=type_hints["instance_types"])
            check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
            check_type(argname="argument load_balancer_weight", value=load_balancer_weight, expected_type=type_hints["load_balancer_weight"])
            check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
            check_type(argname="argument ntp_servers", value=ntp_servers, expected_type=type_hints["ntp_servers"])
            check_type(argname="argument ram_role_name", value=ram_role_name, expected_type=type_hints["ram_role_name"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument restart_policy", value=restart_policy, expected_type=type_hints["restart_policy"])
            check_type(argname="argument security_context_sysctls", value=security_context_sysctls, expected_type=type_hints["security_context_sysctls"])
            check_type(argname="argument spot_price_limit", value=spot_price_limit, expected_type=type_hints["spot_price_limit"])
            check_type(argname="argument spot_strategy", value=spot_strategy, expected_type=type_hints["spot_strategy"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument termination_grace_period_seconds", value=termination_grace_period_seconds, expected_type=type_hints["termination_grace_period_seconds"])
            check_type(argname="argument volumes", value=volumes, expected_type=type_hints["volumes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "container_group_name": container_group_name,
            "scaling_configuration_name": scaling_configuration_name,
            "scaling_group_id": scaling_group_id,
            "security_group_id": security_group_id,
        }
        if acr_registry_infos is not None:
            self._values["acr_registry_infos"] = acr_registry_infos
        if active_deadline_seconds is not None:
            self._values["active_deadline_seconds"] = active_deadline_seconds
        if auto_create_eip is not None:
            self._values["auto_create_eip"] = auto_create_eip
        if auto_match_image_cache is not None:
            self._values["auto_match_image_cache"] = auto_match_image_cache
        if containers is not None:
            self._values["containers"] = containers
        if cost_optimization is not None:
            self._values["cost_optimization"] = cost_optimization
        if cpu is not None:
            self._values["cpu"] = cpu
        if cpu_options_core is not None:
            self._values["cpu_options_core"] = cpu_options_core
        if cpu_options_threads_per_core is not None:
            self._values["cpu_options_threads_per_core"] = cpu_options_threads_per_core
        if data_cache_bucket is not None:
            self._values["data_cache_bucket"] = data_cache_bucket
        if data_cache_bursting_enabled is not None:
            self._values["data_cache_bursting_enabled"] = data_cache_bursting_enabled
        if data_cache_pl is not None:
            self._values["data_cache_pl"] = data_cache_pl
        if data_cache_provisioned_iops is not None:
            self._values["data_cache_provisioned_iops"] = data_cache_provisioned_iops
        if dns_config_name_servers is not None:
            self._values["dns_config_name_servers"] = dns_config_name_servers
        if dns_config_options is not None:
            self._values["dns_config_options"] = dns_config_options
        if dns_config_searches is not None:
            self._values["dns_config_searches"] = dns_config_searches
        if dns_policy is not None:
            self._values["dns_policy"] = dns_policy
        if egress_bandwidth is not None:
            self._values["egress_bandwidth"] = egress_bandwidth
        if eip_bandwidth is not None:
            self._values["eip_bandwidth"] = eip_bandwidth
        if ephemeral_storage is not None:
            self._values["ephemeral_storage"] = ephemeral_storage
        if host_aliases is not None:
            self._values["host_aliases"] = host_aliases
        if host_name is not None:
            self._values["host_name"] = host_name
        if image_registry_credentials is not None:
            self._values["image_registry_credentials"] = image_registry_credentials
        if image_snapshot_id is not None:
            self._values["image_snapshot_id"] = image_snapshot_id
        if ingress_bandwidth is not None:
            self._values["ingress_bandwidth"] = ingress_bandwidth
        if init_containers is not None:
            self._values["init_containers"] = init_containers
        if instance_family_level is not None:
            self._values["instance_family_level"] = instance_family_level
        if instance_types is not None:
            self._values["instance_types"] = instance_types
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if load_balancer_weight is not None:
            self._values["load_balancer_weight"] = load_balancer_weight
        if memory is not None:
            self._values["memory"] = memory
        if ntp_servers is not None:
            self._values["ntp_servers"] = ntp_servers
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if restart_policy is not None:
            self._values["restart_policy"] = restart_policy
        if security_context_sysctls is not None:
            self._values["security_context_sysctls"] = security_context_sysctls
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if tags is not None:
            self._values["tags"] = tags
        if termination_grace_period_seconds is not None:
            self._values["termination_grace_period_seconds"] = termination_grace_period_seconds
        if volumes is not None:
            self._values["volumes"] = volumes

    @builtins.property
    def container_group_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: containerGroupName: The name of the elastic container instance.
        '''
        result = self._values.get("container_group_name")
        assert result is not None, "Required property 'container_group_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def scaling_configuration_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        scalingConfigurationName: The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (_), hyphens (-), and periods (.). The name must start with a letter or a digit.
        The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
        '''
        result = self._values.get("scaling_configuration_name")
        assert result is not None, "Required property 'scaling_configuration_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group for which you want to create the scaling configuration.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def security_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        securityGroupId: The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other.
        If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group and adds the declared container protocols and port numbers to the inbound rules of the security group.
        '''
        result = self._values.get("security_group_id")
        assert result is not None, "Required property 'security_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def acr_registry_infos(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.AcrRegistryInfosProperty]]]]:
        '''
        :Property: acrRegistryInfos:
        '''
        result = self._values.get("acr_registry_infos")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.AcrRegistryInfosProperty]]]], result)

    @builtins.property
    def active_deadline_seconds(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: activeDeadlineSeconds: The validity period of the scaling configuration. Unit: seconds.
        '''
        result = self._values.get("active_deadline_seconds")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def auto_create_eip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: autoCreateEip: Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.
        '''
        result = self._values.get("auto_create_eip")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def auto_match_image_cache(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoMatchImageCache: Specifies whether to automatically match the image cache. Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("auto_match_image_cache")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def containers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.ContainersProperty]]]]:
        '''
        :Property: containers:
        '''
        result = self._values.get("containers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.ContainersProperty]]]], result)

    @builtins.property
    def cost_optimization(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        costOptimization: Specifies whether to enable the Cost Optimization feature. Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("cost_optimization")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cpu(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: cpu: The number of vCPUs that you want to allocate to the elastic container instance.
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cpu_options_core(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: cpuOptionsCore: The number of physical CPU cores. You can specify this parameter for only specific instance types. For more information, see Specify custom CPU options.
        '''
        result = self._values.get("cpu_options_core")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cpu_options_threads_per_core(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: cpuOptionsThreadsPerCore: The number of threads per core. You can specify this parameter for only specific instance types. If you set this parameter to 1, Hyper-Threading is disabled. For more information, see Specify custom CPU options.
        '''
        result = self._values.get("cpu_options_threads_per_core")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def data_cache_bucket(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: dataCacheBucket: The bucket that stores data caches.
        '''
        result = self._values.get("data_cache_bucket")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def data_cache_bursting_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dataCacheBurstingEnabled: Specifies whether to enable the Performance Burst feature for the ESSD AutoPL disk used for data caching. Valid values:
        true
        false
        Default value: false.
        Note
        For more information about ESSD AutoPL disks, see ESSD AutoPL disks.
        '''
        result = self._values.get("data_cache_bursting_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def data_cache_pl(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dataCachePl: The performance level (PL) of the disk used for data caching. We recommend that you use ESSDs. Valid values if you use ESSDs:
        PL0: An ESSD can provide up to 10,000 random read/write IOPS.
        PL1: An ESSD can provide up to 50,000 random read/write IOPS.
        PL2: An ESSD can provide up to 100,000 random read/write IOPS.
        PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
        Default value: PL1.
        Note
        For more information about ESSDs, see ESSDs.
        '''
        result = self._values.get("data_cache_pl")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def data_cache_provisioned_iops(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dataCacheProvisionedIops: The IOPS provisioned for the ESSD AutoPL disk used for data caching. Valid values: 0 to min{50000, 1000 × Capacity - Baseline IOPS}, where Baseline IOPS = min{1800 + 50 × Capacity - 50000}.
        Note
        For more information about ESSD AutoPL disks, see ESSD AutoPL disks.
        '''
        result = self._values.get("data_cache_provisioned_iops")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def dns_config_name_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: dnsConfigNameServers: The IP addresses of the DNS servers.
        '''
        result = self._values.get("dns_config_name_servers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def dns_config_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.DnsConfigOptionsProperty]]]]:
        '''
        :Property: dnsConfigOptions:
        '''
        result = self._values.get("dns_config_options")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.DnsConfigOptionsProperty]]]], result)

    @builtins.property
    def dns_config_searches(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: dnsConfigSearches: The search domains of the DNS server.
        '''
        result = self._values.get("dns_config_searches")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def dns_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dnsPolicy: The Domain Name System (DNS) policy. Valid values:
        None: uses the DNS that is specified by DnsConfig.
        Default: uses the DNS that is specified for the runtime environment.
        '''
        result = self._values.get("dns_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def egress_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: egressBandwidth: The maximum outbound bandwidth. Unit: bytes.
        '''
        result = self._values.get("egress_bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def eip_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: eipBandwidth: The bandwidth of the EIP. Default value: 5. Unit: Mbit/s.
        '''
        result = self._values.get("eip_bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ephemeral_storage(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ephemeralStorage: The size of the temporary storage space. By default, an enhanced SSD (ESSD) of the PL1 level is used. Unit: GiB.
        '''
        result = self._values.get("ephemeral_storage")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def host_aliases(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.HostAliasesProperty]]]]:
        '''
        :Property: hostAliases:
        '''
        result = self._values.get("host_aliases")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.HostAliasesProperty]]]], result)

    @builtins.property
    def host_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: hostName: The hostname of the elastic container instance.
        '''
        result = self._values.get("host_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_registry_credentials(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.ImageRegistryCredentialsProperty]]]]:
        '''
        :Property: imageRegistryCredentials:
        '''
        result = self._values.get("image_registry_credentials")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.ImageRegistryCredentialsProperty]]]], result)

    @builtins.property
    def image_snapshot_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: imageSnapshotId: The ID of the image cache snapshot.
        '''
        result = self._values.get("image_snapshot_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ingress_bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ingressBandwidth: The maximum inbound bandwidth. Unit: bytes.
        '''
        result = self._values.get("ingress_bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def init_containers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.InitContainersProperty]]]]:
        '''
        :Property: initContainers:
        '''
        result = self._values.get("init_containers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.InitContainersProperty]]]], result)

    @builtins.property
    def instance_family_level(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        instanceFamilyLevel: The level of the instance family. You can use this parameter to filter instance types that meet the specified criteria. This parameter takes effect only if you set CostOptimization to true. Valid values:
        EntryLevel: entry level (shared instance types) Instance types of this level are the most cost-effective but may not provide stable computing performance. Instance types of this level are suitable for scenarios in which CPU utilization is low. For more information, see Shared instance families.
        EnterpriseLevel: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability. For more information, see Overview of instance families.
        CreditEntryLevel: credit entry level (burstable instance types). CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which CPU utilization is low but may fluctuate in specific scenarios. For more information, see Overview of burstable instances.
        '''
        result = self._values.get("instance_family_level")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: instanceTypes: The specified ECS instance types. You can specify up to five ECS instance types. For more information, see Specify ECS instance types to create an elastic container instance.
        '''
        result = self._values.get("instance_types")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def ipv6_address_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipv6AddressCount: The number of IPv6 addresses.
        '''
        result = self._values.get("ipv6_address_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def load_balancer_weight(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        loadBalancerWeight: The weight of the elastic container instance as a backend server. Valid values: 1 to 100.
        Default value: 50.
        '''
        result = self._values.get("load_balancer_weight")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def memory(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: memory: The memory size that you want to allocate to the elastic container instance. Unit: GiB.
        '''
        result = self._values.get("memory")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ntp_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: ntpServers: The Network Time Protocol (NTP) server.
        '''
        result = self._values.get("ntp_servers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def ram_role_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ramRoleName: The name of the Resource Access Management (RAM) role that you want to assign to the elastic container instance. Elastic container instances and Elastic Compute Service (ECS) instances can share the same RAM role. For more information, see Use an instance RAM role by calling API operations.
        '''
        result = self._values.get("ram_role_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def restart_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        restartPolicy: The restart policy of the elastic container instance. Valid values:
        Always: always restarts the elastic container instance.
        Never: never restarts the elastic container instance.
        OnFailure: restarts the elastic container instance upon failures.
        Default value: Always.
        '''
        result = self._values.get("restart_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_context_sysctls(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.SecurityContextSysctlsProperty]]]]:
        '''
        :Property: securityContextSysctls:
        '''
        result = self._values.get("security_context_sysctls")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.SecurityContextSysctlsProperty]]]], result)

    @builtins.property
    def spot_price_limit(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotPriceLimit: The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places.
        If you set SpotStrategy to SpotWithPriceLimit, you must specify SpotPriceLimit.
        '''
        result = self._values.get("spot_price_limit")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotStrategy: The bidding policy of the instance. Valid values:
        NoSpot: The instance is created as a pay-as-you-go instance.
        SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
        SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is used as the bid price.
        Default value: NoSpot.
        '''
        result = self._values.get("spot_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[RosEciScalingConfiguration.TagsProperty]]:
        '''
        :Property: tags:
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosEciScalingConfiguration.TagsProperty]], result)

    @builtins.property
    def termination_grace_period_seconds(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: terminationGracePeriodSeconds: The buffer period during which a program handles operations before the program is stopped. Unit: seconds.
        '''
        result = self._values.get("termination_grace_period_seconds")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def volumes(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.VolumesProperty]]]]:
        '''
        :Property: volumes:
        '''
        result = self._values.get("volumes")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.VolumesProperty]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosEciScalingConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosLifecycleHook(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosLifecycleHook",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::LifecycleHook``, which is used to create a lifecycle hook for a scaling group.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``LifecycleHook`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-lifecyclehook
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosLifecycleHookProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57fc91d59300f2336a829dda4336fca4ac11f861ae726b5665cbaf2ac7896d7a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__563fbf537f7f2273e12479327c31d8505c72a5d4c26cb8d51e655fac84f91f1b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrLifecycleHookId")
    def attr_lifecycle_hook_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: LifecycleHookId: The lifecycle hook ID
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrLifecycleHookId"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingGroupId: The id of the scaling group to which the lifecycle hook belongs.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95d065d4f23e8eef8aa5fd7edd92721e2245694e4654f50a736876a5ef7b7643)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="lifecycleTransition")
    def lifecycle_transition(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        lifecycleTransition: The scaling activities to which lifecycle hooks apply Value range:
        SCALE_OUT: scale-out event
        SCALE_IN: scale-in event
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "lifecycleTransition"))

    @lifecycle_transition.setter
    def lifecycle_transition(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c13363b80b50095519ed91f638b1d9eb01b904905e81366d97081b667916733)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "lifecycleTransition", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37fe5fbf2a782dff958f12ba54369b88a85baede98b47d7330f8902aa0415cb8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="defaultResult")
    def default_result(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        defaultResult: The action that the scaling group takes when the lifecycle hook times out. Value range:
        CONTINUE: the scaling group continues with the scale-in or scale-out process.
        ABANDON: the scaling group stops any remaining action of the scale-in or scale-out event.
        Default value: CONTINUE
        If the scaling group has multiple lifecycle hooks and one of them is terminated by the DefaultResult=ABANDON parameter during a scale-in event (SCALE_IN), the remaining lifecycle hooks under the same scaling group will also be terminated. Otherwise, the action following the wait state is the next action, as specified in the parameter DefaultResult, after the last lifecycle event under the same scaling group.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "defaultResult"))

    @default_result.setter
    def default_result(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6745b82ad4e1c00bf9b973d8ef3581f023e2e79433be4bfe28e56fe4f1a721b7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "defaultResult", value)

    @builtins.property
    @jsii.member(jsii_name="heartbeatTimeout")
    def heartbeat_timeout(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        heartbeatTimeout: The time, in seconds, that can elapse before the lifecycle hook times out. If the lifecycle hook times out, the scaling group performs the default action (DefaultResult). The range is from 30 to 86400 seconds. The default value is 600 seconds.
        You can prevent the lifecycle hook from timing out by calling the RecordLifecycleActionHeartbeat operation. You can also terminate the lifecycle action by calling the CompleteLifecycleAction operation.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "heartbeatTimeout"))

    @heartbeat_timeout.setter
    def heartbeat_timeout(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5bb60926d7f23fa1e74fcd7976e770f42260bab55175f08aaa3e908ed90dae8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "heartbeatTimeout", value)

    @builtins.property
    @jsii.member(jsii_name="lifecycleHookName")
    def lifecycle_hook_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        lifecycleHookName: The name of the lifecycle hook. Each name must be unique within a scaling group. The name must be 2 to 64 characters in length and can contain letters, numbers, Chinese characters, and special characters including underscores (_), hyphens (-) and periods (.).
        Default value: Lifecycle Hook ID
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "lifecycleHookName"))

    @lifecycle_hook_name.setter
    def lifecycle_hook_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95d2e9b29a1a604979ea9d8aaf662758fedb0b9572bccd910da9291841aebb16)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "lifecycleHookName", value)

    @builtins.property
    @jsii.member(jsii_name="notificationArn")
    def notification_arn(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        notificationArn: The Alibaba Cloud Resource Name (ARN) of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This target can be either an MNS queue or an MNS topic. The format of the parameter value is acs:ess:{region}:{account-id}:{resource-relative-id}.
        region: the region to which the scaling group locates
        account-id: Alibaba Cloud ID
        For example:
        MNS queue: acs:ess:{region}:{account-id}:queue/{queuename}
        MNS topic: acs:ess:{region}:{account-id}:topic/{topicname}
        OOS template: acs:ess:{region}:{account-id}:oos/{templatename}
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "notificationArn"))

    @notification_arn.setter
    def notification_arn(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29048251e06c6a5e43b470a7f61fd643c99d57c1c9a954b45604da8537bd9541)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "notificationArn", value)

    @builtins.property
    @jsii.member(jsii_name="notificationMetadata")
    def notification_metadata(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: notificationMetadata: The fixed string that you want to include when Auto Scaling sends a message about the wait state of the scaling activity to the notification target. The length of the parameter can be up to 4096 characters. Auto Scaling will send the specified NotificationMetadata parameter along with the notification message so that you can easily categorize your notifications. The NotificationMetadata parameter will only take effect after you specify the NotificationArn parameter.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "notificationMetadata"))

    @notification_metadata.setter
    def notification_metadata(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7adee079de4117785e3460431cc7da7925ecc448c7685c32e09f6c7583383077)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "notificationMetadata", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosLifecycleHookProps",
    jsii_struct_bases=[],
    name_mapping={
        "lifecycle_transition": "lifecycleTransition",
        "scaling_group_id": "scalingGroupId",
        "default_result": "defaultResult",
        "heartbeat_timeout": "heartbeatTimeout",
        "lifecycle_hook_name": "lifecycleHookName",
        "notification_arn": "notificationArn",
        "notification_metadata": "notificationMetadata",
    },
)
class RosLifecycleHookProps:
    def __init__(
        self,
        *,
        lifecycle_transition: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        default_result: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        heartbeat_timeout: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        lifecycle_hook_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        notification_arn: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        notification_metadata: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosLifecycleHook``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-lifecyclehook

        :param lifecycle_transition: 
        :param scaling_group_id: 
        :param default_result: 
        :param heartbeat_timeout: 
        :param lifecycle_hook_name: 
        :param notification_arn: 
        :param notification_metadata: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__345795d75b456d230f585dd18d3f509731a817828c61adb2a97fcb035a1b6979)
            check_type(argname="argument lifecycle_transition", value=lifecycle_transition, expected_type=type_hints["lifecycle_transition"])
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument default_result", value=default_result, expected_type=type_hints["default_result"])
            check_type(argname="argument heartbeat_timeout", value=heartbeat_timeout, expected_type=type_hints["heartbeat_timeout"])
            check_type(argname="argument lifecycle_hook_name", value=lifecycle_hook_name, expected_type=type_hints["lifecycle_hook_name"])
            check_type(argname="argument notification_arn", value=notification_arn, expected_type=type_hints["notification_arn"])
            check_type(argname="argument notification_metadata", value=notification_metadata, expected_type=type_hints["notification_metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "lifecycle_transition": lifecycle_transition,
            "scaling_group_id": scaling_group_id,
        }
        if default_result is not None:
            self._values["default_result"] = default_result
        if heartbeat_timeout is not None:
            self._values["heartbeat_timeout"] = heartbeat_timeout
        if lifecycle_hook_name is not None:
            self._values["lifecycle_hook_name"] = lifecycle_hook_name
        if notification_arn is not None:
            self._values["notification_arn"] = notification_arn
        if notification_metadata is not None:
            self._values["notification_metadata"] = notification_metadata

    @builtins.property
    def lifecycle_transition(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        lifecycleTransition: The scaling activities to which lifecycle hooks apply Value range:
        SCALE_OUT: scale-out event
        SCALE_IN: scale-in event
        '''
        result = self._values.get("lifecycle_transition")
        assert result is not None, "Required property 'lifecycle_transition' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def default_result(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        defaultResult: The action that the scaling group takes when the lifecycle hook times out. Value range:
        CONTINUE: the scaling group continues with the scale-in or scale-out process.
        ABANDON: the scaling group stops any remaining action of the scale-in or scale-out event.
        Default value: CONTINUE
        If the scaling group has multiple lifecycle hooks and one of them is terminated by the DefaultResult=ABANDON parameter during a scale-in event (SCALE_IN), the remaining lifecycle hooks under the same scaling group will also be terminated. Otherwise, the action following the wait state is the next action, as specified in the parameter DefaultResult, after the last lifecycle event under the same scaling group.
        '''
        result = self._values.get("default_result")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def heartbeat_timeout(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        heartbeatTimeout: The time, in seconds, that can elapse before the lifecycle hook times out. If the lifecycle hook times out, the scaling group performs the default action (DefaultResult). The range is from 30 to 86400 seconds. The default value is 600 seconds.
        You can prevent the lifecycle hook from timing out by calling the RecordLifecycleActionHeartbeat operation. You can also terminate the lifecycle action by calling the CompleteLifecycleAction operation.
        '''
        result = self._values.get("heartbeat_timeout")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def lifecycle_hook_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        lifecycleHookName: The name of the lifecycle hook. Each name must be unique within a scaling group. The name must be 2 to 64 characters in length and can contain letters, numbers, Chinese characters, and special characters including underscores (_), hyphens (-) and periods (.).
        Default value: Lifecycle Hook ID
        '''
        result = self._values.get("lifecycle_hook_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def notification_arn(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        notificationArn: The Alibaba Cloud Resource Name (ARN) of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This target can be either an MNS queue or an MNS topic. The format of the parameter value is acs:ess:{region}:{account-id}:{resource-relative-id}.
        region: the region to which the scaling group locates
        account-id: Alibaba Cloud ID
        For example:
        MNS queue: acs:ess:{region}:{account-id}:queue/{queuename}
        MNS topic: acs:ess:{region}:{account-id}:topic/{topicname}
        OOS template: acs:ess:{region}:{account-id}:oos/{templatename}
        '''
        result = self._values.get("notification_arn")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def notification_metadata(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: notificationMetadata: The fixed string that you want to include when Auto Scaling sends a message about the wait state of the scaling activity to the notification target. The length of the parameter can be up to 4096 characters. Auto Scaling will send the specified NotificationMetadata parameter along with the notification message so that you can easily categorize your notifications. The NotificationMetadata parameter will only take effect after you specify the NotificationArn parameter.
        '''
        result = self._values.get("notification_metadata")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosLifecycleHookProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosLoadBalancerAttachment(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosLoadBalancerAttachment",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::LoadBalancerAttachment``, which is used to add one or more Server Load Balancer (SLB) instances.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``LoadBalancerAttachment`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-loadbalancerattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosLoadBalancerAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__961c8bd385ec262ef9ab3840e388f8722bec7794f114732c0668fd3b8cf4073b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e34492297afe3f420b968411f360b233afe06d52f99b89586c8a7f4896062dd9)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a8db7946cc94363a94aa3a3dc30a147a403571bc0f7bc24cc60baf317324ca4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e69ad2e3f71a5d56575f03c05069dbcac833022c2a3e160fe13558fc3ee6432)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="forceAttach")
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        forceAttach: Specifies whether to add all instances in the current scaling group to the backend server groups of the attached CLB instance. Valid values:
        true
        false
        Default value: false.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "forceAttach"))

    @force_attach.setter
    def force_attach(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f8ce650c86ae3724460dd8f30ceadc56a300eb28c8321bc7edb2cc590f8f32a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "forceAttach", value)

    @builtins.property
    @jsii.member(jsii_name="loadBalancerConfigs")
    def load_balancer_configs(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosLoadBalancerAttachment.LoadBalancerConfigsProperty"]]]]:
        '''
        :Property: loadBalancerConfigs: Load balancer configuration list.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosLoadBalancerAttachment.LoadBalancerConfigsProperty"]]]], jsii.get(self, "loadBalancerConfigs"))

    @load_balancer_configs.setter
    def load_balancer_configs(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosLoadBalancerAttachment.LoadBalancerConfigsProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a04dd62b04c34e9239bad9c7ee1eb49ede46f4ddae0a7dda35db0a76a0e8ce7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loadBalancerConfigs", value)

    @builtins.property
    @jsii.member(jsii_name="loadBalancers")
    def load_balancers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: loadBalancers: The ID of CLB instance N that you want to attach to the scaling group. Valid values of N: 1 to 5.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "loadBalancers"))

    @load_balancers.setter
    def load_balancers(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59e877aafc4932abb675ae3c68433e455b5ab47b2818be612b78c705836e2858)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loadBalancers", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosLoadBalancerAttachment.LoadBalancerConfigsProperty",
        jsii_struct_bases=[],
        name_mapping={"load_balancer_id": "loadBalancerId", "weight": "weight"},
    )
    class LoadBalancerConfigsProperty:
        def __init__(
            self,
            *,
            load_balancer_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param load_balancer_id: 
            :param weight: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8905b9145f6b218e588c83b56ee0e9df0a4a729bee9b7d6a5c86daed6154d9e9)
                check_type(argname="argument load_balancer_id", value=load_balancer_id, expected_type=type_hints["load_balancer_id"])
                check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if load_balancer_id is not None:
                self._values["load_balancer_id"] = load_balancer_id
            if weight is not None:
                self._values["weight"] = weight

        @builtins.property
        def load_balancer_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: loadBalancerId: The ID of the CLB instance.
            '''
            result = self._values.get("load_balancer_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def weight(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            weight: The weight of an Elastic Compute Service (ECS) instance as a backend server in the backend server groups of the attached CLB instance. If you increase the weight of an ECS instance, the number of access requests that are forwarded to the ECS instance also increases. If you set Weight to 0 for an ECS instance, no access requests are forwarded to the ECS instance.
            Valid values: 0 to 100.
            '''
            result = self._values.get("weight")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LoadBalancerConfigsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosLoadBalancerAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "force_attach": "forceAttach",
        "load_balancer_configs": "loadBalancerConfigs",
        "load_balancers": "loadBalancers",
    },
)
class RosLoadBalancerAttachmentProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        load_balancer_configs: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosLoadBalancerAttachment.LoadBalancerConfigsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        load_balancers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosLoadBalancerAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-loadbalancerattachment

        :param scaling_group_id: 
        :param force_attach: 
        :param load_balancer_configs: 
        :param load_balancers: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d92760cafdb81677fdb1fd97cbe39aac8264baaad3789d261614f6e1ea69f01)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument force_attach", value=force_attach, expected_type=type_hints["force_attach"])
            check_type(argname="argument load_balancer_configs", value=load_balancer_configs, expected_type=type_hints["load_balancer_configs"])
            check_type(argname="argument load_balancers", value=load_balancers, expected_type=type_hints["load_balancers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
        }
        if force_attach is not None:
            self._values["force_attach"] = force_attach
        if load_balancer_configs is not None:
            self._values["load_balancer_configs"] = load_balancer_configs
        if load_balancers is not None:
            self._values["load_balancers"] = load_balancers

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        forceAttach: Specifies whether to add all instances in the current scaling group to the backend server groups of the attached CLB instance. Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("force_attach")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def load_balancer_configs(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosLoadBalancerAttachment.LoadBalancerConfigsProperty]]]]:
        '''
        :Property: loadBalancerConfigs: Load balancer configuration list.
        '''
        result = self._values.get("load_balancer_configs")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosLoadBalancerAttachment.LoadBalancerConfigsProperty]]]], result)

    @builtins.property
    def load_balancers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: loadBalancers: The ID of CLB instance N that you want to attach to the scaling group. Valid values of N: 1 to 5.
        '''
        result = self._values.get("load_balancers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosLoadBalancerAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosScalingConfiguration(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosScalingConfiguration",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::ScalingConfiguration``, which is used to create a scaling configuration for a scaling group.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``ScalingConfiguration`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalingconfiguration
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosScalingConfigurationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc3736789ace51b21bdd3a49d37f206468c342c52ac58836d144f0ad0bf4c0b3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce5fc6b0b04b705dcb94889a9b28263700dd07e064088a31128d0dcca0bfd6ff)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingConfigurationId")
    def attr_scaling_configuration_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingConfigurationId: The scaling configuration id
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingConfigurationId"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingGroupId: The id of the scaling group to which the scaling configuration belongs.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__677601f93c951dbba697f77d3d43fbc56744a2ebf62b9311403cd99503cfae57)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: Scaling group id to create the scaling configuration.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef08af6738238cf4e4c1164bfcb6d0ba5a2090cc7daad9c422f998fc46bf2976)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="affinity")
    def affinity(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        affinity: Specifies whether to associate an ECS instance on a dedicated host with the dedicated host. Valid values:

        - **default**: does not associate the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode and the original dedicated host has insufficient resources, the ECS instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
        - **host**: associates the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the ECS instance fails to start.
        Default value: **default**
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "affinity"))

    @affinity.setter
    def affinity(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__108d521660dc86e34746f1ff1f0646487869024d59f224ba11d5cd7d49c8f083)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "affinity", value)

    @builtins.property
    @jsii.member(jsii_name="cpu")
    def cpu(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        cpu: The number of vCPUs.
        You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set CPU to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
        **Note**: You can specify **Cpu** and **Memory** to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "cpu"))

    @cpu.setter
    def cpu(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7379c6129374bdddf86a2e72b21dfe52ab706bbce03ea7e2e1a955c4503045dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpu", value)

    @builtins.property
    @jsii.member(jsii_name="creditSpecification")
    def credit_specification(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        creditSpecification: The performance mode of the burstable instance. Valid values:
        Standard: the standard mode.
        Unlimited: the unlimited mode.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "creditSpecification"))

    @credit_specification.setter
    def credit_specification(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59cad1eda38f8b1f3a519eda8eec57034069181365df94b7181c64191b3904ca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "creditSpecification", value)

    @builtins.property
    @jsii.member(jsii_name="dedicatedHostId")
    def dedicated_host_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dedicatedHostId: The ID of the dedicated host on which you want to create an ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify **DedicatedHostId**, **SpotStrategy** and **SpotPriceLimit** are ignored.
        You can call the **DescribeDedicatedHosts** operation to query dedicated host IDs.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "dedicatedHostId"))

    @dedicated_host_id.setter
    def dedicated_host_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be1849591ef4ab200da867a262a8778851b216ee75f3fff670a49a14c14de6de)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dedicatedHostId", value)

    @builtins.property
    @jsii.member(jsii_name="deploymentSetId")
    def deployment_set_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: deploymentSetId: Deployment set ID.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "deploymentSetId"))

    @deployment_set_id.setter
    def deployment_set_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5bccf97da4f501af5332dd1a446d88c6df992a21ff423811246dd338878510db)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deploymentSetId", value)

    @builtins.property
    @jsii.member(jsii_name="diskMappings")
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.DiskMappingsProperty"]]]]:
        '''
        :Property: diskMappings: Disk mappings to attach to instance.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.DiskMappingsProperty"]]]], jsii.get(self, "diskMappings"))

    @disk_mappings.setter
    def disk_mappings(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.DiskMappingsProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__606c2339da212d24c73c450529b9fe22b8f0e42dc81d501c22c35e1e70974bee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskMappings", value)

    @builtins.property
    @jsii.member(jsii_name="hostName")
    def host_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        hostName: The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
        Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
        Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "hostName"))

    @host_name.setter
    def host_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7454d0761f0ff372c417eb10319e916f7a9bd9096020f78f95808ac1ed433324)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hostName", value)

    @builtins.property
    @jsii.member(jsii_name="hpcClusterId")
    def hpc_cluster_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "hpcClusterId"))

    @hpc_cluster_id.setter
    def hpc_cluster_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc8259f421174d1c0e8469b66ff1ca8ba738dfb74325daa2013c4019dba223ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hpcClusterId", value)

    @builtins.property
    @jsii.member(jsii_name="imageFamily")
    def image_family(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: imageFamily: The name of the image family. You can configure this parameter to obtain the latest available images within the specified image family. The images are used to create ECS instances. If you have set the ImageId parameter, you cannot set the ImageFamily parameter.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "imageFamily"))

    @image_family.setter
    def image_family(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e7f892fd57c1468945a1e8d0aef617f820f835724ea5e103df5281cc8cf2a2c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageFamily", value)

    @builtins.property
    @jsii.member(jsii_name="imageId")
    def image_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: imageId: Image ID to create ecs instance .
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "imageId"))

    @image_id.setter
    def image_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73ce4f619c8e8d29bee52fbba82dca5a791764d5e3b6f947c6c57e1b9408b868)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageId", value)

    @builtins.property
    @jsii.member(jsii_name="imageName")
    def image_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        imageName: The name of the image. Each image name must be unique in a region. If you specify **ImageId**, **ImageName** is ignored.
        You cannot use **ImageName** to specify images that are purchased from Alibaba Cloud Marketplace.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "imageName"))

    @image_name.setter
    def image_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2bd4ab96a23f80dda993dd4e7eea21ee8ff11bdb921e80e5c20d5f717830d19a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageName", value)

    @builtins.property
    @jsii.member(jsii_name="imageOptionsLoginAsNonRoot")
    def image_options_login_as_non_root(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        imageOptionsLoginAsNonRoot: Whether the ecs instance is logged in as ecs-user.Valid values:

        - **true**
        - **false**
        Default value: **false**.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "imageOptionsLoginAsNonRoot"))

    @image_options_login_as_non_root.setter
    def image_options_login_as_non_root(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e9b5b848944a6142d06d1e43e33180547c78a8343499f2d6c236af25cb9053e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageOptionsLoginAsNonRoot", value)

    @builtins.property
    @jsii.member(jsii_name="instanceDescription")
    def instance_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceDescription: The description of the ECS instance. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceDescription"))

    @instance_description.setter
    def instance_description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c696b79a7c8acf18f4d7ffce8cf42a44fd61f6504a0cdc7547f9e7b6845959d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceDescription", value)

    @builtins.property
    @jsii.member(jsii_name="instanceId")
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceId: Source ECS instance to copy configuration, if the properties is setting, Which will copy the InstanceType, ImageId, InternetChargeType, IoOptimized,UserData, KeyPairName, RamRoleName, InternetMaxBandwidthIn,InternetMaxBandwidthOut, and first security group id from source instance, you can also specify the relative properties to overwrite the properties copy from source instance id.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa70661252f24661fcab63e263e524859463b15f7ad7030f6a0827c66d9e6c8a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceId", value)

    @builtins.property
    @jsii.member(jsii_name="instanceName")
    def instance_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceName: The name of the instance launched from the current scaling configuration.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceName"))

    @instance_name.setter
    def instance_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90a7b777c5e3e9c274f9abefe866f66d0374573092a3c712d2c2c8d7e9583085)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceName", value)

    @builtins.property
    @jsii.member(jsii_name="instancePatternInfos")
    def instance_pattern_infos(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.InstancePatternInfosProperty"]]]]:
        '''
        :Property: instancePatternInfos: Details of the intelligent configuration settings that determine the range of instance types that meet the specified criteria.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.InstancePatternInfosProperty"]]]], jsii.get(self, "instancePatternInfos"))

    @instance_pattern_infos.setter
    def instance_pattern_infos(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.InstancePatternInfosProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8685d17f6d29d932480992f19ab5f674c62a24f8574b7071a45ecd0c33067e3e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instancePatternInfos", value)

    @builtins.property
    @jsii.member(jsii_name="instanceType")
    def instance_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceType: ecs supported instance type.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceType"))

    @instance_type.setter
    def instance_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__499b99e8e9caf3e37220501480d14ffcdd37f171bc281b947c91b11e27ad984f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceType", value)

    @builtins.property
    @jsii.member(jsii_name="instanceTypeOverrides")
    def instance_type_overrides(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.InstanceTypeOverridesProperty"]]]]:
        '''
        :Property: instanceTypeOverrides: The instance types.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.InstanceTypeOverridesProperty"]]]], jsii.get(self, "instanceTypeOverrides"))

    @instance_type_overrides.setter
    def instance_type_overrides(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.InstanceTypeOverridesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52e5db7e641abec46db3bdb63ac928b5e4f5cd0a8fa0198feb91e3a4141bc18c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceTypeOverrides", value)

    @builtins.property
    @jsii.member(jsii_name="instanceTypes")
    def instance_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: instanceTypes: ecs supported instance types. Length [1,10]. If InstanceTypes is specified,the InstanceType will be ignored.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "instanceTypes"))

    @instance_types.setter
    def instance_types(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c40e0ecaf94abb2433f8ee24dd27aef0953fb451acf9a7ff5bb95b818102ad0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceTypes", value)

    @builtins.property
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetChargeType"))

    @internet_charge_type.setter
    def internet_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62bce03693933e15732b4dce2e438265e6eb8b152b7da5d639f8d5df2e327ac9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetMaxBandwidthIn: Maximum incoming bandwidth from the public network, measured in Mbps (Mega bit per second). The value range is [1,200]. If this parameter value is not specified, AliyunAPI automatically sets the value to 200 Mbps.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetMaxBandwidthIn"))

    @internet_max_bandwidth_in.setter
    def internet_max_bandwidth_in(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afe3eb121d779ad7a4f2b1a000e290a01dfc6ac1112763362511f54abf004459)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetMaxBandwidthIn", value)

    @builtins.property
    @jsii.member(jsii_name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetMaxBandwidthOut: Maximum outgoing bandwidth from the public network, measured in Mbps (Mega bit per second).
        The value range for PayByBandwidth is [0,100]. If this parameter value is not specified, AliyunAPI automatically sets the value to 0 Mbps.
        The value range for PayByTraffic is [0,100]. If this parameter value is not specified, an error is reported
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetMaxBandwidthOut"))

    @internet_max_bandwidth_out.setter
    def internet_max_bandwidth_out(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ebca14c40b2e5f8dafd24f736f6e7cddb5ac1fcda6f79ec0dd5a00bcf59c0fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetMaxBandwidthOut", value)

    @builtins.property
    @jsii.member(jsii_name="ioOptimized")
    def io_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'none'.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ioOptimized"))

    @io_optimized.setter
    def io_optimized(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d9337c47a3c04319e70c6e3e08aff2b439ca37f711547a69e148cbca33a9e89)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ioOptimized", value)

    @builtins.property
    @jsii.member(jsii_name="ipv6AddressCount")
    def ipv6_address_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipv6AddressCount: The number of randomly generated IPv6 addresses to be assigned to the elastic network interface (ENI).
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ipv6AddressCount"))

    @ipv6_address_count.setter
    def ipv6_address_count(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4e77bb5a6076dc184e17fe78d20d63bd473daecddd345ff77afc7ef0be861f0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipv6AddressCount", value)

    @builtins.property
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: keyPairName: SSH key pair name.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "keyPairName"))

    @key_pair_name.setter
    def key_pair_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf8507da5e2684304087d5457b6af939b823a7f1b8eaa4352218db6ba016c2bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyPairName", value)

    @builtins.property
    @jsii.member(jsii_name="loadBalancerWeight")
    def load_balancer_weight(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        loadBalancerWeight: The weight of the ECS instance as a backend server. Valid values: 1 to 100.
        Default value: 50.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "loadBalancerWeight"))

    @load_balancer_weight.setter
    def load_balancer_weight(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0e1476480a95d457d5860b75481675cb823c4c68737693da803b912f4a883c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loadBalancerWeight", value)

    @builtins.property
    @jsii.member(jsii_name="memory")
    def memory(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        memory: The memory size. Unit: GiB.
        You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
        **Note**: You can specify **Cpu** and **Memory** to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "memory"))

    @memory.setter
    def memory(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fb2367746f52f1f30d3df05a59a3dd8c0a43593a16941a0071e64f27fb8e073)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "memory", value)

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "password"))

    @password.setter
    def password(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f97d659ac8c2000d609920da7ec42611e7e47fdf53b6a542ff353da520d0b097)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "password", value)

    @builtins.property
    @jsii.member(jsii_name="passwordInherit")
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: passwordInherit: Whether to use the password pre-configured in the image you select or not. When PasswordInherit is specified, the Password must be null. For a secure access, make sure that the selected image has password configured.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "passwordInherit"))

    @password_inherit.setter
    def password_inherit(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e11312a10a96ffda3ba1a28a4a45086695bc163669c649cf51f575038a97cf2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "passwordInherit", value)

    @builtins.property
    @jsii.member(jsii_name="privatePoolOptions")
    def private_pool_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.PrivatePoolOptionsProperty"]]:
        '''
        :Property: privatePoolOptions: Option settings for private pools
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.PrivatePoolOptionsProperty"]], jsii.get(self, "privatePoolOptions"))

    @private_pool_options.setter
    def private_pool_options(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.PrivatePoolOptionsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1daee1062f92e2c882d399ecf9350bce387dfa05c6e7de6d8866f507de80e467)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "privatePoolOptions", value)

    @builtins.property
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ramRoleName"))

    @ram_role_name.setter
    def ram_role_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6957f0fbf659bbfddecc46e4b1bd454b6e6f6a101dc7a56bd2054ad870b4bae4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ramRoleName", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: Resource group id.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__285e84e0da51e82ee3070d78b5a37cfb677b64889900647873c13b34c4265bae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="scalingConfigurationName")
    def scaling_configuration_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: scalingConfigurationName: Name of created scaling configuration.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scalingConfigurationName"))

    @scaling_configuration_name.setter
    def scaling_configuration_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f326fb86f2d25015d3e15b87ed4b673bb36d3f822c8382804bfbf236bdd73031)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingConfigurationName", value)

    @builtins.property
    @jsii.member(jsii_name="securityEnhancementStrategy")
    def security_enhancement_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        securityEnhancementStrategy: Specifies whether to enable security hardening. Valid values:

        - **Active**: enables security hardening. This value is applicable only to public images.
        - **Deactive**: disables security hardening. This value is applicable to all image types.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "securityEnhancementStrategy"))

    @security_enhancement_strategy.setter
    def security_enhancement_strategy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c71ce8bab5a98e432882f1924c1da91fde695b10b984a65cc50182fd4e3a26f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityEnhancementStrategy", value)

    @builtins.property
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: securityGroupId: Security Group to create ecs instance.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "securityGroupId"))

    @security_group_id.setter
    def security_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0a9c4e8fd23c88aee36c37063331c06480078aa58234cb0bd0de61d40b1bf28)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        securityGroupIds: The IDs of the security groups with which you want to associate the ECS instances that are created by using the scaling configuration.
        **Note**: If you specify **SecurityGroupId**, you cannot specify **SecurityGroupIds**.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "securityGroupIds"))

    @security_group_ids.setter
    def security_group_ids(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e97224c373ce70670616a24e381166860b051512514d4ac32f88aacf040441e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityGroupIds", value)

    @builtins.property
    @jsii.member(jsii_name="spotDuration")
    def spot_duration(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotDuration: The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
        If you set this parameter to 0, no protection period is specified for the preemptible instance.
        Default value: 1
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotDuration"))

    @spot_duration.setter
    def spot_duration(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07f7b3cd10964e4a6974538f46ef760af035a7ff7e03f95970b1625faaa0b202)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotDuration", value)

    @builtins.property
    @jsii.member(jsii_name="spotInterruptionBehavior")
    def spot_interruption_behavior(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: spotInterruptionBehavior: The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate. This value specifies that the preemptible instance is to be released.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotInterruptionBehavior"))

    @spot_interruption_behavior.setter
    def spot_interruption_behavior(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eea29678ed7ce88aeeededa614412e50d322a9ff018dabb7a0c512a4d013fcaf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotInterruptionBehavior", value)

    @builtins.property
    @jsii.member(jsii_name="spotPriceLimit")
    def spot_price_limit(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: spotPriceLimit: Set the hourly maximum price for the instance. Supports a maximum of 3 decimal places, and the parameter takes effect only when the value of SpotStrategy is SpotWithPriceLimit.It is a default value for all instance types, and can be overwrite by SpotPriceLimitForInstanceType
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotPriceLimit"))

    @spot_price_limit.setter
    def spot_price_limit(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5923896a7836c06a59c03cf6dfae4661aee5e0262516a32d908422e5303f95e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotPriceLimit", value)

    @builtins.property
    @jsii.member(jsii_name="spotPriceLimitForInstanceType")
    def spot_price_limit_for_instance_type(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        '''
        :Property:

        spotPriceLimitForInstanceType: Set the hourly maximum price for the instance of specified instance type.
        The parameter takes effect only when the value of SpotStrategy is SpotWithPriceLimit.
        You should input the information of the tag with the format of the Key-Value, such as {"key1":"value1","key2":"value2", ... "key5":"value5"}.
        At most 50 items can be specified.
        Key
        ecs instance type
        Value
        Supports a maximum of 3 decimal places.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]], jsii.get(self, "spotPriceLimitForInstanceType"))

    @spot_price_limit_for_instance_type.setter
    def spot_price_limit_for_instance_type(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84df159d08dbf2b916e17aecb46858724488564bd2c2bbcd74f879ff441f4994)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotPriceLimitForInstanceType", value)

    @builtins.property
    @jsii.member(jsii_name="spotStrategy")
    def spot_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotStrategy: Preemption strategy for post-paid instances. It takes effect when the parameter InstanceChargeType takes the value of PostPaid. Ranges:
        NoSpot: Normal pay-per-use instance
        SpotWithPriceLimit: Set a preemptive instance of the cap price
        SpotAsPriceGo: System automatic bidding, following the current market actual price
        Default: NoSpot.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotStrategy"))

    @spot_strategy.setter
    def spot_strategy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82183a4e74d7c5bf1696a2dacad67d9a6b499c7b9586f0895533b69a7b1bd447)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotStrategy", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskAutoSnapshotPolicyId")
    def system_disk_auto_snapshot_policy_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskAutoSnapshotPolicyId"))

    @system_disk_auto_snapshot_policy_id.setter
    def system_disk_auto_snapshot_policy_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__005e62578e59057a9e0c73dd92bea6e8961433c82cab3490c637ce3357dd83d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskAutoSnapshotPolicyId", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskBurstingEnabled")
    def system_disk_bursting_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        systemDiskBurstingEnabled: Specifies whether to enable the burst feature for the system disk. Valid values:

        - **true**
        - **false**
        **Note**: This parameter is available only if you set **SystemDiskCategory** to **cloud_auto**.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskBurstingEnabled"))

    @system_disk_bursting_enabled.setter
    def system_disk_bursting_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e273b5850a310395fe1592b15ff1848c1835fdf6583b14107a2fa23512f7a2da)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskBurstingEnabled", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskCategories")
    def system_disk_categories(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        systemDiskCategories: The categories of the system disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:

        - **cloud**: basic disk
        - **cloud_efficiency**: ultra disk
        - **cloud_ssd**: standard SSD
        - **cloud_essd**: ESSD
        **Note**: If you specify **SystemDiskCategories**, you cannot specify **SystemDiskCategory**.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "systemDiskCategories"))

    @system_disk_categories.setter
    def system_disk_categories(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fb0586c2335d3daad0feae6ed4663251982450525300d5e9f7efafb8b1e1931)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskCategories", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskCategory")
    def system_disk_category(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskCategory: Category of system disk. Default is cloud.support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd|cloud_auto
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskCategory"))

    @system_disk_category.setter
    def system_disk_category(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53c95809a2d2aa1a7a5db90b65f1f5ddb03fa7dd67386f85ee7bb31324c7f5c7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskCategory", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskDescription")
    def system_disk_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskDescription: The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskDescription"))

    @system_disk_description.setter
    def system_disk_description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf5c1f5fa362889cf95c569a43e014f013749a9485084df420351a6ed65feca8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskDescription", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskDiskName")
    def system_disk_disk_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskDiskName: The name of the system disk. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskDiskName"))

    @system_disk_disk_name.setter
    def system_disk_disk_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62d6f8be398f7ca22f17712b07582255036c4b65c0801766ccbb827ae47c189e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskDiskName", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskEncryptAlgorithm")
    def system_disk_encrypt_algorithm(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        systemDiskEncryptAlgorithm: The encryption algorithm that you want to use to encrypt the system disk. Valid values:

        - **AES-256**
        - **SM4-128**
        Default value: **AES-256**
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskEncryptAlgorithm"))

    @system_disk_encrypt_algorithm.setter
    def system_disk_encrypt_algorithm(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04ed1c07f81060372984760f7ebaafa0ed9724f1a3c8aae891a85520c59ad985)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskEncryptAlgorithm", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskEncrypted")
    def system_disk_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        systemDiskEncrypted: Specifies whether to encrypt the system disk. Valid values:

        - **true**
        - **false**
        Default value: **false**
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskEncrypted"))

    @system_disk_encrypted.setter
    def system_disk_encrypted(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45a73fc36b84d2c8b76bcae1656bb0267aaa77d4a0c4f2ac0a7ff45ba35dab74)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskEncrypted", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskKmsKeyId")
    def system_disk_kms_key_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskKmsKeyId: The ID of the KMS key that you want to use to encrypt the system disk.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskKmsKeyId"))

    @system_disk_kms_key_id.setter
    def system_disk_kms_key_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e20f671b6f1f37a981aba385b3cc60791017e7eea371079d5c2848d963616eae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskKmsKeyId", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskPerformanceLevel")
    def system_disk_performance_level(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskPerformanceLevel: The performance level of an ESSD.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskPerformanceLevel"))

    @system_disk_performance_level.setter
    def system_disk_performance_level(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20ef09969b6c99e34652e5b2667ded51363e7a7c313f96f346c2d497d8cc3d5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskPerformanceLevel", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskProvisionedIops")
    def system_disk_provisioned_iops(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        systemDiskProvisionedIops: The IOPS metric that is preconfigured for the system disk.
        **Note**: IOPS measures the number of read and write operations that an EBS device can process per second.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskProvisionedIops"))

    @system_disk_provisioned_iops.setter
    def system_disk_provisioned_iops(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a73425c441c415a2410bddda46c5f3ccb3ba79433c15b83dd9b0f1b59a294b4f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskProvisionedIops", value)

    @builtins.property
    @jsii.member(jsii_name="systemDiskSize")
    def system_disk_size(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskSize: Size of system disk. Unit is GB.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "systemDiskSize"))

    @system_disk_size.setter
    def system_disk_size(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67afe00d58cf231eb7ac3fb6d20a5d57f5a5d97715838efea03719bb35274d87)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "systemDiskSize", value)

    @builtins.property
    @jsii.member(jsii_name="tagList")
    def tag_list(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.TagListProperty"]]]]:
        '''
        :Property:

        tagList: The tags of an instance in list format.
        Do not use with Tags at the same time.
        You should input the information of the tag with the format of Key-Value list, such as [{"Key":"key1","Value":"value1"}, ...].
        At most 20 tags can be specified.
        Key
        It can be up to 64 characters in length.
        Cannot begin with aliyun.
        Cannot begin with http:// or https://.
        Cannot be a null string.
        Value
        It can be up to 128 characters in length.
        Cannot begin with aliyun.
        Cannot begin with http:// or https://.
        Can be a null string.If less then 20 tags are specified, ros will add a tag(Key: "ros-aliyun-created", Value:"<resource_name>*stack*<stack_id>") if possible.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.TagListProperty"]]]], jsii.get(self, "tagList"))

    @tag_list.setter
    def tag_list(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingConfiguration.TagListProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4d794f90bc9a0d9a63fac47f839b7179ea525633a90bbfb1e5e25df0f1479fb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tagList", value)

    @builtins.property
    @jsii.member(jsii_name="tenancy")
    def tenancy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        tenancy: Specifies whether to create an ECS instance on a dedicated host. Valid values:

        - **default**: does not create an ECS instance on a dedicated host.
        - **host**: creates an ECS instance on a dedicated host. If you do not specify **DedicatedHostId**, Alibaba Cloud selects a dedicated host for the ECS instance.
        Default value: **default**
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "tenancy"))

    @tenancy.setter
    def tenancy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea65102667116d8b14b389e9f55dc8ade376ea10c90bbefe74a6e5acbc721adc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tenancy", value)

    @builtins.property
    @jsii.member(jsii_name="userData")
    def user_data(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "userData"))

    @user_data.setter
    def user_data(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a35c288ff84684af77eecedbac0b5b5e3e217408c1bc24487558436ace951c36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "userData", value)

    @builtins.property
    @jsii.member(jsii_name="zoneId")
    def zone_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: zoneId: The zone ID of the ECS instance.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "zoneId"))

    @zone_id.setter
    def zone_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d0aba72d23d92660608444287ded7823802fdd5bb007837dda9514e49e996d8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "zoneId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingConfiguration.DiskMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auto_snapshot_policy_id": "autoSnapshotPolicyId",
            "bursting_enabled": "burstingEnabled",
            "categories": "categories",
            "category": "category",
            "delete_with_instance": "deleteWithInstance",
            "description": "description",
            "device": "device",
            "disk_name": "diskName",
            "encrypted": "encrypted",
            "kms_key_id": "kmsKeyId",
            "performance_level": "performanceLevel",
            "provisioned_iops": "provisionedIops",
            "size": "size",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskMappingsProperty:
        def __init__(
            self,
            *,
            auto_snapshot_policy_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            categories: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            category: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            delete_with_instance: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            device: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            disk_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            encrypted: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            kms_key_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            performance_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            size: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            snapshot_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param auto_snapshot_policy_id: 
            :param bursting_enabled: 
            :param categories: 
            :param category: 
            :param delete_with_instance: 
            :param description: 
            :param device: 
            :param disk_name: 
            :param encrypted: 
            :param kms_key_id: 
            :param performance_level: 
            :param provisioned_iops: 
            :param size: 
            :param snapshot_id: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7b66734dff1e85145b6907c20fedb10194946ad52ef783e3df39fede6235aab5)
                check_type(argname="argument auto_snapshot_policy_id", value=auto_snapshot_policy_id, expected_type=type_hints["auto_snapshot_policy_id"])
                check_type(argname="argument bursting_enabled", value=bursting_enabled, expected_type=type_hints["bursting_enabled"])
                check_type(argname="argument categories", value=categories, expected_type=type_hints["categories"])
                check_type(argname="argument category", value=category, expected_type=type_hints["category"])
                check_type(argname="argument delete_with_instance", value=delete_with_instance, expected_type=type_hints["delete_with_instance"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument device", value=device, expected_type=type_hints["device"])
                check_type(argname="argument disk_name", value=disk_name, expected_type=type_hints["disk_name"])
                check_type(argname="argument encrypted", value=encrypted, expected_type=type_hints["encrypted"])
                check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
                check_type(argname="argument performance_level", value=performance_level, expected_type=type_hints["performance_level"])
                check_type(argname="argument provisioned_iops", value=provisioned_iops, expected_type=type_hints["provisioned_iops"])
                check_type(argname="argument size", value=size, expected_type=type_hints["size"])
                check_type(argname="argument snapshot_id", value=snapshot_id, expected_type=type_hints["snapshot_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auto_snapshot_policy_id is not None:
                self._values["auto_snapshot_policy_id"] = auto_snapshot_policy_id
            if bursting_enabled is not None:
                self._values["bursting_enabled"] = bursting_enabled
            if categories is not None:
                self._values["categories"] = categories
            if category is not None:
                self._values["category"] = category
            if delete_with_instance is not None:
                self._values["delete_with_instance"] = delete_with_instance
            if description is not None:
                self._values["description"] = description
            if device is not None:
                self._values["device"] = device
            if disk_name is not None:
                self._values["disk_name"] = disk_name
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if performance_level is not None:
                self._values["performance_level"] = performance_level
            if provisioned_iops is not None:
                self._values["provisioned_iops"] = provisioned_iops
            if size is not None:
                self._values["size"] = size
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def auto_snapshot_policy_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: autoSnapshotPolicyId: The ID of the automatic snapshot policy that you want to apply to the data disk.
            '''
            result = self._values.get("auto_snapshot_policy_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def bursting_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            burstingEnabled: Specifies whether to enable the burst feature for the system disk. Valid values:

            - **true**
            - **false**
            **Note**: This parameter is available only if you set **SystemDisk.Category** to **cloud_auto**.
            '''
            result = self._values.get("bursting_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def categories(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property:

            categories: The categories of the data disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:

            - **cloud**: basic disk. For a basic disk that is created together with the instance, **DeleteWithInstance** is set to true.
            - **cloud_efficiency**: ultra disk.
            - **cloud_ssd**: standard SSD.
            - **cloud_essd**: ESSD.
            **Note**: If you specify **Categories**, you cannot specify **DataDisks.Category**.
            '''
            result = self._values.get("categories")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def category(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            category: The category of the data disk. Valid values:

            - **cloud**: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
            - **cloud_efficiency**: ultra disk.
            - **cloud_ssd**: standard SSD.
            - **ephemeral_ssd**: local SSD.
            - **cloud_essd**: ESSD.
            If you specify **Category**, you cannot specify **Categories**. If you do not specify **Category** or **Categories**, the default value of **Category** is used:
            - For I/O optimized instances, the default value is **cloud_efficiency**.
            - For non-I/O optimized instances, the default value is **cloud**.
            '''
            result = self._values.get("category")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def delete_with_instance(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            deleteWithInstance: Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:

            - **true**
            - **false**
            This parameter is available only for independent disks whose value of **Category** is set to **cloud**, **cloud_efficiency**, **cloud_ssd**, or **cloud_essd**. If you specify this parameter for other disks, an error is reported.
            Default value: **true**
            '''
            result = self._values.get("delete_with_instance")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def description(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def device(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: device: A device name where the volume will be attached in the system at /dev/xvd[id]. Range from '/dev/xvdb' to '/dev/xvdz'.
            '''
            result = self._values.get("device")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def disk_name(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
            '''
            result = self._values.get("disk_name")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            encrypted: Whether the data disk is encrypted or not. Valid values:

            - **true**: Encrypted.
            - **false**: Not encrypted.
            Default value: false.
            '''
            result = self._values.get("encrypted")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def kms_key_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: kmsKeyId: The KMS key ID for the data disk.
            '''
            result = self._values.get("kms_key_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def performance_level(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            performanceLevel: The PL of the data disk that is an ESSD. Valid values:

            - **PL0**: An ESSD can provide up to 10,000 random read/write IOPS.
            - **PL1**: An ESSD can provide up to 50,000 random read/write IOPS.
            - **PL2**: An ESSD can provide up to 100,000 random read/write IOPS.
            - **PL3**: An ESSD can provide up to 1,000,000 random read/write IOPS.
            '''
            result = self._values.get("performance_level")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def provisioned_iops(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            provisionedIops: The IOPS metric that is preconfigured for the data disk.
            **Note**: IOPS measures the number of read and write operations that an EBS device can process per second.
            '''
            result = self._values.get("provisioned_iops")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def size(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            size: The size of the data disk. Unit: GiB. Valid values:

            - If you set Categories to cloud: 5 to 2000.
            - If you set Categories to cloud_efficiency: 20 to 32768.
            - If you set Categories to cloud_essd: 20 to 32768.
            - If you set Categories to ephemeral_ssd: 5 to 800.
            The size of the data disk must be greater than or equal to the size of the snapshot that is specified by SnapshotId.
            '''
            result = self._values.get("size")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def snapshot_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: snapshotId: ID of the snapshot to create the volume.
            '''
            result = self._values.get("snapshot_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingConfiguration.InstancePatternInfosProperty",
        jsii_struct_bases=[],
        name_mapping={
            "architectures": "architectures",
            "burstable_performance": "burstablePerformance",
            "cores": "cores",
            "excluded_instance_types": "excludedInstanceTypes",
            "instance_family_level": "instanceFamilyLevel",
            "max_price": "maxPrice",
            "memory": "memory",
        },
    )
    class InstancePatternInfosProperty:
        def __init__(
            self,
            *,
            architectures: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            burstable_performance: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            cores: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            excluded_instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
            instance_family_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            max_price: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param architectures: 
            :param burstable_performance: 
            :param cores: 
            :param excluded_instance_types: 
            :param instance_family_level: 
            :param max_price: 
            :param memory: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__45c3c52027a82825ec576c0beadee9b0534f99e85e7ed7752e9e032bcca10689)
                check_type(argname="argument architectures", value=architectures, expected_type=type_hints["architectures"])
                check_type(argname="argument burstable_performance", value=burstable_performance, expected_type=type_hints["burstable_performance"])
                check_type(argname="argument cores", value=cores, expected_type=type_hints["cores"])
                check_type(argname="argument excluded_instance_types", value=excluded_instance_types, expected_type=type_hints["excluded_instance_types"])
                check_type(argname="argument instance_family_level", value=instance_family_level, expected_type=type_hints["instance_family_level"])
                check_type(argname="argument max_price", value=max_price, expected_type=type_hints["max_price"])
                check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if architectures is not None:
                self._values["architectures"] = architectures
            if burstable_performance is not None:
                self._values["burstable_performance"] = burstable_performance
            if cores is not None:
                self._values["cores"] = cores
            if excluded_instance_types is not None:
                self._values["excluded_instance_types"] = excluded_instance_types
            if instance_family_level is not None:
                self._values["instance_family_level"] = instance_family_level
            if max_price is not None:
                self._values["max_price"] = max_price
            if memory is not None:
                self._values["memory"] = memory

        @builtins.property
        def architectures(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property:

            architectures: The architectures of the instance types. Valid values:

            - **X86**: x86 architecture.
            - **Heterogeneous**: heterogeneous architecture, such as GPUs and FPGAs.
            - **BareMetal**: ECS Bare Metal Instance architecture.
            - **Arm**: ARM architecture.
            - **SuperComputeCluster**: Super Computing Cluster architecture.
            By default, all values are included.
            '''
            result = self._values.get("architectures")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def burstable_performance(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            burstablePerformance: Specifies whether to include burstable instance types. Valid values:

            - **Exclude**: does not include burstable instance types.
            - **Include**: includes burstable instance types.
            - **Required**: includes only burstable instance types.
            Default value: **Include**
            '''
            result = self._values.get("burstable_performance")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def cores(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            cores: The number of vCPUs that you want to allocate to an instance type in intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.
            Take note of the following items when you specify Cores:

            - InstancePatternInfos is available only for scaling groups that reside in VPCs.
            - If you specify InstancePatternInfos, you must specify Cores and Memory.
            - If you specify an instance type by using InstanceType or InstanceTypes, Auto Scaling preferentially uses the instance type that is specified by InstanceType or InstanceTypes for scale-outs. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances by using the lowest-priced instance type that is specified by InstancePatternInfos.
            '''
            result = self._values.get("cores")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def excluded_instance_types(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
            '''
            :Property:

            excludedInstanceTypes: The instance types that you want to exclude. You can use wildcard characters, such as asterisks (*), to exclude an instance type or an instance family. Examples:

            - ecs.c6.large: excludes the ecs.c6.large instance type.
            - ecs.c6.*: excludes the c6 instance family.
            '''
            result = self._values.get("excluded_instance_types")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

        @builtins.property
        def instance_family_level(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            instanceFamilyLevel: The level of the instance type, which is used to filter instance types that meet the specified criteria. This parameter takes effect only if you set **CostOptimization** to true. Valid values:

            - **EntryLevel**: entry level (shared instance type). Instance types of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instance types of this level are suitable for business scenarios in which the CPU utilization is low.
            - **EnterpriseLevel**: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability.
            - **CreditEntryLevel**: credit entry level. This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which the CPU utilization is low but may fluctuate in specific cases.
            '''
            result = self._values.get("instance_family_level")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def max_price(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            maxPrice: The maximum hourly price of a pay-as-you-go or preemptible instance in intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.
            **Note**: If you set **SpotStrategy** to **SpotWithPriceLimit**, you must specify **MaxPrice**. In other cases, **MaxPrice** is optional.
            '''
            result = self._values.get("max_price")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def memory(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: memory: The memory size that you want to allocate to an instance type in intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.
            '''
            result = self._values.get("memory")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstancePatternInfosProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingConfiguration.InstanceTypeOverridesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instance_type": "instanceType",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class InstanceTypeOverridesProperty:
        def __init__(
            self,
            *,
            instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            weighted_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param instance_type: 
            :param weighted_capacity: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__181783adb53885162463202afc6641a4c6c7415934934c4d866cd2ab39cb73ce)
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument weighted_capacity", value=weighted_capacity, expected_type=type_hints["weighted_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def instance_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            instanceType: Instance type N that you want to use to override the instance type that is specified in the launch template.
            If you want to trigger scale-outs based on the weighted capacities of instances, specify **InstanceType** and **WeightedCapacity** at the same time. You can specify N instance types by using the Extended Configurations feature. Valid values of N: 1 to 10.
            **Note**: This parameter takes effect only if you specify **LaunchTemplateId**.
            You can specify an instance type that is available for purchase as the value of InstanceType.
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def weighted_capacity(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            weightedCapacity: The weight of instance type N. If you want to trigger scale-outs based on the weighted capacities of instances, you must specify **WeightedCapacity** after you specify **InstanceType**.
            The weight of an instance type specifies the capacity of an instance of the instance type in the scaling group. A higher weight specifies that a smaller number of instances of the specified instance type is required to meet the expected capacity requirement.
            Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
            Example:

            - Current capacity: 0
            Expected capacity: 6
            Capacity of ecs.c5.xlarge: 4
            To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
            **Note**: The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by MaxSize and the maximum weight of the instance types.
            Valid values of WeightedCapacity: 1 to 500.
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceTypeOverridesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingConfiguration.PrivatePoolOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"id": "id", "match_criteria": "matchCriteria"},
    )
    class PrivatePoolOptionsProperty:
        def __init__(
            self,
            *,
            id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            match_criteria: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param id: 
            :param match_criteria: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__df368e21643e5131a5135d400a904db38cb23dd35b82daa617b7963be87e3f06)
                check_type(argname="argument id", value=id, expected_type=type_hints["id"])
                check_type(argname="argument match_criteria", value=match_criteria, expected_type=type_hints["match_criteria"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if id is not None:
                self._values["id"] = id
            if match_criteria is not None:
                self._values["match_criteria"] = match_criteria

        @builtins.property
        def id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: id: The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
            '''
            result = self._values.get("id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def match_criteria(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            matchCriteria: The type of the private pool that you want to use to start ECS instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool to create ECS instances. Valid values:

            - **Open**: open private pool. Auto Scaling selects a matching open private pool to start instances. If no matching open private pools are found, Auto Scaling uses the resources in the public pool to start instances. In this case, you do not need to specify PrivatePoolOptions.Id.
            Target: specified private pool. Auto Scaling uses the resources in the specified private pool to start ECS instances. If the specified private pool is unavailable, Auto Scaling cannot start ECS instances. If you set this parameter to Target, you must specify PrivatePoolOptions.Id.
            - **None**: no private pool. Auto Scaling does not use the resources in private pools to start ECS instances.
            '''
            result = self._values.get("match_criteria")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivatePoolOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingConfiguration.TagListProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagListProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7fc9909d468266827c82c3c6fd1c807046dd022f01a8aca3c828f004e50bae89)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagListProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosScalingConfigurationProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "affinity": "affinity",
        "cpu": "cpu",
        "credit_specification": "creditSpecification",
        "dedicated_host_id": "dedicatedHostId",
        "deployment_set_id": "deploymentSetId",
        "disk_mappings": "diskMappings",
        "host_name": "hostName",
        "hpc_cluster_id": "hpcClusterId",
        "image_family": "imageFamily",
        "image_id": "imageId",
        "image_name": "imageName",
        "image_options_login_as_non_root": "imageOptionsLoginAsNonRoot",
        "instance_description": "instanceDescription",
        "instance_id": "instanceId",
        "instance_name": "instanceName",
        "instance_pattern_infos": "instancePatternInfos",
        "instance_type": "instanceType",
        "instance_type_overrides": "instanceTypeOverrides",
        "instance_types": "instanceTypes",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "ipv6_address_count": "ipv6AddressCount",
        "key_pair_name": "keyPairName",
        "load_balancer_weight": "loadBalancerWeight",
        "memory": "memory",
        "password": "password",
        "password_inherit": "passwordInherit",
        "private_pool_options": "privatePoolOptions",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "scaling_configuration_name": "scalingConfigurationName",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
        "spot_duration": "spotDuration",
        "spot_interruption_behavior": "spotInterruptionBehavior",
        "spot_price_limit": "spotPriceLimit",
        "spot_price_limit_for_instance_type": "spotPriceLimitForInstanceType",
        "spot_strategy": "spotStrategy",
        "system_disk_auto_snapshot_policy_id": "systemDiskAutoSnapshotPolicyId",
        "system_disk_bursting_enabled": "systemDiskBurstingEnabled",
        "system_disk_categories": "systemDiskCategories",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_encrypt_algorithm": "systemDiskEncryptAlgorithm",
        "system_disk_encrypted": "systemDiskEncrypted",
        "system_disk_kms_key_id": "systemDiskKmsKeyId",
        "system_disk_performance_level": "systemDiskPerformanceLevel",
        "system_disk_provisioned_iops": "systemDiskProvisionedIops",
        "system_disk_size": "systemDiskSize",
        "tag_list": "tagList",
        "tenancy": "tenancy",
        "user_data": "userData",
        "zone_id": "zoneId",
    },
)
class RosScalingConfigurationProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        affinity: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        credit_specification: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        dedicated_host_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deployment_set_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        disk_mappings: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.DiskMappingsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        host_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        hpc_cluster_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_family: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_options_login_as_non_root: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_pattern_infos: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.InstancePatternInfosProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_type_overrides: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.InstanceTypeOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_max_bandwidth_in: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_max_bandwidth_out: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        io_optimized: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ipv6_address_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        key_pair_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        load_balancer_weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        password: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        private_pool_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.PrivatePoolOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ram_role_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_configuration_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_enhancement_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_group_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        spot_duration: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_interruption_behavior: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_price_limit_for_instance_type: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]] = None,
        spot_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_auto_snapshot_policy_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_categories: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        system_disk_category: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_disk_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_encrypt_algorithm: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_encrypted: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_kms_key_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_performance_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tag_list: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.TagListProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tenancy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        user_data: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        zone_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosScalingConfiguration``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalingconfiguration

        :param scaling_group_id: 
        :param affinity: 
        :param cpu: 
        :param credit_specification: 
        :param dedicated_host_id: 
        :param deployment_set_id: 
        :param disk_mappings: 
        :param host_name: 
        :param hpc_cluster_id: 
        :param image_family: 
        :param image_id: 
        :param image_name: 
        :param image_options_login_as_non_root: 
        :param instance_description: 
        :param instance_id: 
        :param instance_name: 
        :param instance_pattern_infos: 
        :param instance_type: 
        :param instance_type_overrides: 
        :param instance_types: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param ipv6_address_count: 
        :param key_pair_name: 
        :param load_balancer_weight: 
        :param memory: 
        :param password: 
        :param password_inherit: 
        :param private_pool_options: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param scaling_configuration_name: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param security_group_ids: 
        :param spot_duration: 
        :param spot_interruption_behavior: 
        :param spot_price_limit: 
        :param spot_price_limit_for_instance_type: 
        :param spot_strategy: 
        :param system_disk_auto_snapshot_policy_id: 
        :param system_disk_bursting_enabled: 
        :param system_disk_categories: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_encrypt_algorithm: 
        :param system_disk_encrypted: 
        :param system_disk_kms_key_id: 
        :param system_disk_performance_level: 
        :param system_disk_provisioned_iops: 
        :param system_disk_size: 
        :param tag_list: 
        :param tenancy: 
        :param user_data: 
        :param zone_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__905bee6bae5d29de4a63d35773e0cffe2dc5253364ba66148204dae2c1fce9fb)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            check_type(argname="argument credit_specification", value=credit_specification, expected_type=type_hints["credit_specification"])
            check_type(argname="argument dedicated_host_id", value=dedicated_host_id, expected_type=type_hints["dedicated_host_id"])
            check_type(argname="argument deployment_set_id", value=deployment_set_id, expected_type=type_hints["deployment_set_id"])
            check_type(argname="argument disk_mappings", value=disk_mappings, expected_type=type_hints["disk_mappings"])
            check_type(argname="argument host_name", value=host_name, expected_type=type_hints["host_name"])
            check_type(argname="argument hpc_cluster_id", value=hpc_cluster_id, expected_type=type_hints["hpc_cluster_id"])
            check_type(argname="argument image_family", value=image_family, expected_type=type_hints["image_family"])
            check_type(argname="argument image_id", value=image_id, expected_type=type_hints["image_id"])
            check_type(argname="argument image_name", value=image_name, expected_type=type_hints["image_name"])
            check_type(argname="argument image_options_login_as_non_root", value=image_options_login_as_non_root, expected_type=type_hints["image_options_login_as_non_root"])
            check_type(argname="argument instance_description", value=instance_description, expected_type=type_hints["instance_description"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument instance_name", value=instance_name, expected_type=type_hints["instance_name"])
            check_type(argname="argument instance_pattern_infos", value=instance_pattern_infos, expected_type=type_hints["instance_pattern_infos"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument instance_type_overrides", value=instance_type_overrides, expected_type=type_hints["instance_type_overrides"])
            check_type(argname="argument instance_types", value=instance_types, expected_type=type_hints["instance_types"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument internet_max_bandwidth_in", value=internet_max_bandwidth_in, expected_type=type_hints["internet_max_bandwidth_in"])
            check_type(argname="argument internet_max_bandwidth_out", value=internet_max_bandwidth_out, expected_type=type_hints["internet_max_bandwidth_out"])
            check_type(argname="argument io_optimized", value=io_optimized, expected_type=type_hints["io_optimized"])
            check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
            check_type(argname="argument key_pair_name", value=key_pair_name, expected_type=type_hints["key_pair_name"])
            check_type(argname="argument load_balancer_weight", value=load_balancer_weight, expected_type=type_hints["load_balancer_weight"])
            check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument password_inherit", value=password_inherit, expected_type=type_hints["password_inherit"])
            check_type(argname="argument private_pool_options", value=private_pool_options, expected_type=type_hints["private_pool_options"])
            check_type(argname="argument ram_role_name", value=ram_role_name, expected_type=type_hints["ram_role_name"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument scaling_configuration_name", value=scaling_configuration_name, expected_type=type_hints["scaling_configuration_name"])
            check_type(argname="argument security_enhancement_strategy", value=security_enhancement_strategy, expected_type=type_hints["security_enhancement_strategy"])
            check_type(argname="argument security_group_id", value=security_group_id, expected_type=type_hints["security_group_id"])
            check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
            check_type(argname="argument spot_duration", value=spot_duration, expected_type=type_hints["spot_duration"])
            check_type(argname="argument spot_interruption_behavior", value=spot_interruption_behavior, expected_type=type_hints["spot_interruption_behavior"])
            check_type(argname="argument spot_price_limit", value=spot_price_limit, expected_type=type_hints["spot_price_limit"])
            check_type(argname="argument spot_price_limit_for_instance_type", value=spot_price_limit_for_instance_type, expected_type=type_hints["spot_price_limit_for_instance_type"])
            check_type(argname="argument spot_strategy", value=spot_strategy, expected_type=type_hints["spot_strategy"])
            check_type(argname="argument system_disk_auto_snapshot_policy_id", value=system_disk_auto_snapshot_policy_id, expected_type=type_hints["system_disk_auto_snapshot_policy_id"])
            check_type(argname="argument system_disk_bursting_enabled", value=system_disk_bursting_enabled, expected_type=type_hints["system_disk_bursting_enabled"])
            check_type(argname="argument system_disk_categories", value=system_disk_categories, expected_type=type_hints["system_disk_categories"])
            check_type(argname="argument system_disk_category", value=system_disk_category, expected_type=type_hints["system_disk_category"])
            check_type(argname="argument system_disk_description", value=system_disk_description, expected_type=type_hints["system_disk_description"])
            check_type(argname="argument system_disk_disk_name", value=system_disk_disk_name, expected_type=type_hints["system_disk_disk_name"])
            check_type(argname="argument system_disk_encrypt_algorithm", value=system_disk_encrypt_algorithm, expected_type=type_hints["system_disk_encrypt_algorithm"])
            check_type(argname="argument system_disk_encrypted", value=system_disk_encrypted, expected_type=type_hints["system_disk_encrypted"])
            check_type(argname="argument system_disk_kms_key_id", value=system_disk_kms_key_id, expected_type=type_hints["system_disk_kms_key_id"])
            check_type(argname="argument system_disk_performance_level", value=system_disk_performance_level, expected_type=type_hints["system_disk_performance_level"])
            check_type(argname="argument system_disk_provisioned_iops", value=system_disk_provisioned_iops, expected_type=type_hints["system_disk_provisioned_iops"])
            check_type(argname="argument system_disk_size", value=system_disk_size, expected_type=type_hints["system_disk_size"])
            check_type(argname="argument tag_list", value=tag_list, expected_type=type_hints["tag_list"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user_data", value=user_data, expected_type=type_hints["user_data"])
            check_type(argname="argument zone_id", value=zone_id, expected_type=type_hints["zone_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
        }
        if affinity is not None:
            self._values["affinity"] = affinity
        if cpu is not None:
            self._values["cpu"] = cpu
        if credit_specification is not None:
            self._values["credit_specification"] = credit_specification
        if dedicated_host_id is not None:
            self._values["dedicated_host_id"] = dedicated_host_id
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if image_family is not None:
            self._values["image_family"] = image_family
        if image_id is not None:
            self._values["image_id"] = image_id
        if image_name is not None:
            self._values["image_name"] = image_name
        if image_options_login_as_non_root is not None:
            self._values["image_options_login_as_non_root"] = image_options_login_as_non_root
        if instance_description is not None:
            self._values["instance_description"] = instance_description
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if instance_pattern_infos is not None:
            self._values["instance_pattern_infos"] = instance_pattern_infos
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if instance_type_overrides is not None:
            self._values["instance_type_overrides"] = instance_type_overrides
        if instance_types is not None:
            self._values["instance_types"] = instance_types
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if load_balancer_weight is not None:
            self._values["load_balancer_weight"] = load_balancer_weight
        if memory is not None:
            self._values["memory"] = memory
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if private_pool_options is not None:
            self._values["private_pool_options"] = private_pool_options
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if scaling_configuration_name is not None:
            self._values["scaling_configuration_name"] = scaling_configuration_name
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if spot_duration is not None:
            self._values["spot_duration"] = spot_duration
        if spot_interruption_behavior is not None:
            self._values["spot_interruption_behavior"] = spot_interruption_behavior
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_price_limit_for_instance_type is not None:
            self._values["spot_price_limit_for_instance_type"] = spot_price_limit_for_instance_type
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_auto_snapshot_policy_id is not None:
            self._values["system_disk_auto_snapshot_policy_id"] = system_disk_auto_snapshot_policy_id
        if system_disk_bursting_enabled is not None:
            self._values["system_disk_bursting_enabled"] = system_disk_bursting_enabled
        if system_disk_categories is not None:
            self._values["system_disk_categories"] = system_disk_categories
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_encrypt_algorithm is not None:
            self._values["system_disk_encrypt_algorithm"] = system_disk_encrypt_algorithm
        if system_disk_encrypted is not None:
            self._values["system_disk_encrypted"] = system_disk_encrypted
        if system_disk_kms_key_id is not None:
            self._values["system_disk_kms_key_id"] = system_disk_kms_key_id
        if system_disk_performance_level is not None:
            self._values["system_disk_performance_level"] = system_disk_performance_level
        if system_disk_provisioned_iops is not None:
            self._values["system_disk_provisioned_iops"] = system_disk_provisioned_iops
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tag_list is not None:
            self._values["tag_list"] = tag_list
        if tenancy is not None:
            self._values["tenancy"] = tenancy
        if user_data is not None:
            self._values["user_data"] = user_data
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: Scaling group id to create the scaling configuration.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def affinity(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        affinity: Specifies whether to associate an ECS instance on a dedicated host with the dedicated host. Valid values:

        - **default**: does not associate the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode and the original dedicated host has insufficient resources, the ECS instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
        - **host**: associates the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the ECS instance fails to start.
        Default value: **default**
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cpu(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        cpu: The number of vCPUs.
        You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set CPU to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
        **Note**: You can specify **Cpu** and **Memory** to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def credit_specification(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        creditSpecification: The performance mode of the burstable instance. Valid values:
        Standard: the standard mode.
        Unlimited: the unlimited mode.
        '''
        result = self._values.get("credit_specification")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def dedicated_host_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dedicatedHostId: The ID of the dedicated host on which you want to create an ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify **DedicatedHostId**, **SpotStrategy** and **SpotPriceLimit** are ignored.
        You can call the **DescribeDedicatedHosts** operation to query dedicated host IDs.
        '''
        result = self._values.get("dedicated_host_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deployment_set_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: deploymentSetId: Deployment set ID.
        '''
        result = self._values.get("deployment_set_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.DiskMappingsProperty]]]]:
        '''
        :Property: diskMappings: Disk mappings to attach to instance.
        '''
        result = self._values.get("disk_mappings")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.DiskMappingsProperty]]]], result)

    @builtins.property
    def host_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        hostName: The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
        Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
        Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        '''
        result = self._values.get("host_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def hpc_cluster_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.
        '''
        result = self._values.get("hpc_cluster_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_family(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: imageFamily: The name of the image family. You can configure this parameter to obtain the latest available images within the specified image family. The images are used to create ECS instances. If you have set the ImageId parameter, you cannot set the ImageFamily parameter.
        '''
        result = self._values.get("image_family")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: imageId: Image ID to create ecs instance .
        '''
        result = self._values.get("image_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        imageName: The name of the image. Each image name must be unique in a region. If you specify **ImageId**, **ImageName** is ignored.
        You cannot use **ImageName** to specify images that are purchased from Alibaba Cloud Marketplace.
        '''
        result = self._values.get("image_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_options_login_as_non_root(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        imageOptionsLoginAsNonRoot: Whether the ecs instance is logged in as ecs-user.Valid values:

        - **true**
        - **false**
        Default value: **false**.
        '''
        result = self._values.get("image_options_login_as_non_root")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceDescription: The description of the ECS instance. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with http:// or https://.
        '''
        result = self._values.get("instance_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceId: Source ECS instance to copy configuration, if the properties is setting, Which will copy the InstanceType, ImageId, InternetChargeType, IoOptimized,UserData, KeyPairName, RamRoleName, InternetMaxBandwidthIn,InternetMaxBandwidthOut, and first security group id from source instance, you can also specify the relative properties to overwrite the properties copy from source instance id.
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceName: The name of the instance launched from the current scaling configuration.
        '''
        result = self._values.get("instance_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_pattern_infos(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstancePatternInfosProperty]]]]:
        '''
        :Property: instancePatternInfos: Details of the intelligent configuration settings that determine the range of instance types that meet the specified criteria.
        '''
        result = self._values.get("instance_pattern_infos")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstancePatternInfosProperty]]]], result)

    @builtins.property
    def instance_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceType: ecs supported instance type.
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_type_overrides(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstanceTypeOverridesProperty]]]]:
        '''
        :Property: instanceTypeOverrides: The instance types.
        '''
        result = self._values.get("instance_type_overrides")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstanceTypeOverridesProperty]]]], result)

    @builtins.property
    def instance_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: instanceTypes: ecs supported instance types. Length [1,10]. If InstanceTypes is specified,the InstanceType will be ignored.
        '''
        result = self._values.get("instance_types")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_max_bandwidth_in(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetMaxBandwidthIn: Maximum incoming bandwidth from the public network, measured in Mbps (Mega bit per second). The value range is [1,200]. If this parameter value is not specified, AliyunAPI automatically sets the value to 200 Mbps.
        '''
        result = self._values.get("internet_max_bandwidth_in")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_max_bandwidth_out(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetMaxBandwidthOut: Maximum outgoing bandwidth from the public network, measured in Mbps (Mega bit per second).
        The value range for PayByBandwidth is [0,100]. If this parameter value is not specified, AliyunAPI automatically sets the value to 0 Mbps.
        The value range for PayByTraffic is [0,100]. If this parameter value is not specified, an error is reported
        '''
        result = self._values.get("internet_max_bandwidth_out")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def io_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'none'.
        '''
        result = self._values.get("io_optimized")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ipv6_address_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipv6AddressCount: The number of randomly generated IPv6 addresses to be assigned to the elastic network interface (ENI).
        '''
        result = self._values.get("ipv6_address_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def key_pair_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: keyPairName: SSH key pair name.
        '''
        result = self._values.get("key_pair_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def load_balancer_weight(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        loadBalancerWeight: The weight of the ECS instance as a backend server. Valid values: 1 to 100.
        Default value: 50.
        '''
        result = self._values.get("load_balancer_weight")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def memory(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        memory: The memory size. Unit: GiB.
        You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
        **Note**: You can specify **Cpu** and **Memory** to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
        '''
        result = self._values.get("memory")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def password(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: passwordInherit: Whether to use the password pre-configured in the image you select or not. When PasswordInherit is specified, the Password must be null. For a secure access, make sure that the selected image has password configured.
        '''
        result = self._values.get("password_inherit")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def private_pool_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.PrivatePoolOptionsProperty]]:
        '''
        :Property: privatePoolOptions: Option settings for private pools
        '''
        result = self._values.get("private_pool_options")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.PrivatePoolOptionsProperty]], result)

    @builtins.property
    def ram_role_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        '''
        result = self._values.get("ram_role_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: Resource group id.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_configuration_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: scalingConfigurationName: Name of created scaling configuration.
        '''
        result = self._values.get("scaling_configuration_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_enhancement_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        securityEnhancementStrategy: Specifies whether to enable security hardening. Valid values:

        - **Active**: enables security hardening. This value is applicable only to public images.
        - **Deactive**: disables security hardening. This value is applicable to all image types.
        '''
        result = self._values.get("security_enhancement_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: securityGroupId: Security Group to create ecs instance.
        '''
        result = self._values.get("security_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        securityGroupIds: The IDs of the security groups with which you want to associate the ECS instances that are created by using the scaling configuration.
        **Note**: If you specify **SecurityGroupId**, you cannot specify **SecurityGroupIds**.
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def spot_duration(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotDuration: The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
        If you set this parameter to 0, no protection period is specified for the preemptible instance.
        Default value: 1
        '''
        result = self._values.get("spot_duration")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_interruption_behavior(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: spotInterruptionBehavior: The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate. This value specifies that the preemptible instance is to be released.
        '''
        result = self._values.get("spot_interruption_behavior")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_price_limit(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: spotPriceLimit: Set the hourly maximum price for the instance. Supports a maximum of 3 decimal places, and the parameter takes effect only when the value of SpotStrategy is SpotWithPriceLimit.It is a default value for all instance types, and can be overwrite by SpotPriceLimitForInstanceType
        '''
        result = self._values.get("spot_price_limit")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_price_limit_for_instance_type(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        '''
        :Property:

        spotPriceLimitForInstanceType: Set the hourly maximum price for the instance of specified instance type.
        The parameter takes effect only when the value of SpotStrategy is SpotWithPriceLimit.
        You should input the information of the tag with the format of the Key-Value, such as {"key1":"value1","key2":"value2", ... "key5":"value5"}.
        At most 50 items can be specified.
        Key
        ecs instance type
        Value
        Supports a maximum of 3 decimal places.
        '''
        result = self._values.get("spot_price_limit_for_instance_type")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]], result)

    @builtins.property
    def spot_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotStrategy: Preemption strategy for post-paid instances. It takes effect when the parameter InstanceChargeType takes the value of PostPaid. Ranges:
        NoSpot: Normal pay-per-use instance
        SpotWithPriceLimit: Set a preemptive instance of the cap price
        SpotAsPriceGo: System automatic bidding, following the current market actual price
        Default: NoSpot.
        '''
        result = self._values.get("spot_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_auto_snapshot_policy_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        '''
        result = self._values.get("system_disk_auto_snapshot_policy_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_bursting_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        systemDiskBurstingEnabled: Specifies whether to enable the burst feature for the system disk. Valid values:

        - **true**
        - **false**
        **Note**: This parameter is available only if you set **SystemDiskCategory** to **cloud_auto**.
        '''
        result = self._values.get("system_disk_bursting_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_categories(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        systemDiskCategories: The categories of the system disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:

        - **cloud**: basic disk
        - **cloud_efficiency**: ultra disk
        - **cloud_ssd**: standard SSD
        - **cloud_essd**: ESSD
        **Note**: If you specify **SystemDiskCategories**, you cannot specify **SystemDiskCategory**.
        '''
        result = self._values.get("system_disk_categories")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def system_disk_category(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskCategory: Category of system disk. Default is cloud.support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd|cloud_auto
        '''
        result = self._values.get("system_disk_category")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskDescription: The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with http:// or https://.
        '''
        result = self._values.get("system_disk_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_disk_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskDiskName: The name of the system disk. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        '''
        result = self._values.get("system_disk_disk_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_encrypt_algorithm(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        systemDiskEncryptAlgorithm: The encryption algorithm that you want to use to encrypt the system disk. Valid values:

        - **AES-256**
        - **SM4-128**
        Default value: **AES-256**
        '''
        result = self._values.get("system_disk_encrypt_algorithm")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        systemDiskEncrypted: Specifies whether to encrypt the system disk. Valid values:

        - **true**
        - **false**
        Default value: **false**
        '''
        result = self._values.get("system_disk_encrypted")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_kms_key_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskKmsKeyId: The ID of the KMS key that you want to use to encrypt the system disk.
        '''
        result = self._values.get("system_disk_kms_key_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_performance_level(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskPerformanceLevel: The performance level of an ESSD.
        '''
        result = self._values.get("system_disk_performance_level")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_provisioned_iops(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        systemDiskProvisionedIops: The IOPS metric that is preconfigured for the system disk.
        **Note**: IOPS measures the number of read and write operations that an EBS device can process per second.
        '''
        result = self._values.get("system_disk_provisioned_iops")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_size(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: systemDiskSize: Size of system disk. Unit is GB.
        '''
        result = self._values.get("system_disk_size")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tag_list(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.TagListProperty]]]]:
        '''
        :Property:

        tagList: The tags of an instance in list format.
        Do not use with Tags at the same time.
        You should input the information of the tag with the format of Key-Value list, such as [{"Key":"key1","Value":"value1"}, ...].
        At most 20 tags can be specified.
        Key
        It can be up to 64 characters in length.
        Cannot begin with aliyun.
        Cannot begin with http:// or https://.
        Cannot be a null string.
        Value
        It can be up to 128 characters in length.
        Cannot begin with aliyun.
        Cannot begin with http:// or https://.
        Can be a null string.If less then 20 tags are specified, ros will add a tag(Key: "ros-aliyun-created", Value:"<resource_name>*stack*<stack_id>") if possible.
        '''
        result = self._values.get("tag_list")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.TagListProperty]]]], result)

    @builtins.property
    def tenancy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        tenancy: Specifies whether to create an ECS instance on a dedicated host. Valid values:

        - **default**: does not create an ECS instance on a dedicated host.
        - **host**: creates an ECS instance on a dedicated host. If you do not specify **DedicatedHostId**, Alibaba Cloud selects a dedicated host for the ECS instance.
        Default value: **default**
        '''
        result = self._values.get("tenancy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def user_data(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def zone_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: zoneId: The zone ID of the ECS instance.
        '''
        result = self._values.get("zone_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosScalingConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosScalingGroup(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosScalingGroup",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::ScalingGroup``, which is used to create a scaling group.

    A scaling group is a group of Elastic Compute Service (ECS) instances that are dynamically scaled based on the configured scenario. A scaling group does not immediately take effect after it is created. You must use ALIYUN::ESS::ScalingGroupEnable to enable the scaling group to trigger scaling activities and execute scaling rules.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``ScalingGroup`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalinggroup
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosScalingGroupProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfa8b82548057b4e9d5f9c6bd95ae16437c0db8d85167b967047184a24f0a34b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7398d701f1411574f7cd0f34f85c5290dd37a39695ad3d0ea3df46c073c00358)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingGroupId: Scaling group Id
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupName")
    def attr_scaling_group_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingGroupName: Scaling group name
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupName"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae7fa6593d4f0ea468c6cc425c55de188d9e0de2cd943d4dc09b0bb61700d2fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="maxSize")
    def max_size(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: maxSize: Maximum number of ECS instances in the scaling group. Value range: [0, 2000].
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "maxSize"))

    @max_size.setter
    def max_size(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__259d3ba494d0f568e0bece082a54d68311b0fe3761742166fd72c7a0cbc8c618)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxSize", value)

    @builtins.property
    @jsii.member(jsii_name="minSize")
    def min_size(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: minSize: Minimum number of ECS instances in the scaling group. Value range: [0, 2000].
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "minSize"))

    @min_size.setter
    def min_size(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a856925e6a009a3cc49de033c3276063254e99fdc4199f22d9b0d27a2fb739e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minSize", value)

    @builtins.property
    @jsii.member(jsii_name="allocationStrategy")
    def allocation_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        allocationStrategy: The allocation policy of instances. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - priority: Auto Scaling selects instance types based on the specified order to create the required number of instances.
        - lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.
        Default value: priority.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "allocationStrategy"))

    @allocation_strategy.setter
    def allocation_strategy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f226b1c92924883009e3639ee437d170ccc1c2c061a413d4db9deadf6f60a0ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allocationStrategy", value)

    @builtins.property
    @jsii.member(jsii_name="azBalance")
    def az_balance(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        azBalance: Specifies whether to evenly distribute instances in the scaling group across multiple zones. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - true
        - false
        Default value: false.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "azBalance"))

    @az_balance.setter
    def az_balance(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__325e4b22ada2192ccdfc2e79847ec39620e7ec6e2c09019df52bca25dc34af61)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "azBalance", value)

    @builtins.property
    @jsii.member(jsii_name="compensateWithOnDemand")
    def compensate_with_on_demand(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        compensateWithOnDemand: Specifies whether to automatically create pay-as-you-go instances to meet the requirements on the number of instances when the expected capacity of preemptible instances cannot be fulfilled due to reasons such as high prices or insufficient resources. This parameter takes effect only when MultiAZPolicy is set to COST_OPTIMIZED.
        Default value: true.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "compensateWithOnDemand"))

    @compensate_with_on_demand.setter
    def compensate_with_on_demand(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__622e769201dfa85f491249382aa53de1745e68a31d350f7c47449add7de8d6aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "compensateWithOnDemand", value)

    @builtins.property
    @jsii.member(jsii_name="containerGroupId")
    def container_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: containerGroupId: The ID of the elastic container instance.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "containerGroupId"))

    @container_group_id.setter
    def container_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba6e0b53d0a7502850e4c9644d38a94b48668220098ada358e96431b9276ed1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "containerGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="customPolicyArn")
    def custom_policy_arn(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: customPolicyArn: The Alibaba Cloud Resource Name (ARN) of the custom scale-in policy (Function). This parameter takes effect only if you specify CustomPolicy as the value of first item of RemovalPolicys.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "customPolicyArn"))

    @custom_policy_arn.setter
    def custom_policy_arn(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52a9680bc4c0d1237fd88fef783c5f1711f8a59d6a6dfe9eec287146d5c606e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "customPolicyArn", value)

    @builtins.property
    @jsii.member(jsii_name="dbInstanceIds")
    def db_instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: dbInstanceIds: ID list of an RDS instance. A Json Array with format: [ "rm-id0", "rm-id1", ... "rm-idz" ], support up to 100 RDS instance.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "dbInstanceIds"))

    @db_instance_ids.setter
    def db_instance_ids(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a30f6746f533d8bfd535369285272c733415eb661498aab045acd6bfe09822b7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbInstanceIds", value)

    @builtins.property
    @jsii.member(jsii_name="defaultCooldown")
    def default_cooldown(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        defaultCooldown: Default cool-down time (in seconds) of the scaling group. Value range: [0, 86400].
        The default value is 300s.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "defaultCooldown"))

    @default_cooldown.setter
    def default_cooldown(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6f937972608ea2d4024eeed7b11364fec06288f2c7fdf5b2309c67078fe1c51)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "defaultCooldown", value)

    @builtins.property
    @jsii.member(jsii_name="desiredCapacity")
    def desired_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: desiredCapacity: The expected number of ECS instances in a scaling group. The scaling group automatically keeps the number of ECS instances as expected. The number of ECS instances cannot be greater than the value of MaxSize and cannot be less than the value of MinSize.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "desiredCapacity"))

    @desired_capacity.setter
    def desired_capacity(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4d5eb01602656e907db7fa24e08bbef91d742852c9a2e7fbf3b985b5b6a5721)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "desiredCapacity", value)

    @builtins.property
    @jsii.member(jsii_name="groupDeletionProtection")
    def group_deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        groupDeletionProtection: Whether to enable deletion protection for scaling group.
        Default to False.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "groupDeletionProtection"))

    @group_deletion_protection.setter
    def group_deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2400a8e87ed65ba3de3bf8c4a801684544c22766a78437b98ac93a630feb9eea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "groupDeletionProtection", value)

    @builtins.property
    @jsii.member(jsii_name="groupType")
    def group_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        groupType: The type of instances that are managed by the scaling group. Valid values:
        ECS
        ECI
        Default value: ECS.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "groupType"))

    @group_type.setter
    def group_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20e1ecf3ca71846d8209c14231525cd5c8634b6c8a11e18fcb393324775400a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "groupType", value)

    @builtins.property
    @jsii.member(jsii_name="healthCheckType")
    def health_check_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: healthCheckType: The health check type. Allow values is "ECS" and "NONE", default to "ECS".
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "healthCheckType"))

    @health_check_type.setter
    def health_check_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39253d0e28ca008795d0e03f22a05e9eb793a226848740b2c8c93a87f40b002f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "healthCheckType", value)

    @builtins.property
    @jsii.member(jsii_name="instanceId")
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceId: The ID of the ECS instance from which the scaling group obtains configuration information of the specified instance.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abd6d54f88a291134c2ab9e40c41139ef3fe50d4c4a0725117908c4194e784d7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceId", value)

    @builtins.property
    @jsii.member(jsii_name="launchTemplateId")
    def launch_template_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: launchTemplateId: The ID of the instance launch template from which the scaling group obtains launch configurations.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "launchTemplateId"))

    @launch_template_id.setter
    def launch_template_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39df13437fa9d0f777138c254bbfdf5e177b9c7567289c0238c53d80f3baf93d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "launchTemplateId", value)

    @builtins.property
    @jsii.member(jsii_name="launchTemplateOverrides")
    def launch_template_overrides(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.LaunchTemplateOverridesProperty"]]]]:
        '''
        :Property:

        launchTemplateOverrides: You can specify up to 10 overrides.
        Note: This parameter takes effect only if you specify LaunchTemplateId.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.LaunchTemplateOverridesProperty"]]]], jsii.get(self, "launchTemplateOverrides"))

    @launch_template_overrides.setter
    def launch_template_overrides(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.LaunchTemplateOverridesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e933e92bb09e7b956484ae54909f8983cee5dad4075a0f1dc6ad7a77639bbb9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "launchTemplateOverrides", value)

    @builtins.property
    @jsii.member(jsii_name="launchTemplateVersion")
    def launch_template_version(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        launchTemplateVersion: The version of the instance launch template. Valid values:
        A fixed template version numbe.
        Default: The default template version is always used.
        Latest: The latest template version is always used.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "launchTemplateVersion"))

    @launch_template_version.setter
    def launch_template_version(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a7c9656e1d9d041f0b9dccaa5f9c4490acce3611b5eb453537598aac85b0046)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "launchTemplateVersion", value)

    @builtins.property
    @jsii.member(jsii_name="loadBalancerIds")
    def load_balancer_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: loadBalancerIds: ID list of a Server Load Balancer instance. A Json Array with format: [ "lb-id0", "lb-id1", ... "lb-idz" ], support up to 100 Load Balancer instance.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "loadBalancerIds"))

    @load_balancer_ids.setter
    def load_balancer_ids(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54a6b0c08e5cbb1033dd2411ccb79487a9b3b0454c38a47d1dbc63776b46187a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loadBalancerIds", value)

    @builtins.property
    @jsii.member(jsii_name="maxInstanceLifetime")
    def max_instance_lifetime(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        maxInstanceLifetime: The maximum life span of an ECS instance in the scaling group. Unit: seconds.
        Valid values: 86400 to the value of Integer.maxValue.
        Default value: null.
        Note: This parameter is unavailable for scaling groups of the ECI type or scaling groups whose ScalingPolicy is set to recycle.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "maxInstanceLifetime"))

    @max_instance_lifetime.setter
    def max_instance_lifetime(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3e6ab024fdd04e2f2be22cd7a1a34b359b86ff5bf23407c63c47d6dcaaca740)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxInstanceLifetime", value)

    @builtins.property
    @jsii.member(jsii_name="multiAzPolicy")
    def multi_az_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        multiAzPolicy: ECS scaling strategy for multi availability zone. Allow value:

        1. PRIORITY: scaling the capacity according to the virtual switch (VSwitchIds.N) you define. ECS instances are automatically created using the next priority virtual switch when the higher priority virtual switch cannot be created in the available zone.
        2. BALANCE: evenly allocate ECS instances between the multiple available zone specified by the scaling group.
        3. COST_OPTIMIZED: During a scale-out activity, Auto Scaling attempts to create ECS instances that have vCPUs provided at the lowest price. During a scale-in activity, Auto Scaling attempts to remove ECS instances that have vCPUs provided at the highest price. Preemptible instances are preferentially created when preemptible instance types are specified in the active scaling configuration. You can configure the CompensateWithOnDemand parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.
        Note COST_OPTIMIZED is valid when multiple instance types are specified or at least one preemptible instance type is specified.
        4. COMPOSABLE: You can flexibly combine the preceding policies based on your business requirements.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "multiAzPolicy"))

    @multi_az_policy.setter
    def multi_az_policy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0aeb879a5358ae247001507514d85e74668f2fbf068b939a223caf731f19d8fd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "multiAzPolicy", value)

    @builtins.property
    @jsii.member(jsii_name="notificationConfigurations")
    def notification_configurations(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.NotificationConfigurationsProperty"]]]]:
        '''
        :Property: notificationConfigurations: When a scaling event occurs in a scaling group, ESS will send a notification to Cloud Monitor or MNS.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.NotificationConfigurationsProperty"]]]], jsii.get(self, "notificationConfigurations"))

    @notification_configurations.setter
    def notification_configurations(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.NotificationConfigurationsProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a780f6d8e00e2de9fe9587c2335da4daed205a167b2778888fc9cba167ef7af)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "notificationConfigurations", value)

    @builtins.property
    @jsii.member(jsii_name="onDemandBaseCapacity")
    def on_demand_base_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        onDemandBaseCapacity: The minimum number of pay-as-you-go instances required in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.
        If you set MultiAZPolicy to COMPOSABLE Policy, the default value of this parameter is 0.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "onDemandBaseCapacity"))

    @on_demand_base_capacity.setter
    def on_demand_base_capacity(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__677d6daacd8b880640a37b24380ed5f265f12a7686e4031c18876a953b4c5fdc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "onDemandBaseCapacity", value)

    @builtins.property
    @jsii.member(jsii_name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        onDemandPercentageAboveBaseCapacity: The percentage of pay-as-you-go instances that can be created when instances are added to the scaling group. This parameter takes effect when the number of pay-as-you-go instances reaches the value for the OnDemandBaseCapacity parameter. Valid values: 0 to 100.
        If you set MultiAZPolicy to COMPOSABLE, the default value of this parameter is 100.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "onDemandPercentageAboveBaseCapacity"))

    @on_demand_percentage_above_base_capacity.setter
    def on_demand_percentage_above_base_capacity(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a47bff9878f440174c1d06ffe17ef4e291f072f8691c8f1745288f50fd2a7d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "onDemandPercentageAboveBaseCapacity", value)

    @builtins.property
    @jsii.member(jsii_name="protectedInstances")
    def protected_instances(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: protectedInstances: ECS instances of protected mode in the scaling group.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "protectedInstances"))

    @protected_instances.setter
    def protected_instances(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ba23d4f1b1b13986485448c4865c1d362996e81ee96cc8d218fb89f43a55a96)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "protectedInstances", value)

    @builtins.property
    @jsii.member(jsii_name="removalPolicys")
    def removal_policys(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        removalPolicys: Policy for removing ECS instances from the scaling group.
        Optional values:

        - OldestInstance: removes the first ECS instance attached to the scaling group.
        - NewestInstance: removes the first ECS instance attached to the scaling group.
        - OldestScalingConfiguration: removes the ECS instance with the oldest scaling configuration.
        - CustomPolicy: removes ECS instances based on the custom scale-in policy (Function).
        You can enter up to three removal policies.
        You cannot set any item of RemovalPolicys to the same value.
        The scaling configuration source specified by the OldestScalingConfiguration setting can be a scaling configuration or a launch template. You can specify CustomPolicy only as the value of first item of RemovalPolicys. If you set first item of RemovalPolicys to CustomPolicy, you must also specify CustomPolicyARN.
        Note: The removal of ECS instances from a scaling group is also affected by the value of MultiAZPolicy.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "removalPolicys"))

    @removal_policys.setter
    def removal_policys(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb1ae7bf69ce03ecdbf38049030bd93a03fe9edd6fe96d4bfce1e2e93b9f7437)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "removalPolicys", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: Resource group id.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b04f8536f9d951f05ffcdd0fe60f1b97b5774a1feb54191c907648f114226377)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupName")
    def scaling_group_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scalingGroupName: Name shown for the scaling group, which must contain 2-40 characters (English or Chinese). The name must begin with a number, an upper/lower-case letter or a Chinese character and may contain numbers, "_", "-" or ".". The account name is unique in the same region.
        If this parameter is not specified, the default value is ScalingGroupId.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scalingGroupName"))

    @scaling_group_name.setter
    def scaling_group_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bea7851a0061153bcc143cb3c742b3a13f0f5cd4b7f09d3a120a41418304e4bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="scalingPolicy")
    def scaling_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scalingPolicy: The reclaim mode of the scaling group. Valid values:
        recycle
        release
        forcerelease
        ScalingPolicy specifies the reclaim modes of scaling groups, but the policy that is used to remove ECS instances from scaling groups is determined by the RemovePolicy parameter of the RemoveInstances operation.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scalingPolicy"))

    @scaling_policy.setter
    def scaling_policy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ce2499e40584a3bd5f1841bc51e26bd5230900b632f0c7e37fc76821057c12f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingPolicy", value)

    @builtins.property
    @jsii.member(jsii_name="serverGroups")
    def server_groups(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.ServerGroupsProperty"]]]]:
        '''
        :Property: serverGroups: The config of server group.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.ServerGroupsProperty"]]]], jsii.get(self, "serverGroups"))

    @server_groups.setter
    def server_groups(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroup.ServerGroupsProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31dd1d9829bf55cbdc7d1ffe8c8dcf9f0ef230bfb0937e58b783ccd8d3eeb45e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serverGroups", value)

    @builtins.property
    @jsii.member(jsii_name="spotAllocationStrategy")
    def spot_allocation_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotAllocationStrategy: The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances.
        - lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.
        Default value: priority.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotAllocationStrategy"))

    @spot_allocation_strategy.setter
    def spot_allocation_strategy(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3467af9ff6f58714e69024cf8e1c08c8ec32d09d65f2c96e03714d85db51dc36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotAllocationStrategy", value)

    @builtins.property
    @jsii.member(jsii_name="spotInstancePools")
    def spot_instance_pools(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotInstancePools: The number of instance types that are available. The system creates preemptible instances of multiple instance types that are available at the lowest cost in the scaling group. Valid values: 1 to 10.
        If you set MultiAZPolicy to COMPOSABLE, the default value of this parameter is 2.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotInstancePools"))

    @spot_instance_pools.setter
    def spot_instance_pools(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__250942cb908afa21269feab72a08272451f38f9a2fbaba3c788d007ce3041810)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotInstancePools", value)

    @builtins.property
    @jsii.member(jsii_name="spotInstanceRemedy")
    def spot_instance_remedy(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: spotInstanceRemedy: Specifies whether to supplement preemptible instances. If this parameter is set to true, Auto Scaling attempts to create an instance to replace a preemptible instance when Auto Scaling receives a system message which indicates that the preemptible instance is to be reclaimed.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spotInstanceRemedy"))

    @spot_instance_remedy.setter
    def spot_instance_remedy(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6b4928d284d8a5350acf8f00970f9e38a3a4b404badfddf4cfe55229a465980)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spotInstanceRemedy", value)

    @builtins.property
    @jsii.member(jsii_name="standbyInstances")
    def standby_instances(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: standbyInstances: ECS instances of standby mode in the scaling group.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "standbyInstances"))

    @standby_instances.setter
    def standby_instances(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d9134ca622ee4a84454600eca80eaf573db508d200fa87f96aafe5ad5aaf74a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "standbyInstances", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosScalingGroup.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosScalingGroup.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosScalingGroup.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f2e42911155afe3a66f087f36a15fb0a83ceebffcac36295bf25ce501cc4767)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @builtins.property
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: vSwitchId: If you create a VPC scaling group, you must specify the ID of a VSwitch.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "vSwitchId"))

    @v_switch_id.setter
    def v_switch_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3daa4ce0b286e8173a9e1a47cf7593525e2cc43d1c96a8b2cac05773dbee6d33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vSwitchId", value)

    @builtins.property
    @jsii.member(jsii_name="vSwitchIds")
    def v_switch_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        vSwitchIds: Parameter VSwitchIds.N is used to create instance in multiple zones. Parameter VSwitchIds.N has a priority over parameter VSwitchId.
        The valid range of N is [1, 8], and you can specify at most 5 VSwitches in a VPC.
        The priority of VSwitches descends from 1 to 8, and 1 indicates the highest priority.
        When you fail to create an instance in the zone to which a specified VSwitch belongs, another VSwitch with less priority replaces the specified one automatically.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "vSwitchIds"))

    @v_switch_ids.setter
    def v_switch_ids(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36d11bd02cd8c7ad32271c095146f7debd4bdef9d154248513dc830616b9f1ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vSwitchIds", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingGroup.LaunchTemplateOverridesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instance_type": "instanceType",
            "spot_price_limit": "spotPriceLimit",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class LaunchTemplateOverridesProperty:
        def __init__(
            self,
            *,
            instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            weighted_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param instance_type: 
            :param spot_price_limit: 
            :param weighted_capacity: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__303a3d099eb216d8e0077bcde5871faae7fced1edd21e752245715afa1dc448c)
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument spot_price_limit", value=spot_price_limit, expected_type=type_hints["spot_price_limit"])
                check_type(argname="argument weighted_capacity", value=weighted_capacity, expected_type=type_hints["weighted_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if spot_price_limit is not None:
                self._values["spot_price_limit"] = spot_price_limit
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def instance_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: instanceType: Specify this to override the instance type that is specified in the launch template.
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def spot_price_limit(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: spotPriceLimit: The maximum bid price of instance type that is specified by InstanceType.
            '''
            result = self._values.get("spot_price_limit")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def weighted_capacity(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: weightedCapacity: If you want to scale instances in the scaling group based on the weights of the specified instance types, you must specify WeightedCapacity after you specify InstanceType.
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateOverridesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingGroup.NotificationConfigurationsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "notification_arn": "notificationArn",
            "notification_types": "notificationTypes",
        },
    )
    class NotificationConfigurationsProperty:
        def __init__(
            self,
            *,
            notification_arn: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            notification_types: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
        ) -> None:
            '''
            :param notification_arn: 
            :param notification_types: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fa7fa1fd449930accb4c85d6202b4d7d427d20d67d67beb5ddbf1bc67b59f0d6)
                check_type(argname="argument notification_arn", value=notification_arn, expected_type=type_hints["notification_arn"])
                check_type(argname="argument notification_types", value=notification_types, expected_type=type_hints["notification_types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "notification_arn": notification_arn,
                "notification_types": notification_types,
            }

        @builtins.property
        def notification_arn(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            notificationArn: The format of the parameter value is acs:ess:{region}:{account-id}:{resource-relative-id}.
            region: the region to which the scaling group locates
            account-id: Alibaba Cloud ID
            For example:
            MNS queue: acs:ess:{region}:{account-id}:queue/{queuename}
            MNS topic: acs:ess:{region}:{account-id}:topic/{topicname}
            Cloud Monitor: acs:ess:{region}:{account-id}:/cloudmonitor
            '''
            result = self._values.get("notification_arn")
            assert result is not None, "Required property 'notification_arn' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def notification_types(
            self,
        ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
            '''
            :Property:

            notificationTypes: Ess events and resource change notification types. Possible values:
            AUTOSCALING:SCALE_OUT_SUCCESS
            AUTOSCALING:SCALE_IN_SUCCESS
            AUTOSCALING:SCALE_OUT_ERROR
            AUTOSCALING:SCALE_IN_ERROR
            AUTOSCALING:SCALE_REJECT
            AUTOSCALING:SCALE_OUT_START
            AUTOSCALING:SCALE_IN_START
            AUTOSCALING:SCHEDULE_TASK_EXPIRING
            '''
            result = self._values.get("notification_types")
            assert result is not None, "Required property 'notification_types' is missing"
            return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NotificationConfigurationsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingGroup.ServerGroupsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "port": "port",
            "server_group_id": "serverGroupId",
            "type": "type",
            "weight": "weight",
        },
    )
    class ServerGroupsProperty:
        def __init__(
            self,
            *,
            port: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
            server_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        ) -> None:
            '''
            :param port: 
            :param server_group_id: 
            :param type: 
            :param weight: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ef24b8cd6ca2231b8e170ead63a5169d9a28e001a39c3096aecfaf8b11197d19)
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument server_group_id", value=server_group_id, expected_type=type_hints["server_group_id"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
                check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "port": port,
                "server_group_id": server_group_id,
                "type": type,
                "weight": weight,
            }

        @builtins.property
        def port(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: port: The port of server group.
            '''
            result = self._values.get("port")
            assert result is not None, "Required property 'port' is missing"
            return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def server_group_id(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: serverGroupId: The id of the server group.
            '''
            result = self._values.get("server_group_id")
            assert result is not None, "Required property 'server_group_id' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def type(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: type: The type of the server group.
            '''
            result = self._values.get("type")
            assert result is not None, "Required property 'type' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def weight(
            self,
        ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: weight: The weight of server group.
            '''
            result = self._values.get("weight")
            assert result is not None, "Required property 'weight' is missing"
            return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ServerGroupsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingGroup.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fc33954b83be2fe3bd435e61f80f69cdb44ec4d010264a424306a240cb55df80)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosScalingGroupEnable(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosScalingGroupEnable",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::ScalingGroupEnable``, which is used to enable a scaling group.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``ScalingGroupEnable`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalinggroupenable
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosScalingGroupEnableProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__347186367dab8c2838a3b5398a7d156c3f4e5025a4de886e82129dd1ba41c169)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8e7288c2591fe281bba6364a65ffa61dc280dcdbae28c8923890b3cd370a946)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrLifecycleState")
    def attr_lifecycle_state(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: LifecycleState: The scaling group status
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrLifecycleState"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingGroupId: The scaling group id
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingInstanceDetails")
    def attr_scaling_instance_details(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingInstanceDetails: Detail information of auto created scaling instances
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingInstanceDetails"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingInstances")
    def attr_scaling_instances(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingInstances: The auto created scaling instances
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingInstances"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleArisExecuteErrorInfo")
    def attr_scaling_rule_aris_execute_error_info(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingRuleArisExecuteErrorInfo: The error info of the execution of scaling rule aris
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleArisExecuteErrorInfo"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleArisExecuteResultInstancesAdded")
    def attr_scaling_rule_aris_execute_result_instances_added(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingRuleArisExecuteResultInstancesAdded: Instances added via the execution of scaling rule aris
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleArisExecuteResultInstancesAdded"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleArisExecuteResultInstancesRemoved")
    def attr_scaling_rule_aris_execute_result_instances_removed(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingRuleArisExecuteResultInstancesRemoved: Instances removed via the execution of scaling rule aris
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleArisExecuteResultInstancesRemoved"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleArisExecuteResultNumberOfAddedInstances")
    def attr_scaling_rule_aris_execute_result_number_of_added_instances(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingRuleArisExecuteResultNumberOfAddedInstances: The number of added vm via the execution of scaling rule aris
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleArisExecuteResultNumberOfAddedInstances"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c384b1680b0320bbf43dc5611d960429649b8095fd63f17cfbd384caac52d9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The id of operated scaling group.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea368f54cc5fdae60852e1324fa97da9bbd07cc977bd449949ec35d3b8090e1b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="attachOptions")
    def attach_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroupEnable.AttachOptionsProperty"]]:
        '''
        :Property: attachOptions: Options for attaching instances.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroupEnable.AttachOptionsProperty"]], jsii.get(self, "attachOptions"))

    @attach_options.setter
    def attach_options(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroupEnable.AttachOptionsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73b2950b30fc844ecd2d8aac5fcf64d2bac8a36488f62c720a2a3b8e5a2d571b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "attachOptions", value)

    @builtins.property
    @jsii.member(jsii_name="detachOptions")
    def detach_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroupEnable.DetachOptionsProperty"]]:
        '''
        :Property: detachOptions: Options for detaching instances.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroupEnable.DetachOptionsProperty"]], jsii.get(self, "detachOptions"))

    @detach_options.setter
    def detach_options(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingGroupEnable.DetachOptionsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc2f9caf6b3eba7590f2192165362232567fa88bc3783179a48375c069c02fbf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "detachOptions", value)

    @builtins.property
    @jsii.member(jsii_name="instanceIds")
    def instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: instanceIds: The id list of ECS instance which will be attached. Max support 1000 instances.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "instanceIds"))

    @instance_ids.setter
    def instance_ids(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3833515c0b41629f2fda361d9ef5538668c22cb3d8232b522468d281e5e0698)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceIds", value)

    @builtins.property
    @jsii.member(jsii_name="removeInstanceIds")
    def remove_instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: removeInstanceIds: The id list of ECS instance which will be removed. Max support 1000 instances.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "removeInstanceIds"))

    @remove_instance_ids.setter
    def remove_instance_ids(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9ef031b2973f79001952ee47d835cc810d376904191390090b0818757a45e29)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "removeInstanceIds", value)

    @builtins.property
    @jsii.member(jsii_name="scalingConfigurationId")
    def scaling_configuration_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: scalingConfigurationId: The id of scaling configuration which will be activate.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scalingConfigurationId"))

    @scaling_configuration_id.setter
    def scaling_configuration_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__300913eaef0df2391f749e278ca8589356ebfecf16fcb552d8c98a8f3b02b91c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingConfigurationId", value)

    @builtins.property
    @jsii.member(jsii_name="scalingRuleAris")
    def scaling_rule_aris(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        scalingRuleAris: A list of scaling rule aris which will be executed. Max support 10 scaling rule aris.
        When creating the resource, all the scaling rule aris in the list will be executed.
        When updating the resource, none of scaling rule aris in the list will be executed, unless ScalingRuleArisExecuteVersion is changed.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "scalingRuleAris"))

    @scaling_rule_aris.setter
    def scaling_rule_aris(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c3c18288a0119ab7701236090591d4f28465a4a8656526525be25140d7444e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingRuleAris", value)

    @builtins.property
    @jsii.member(jsii_name="scalingRuleArisExecuteVersion")
    def scaling_rule_aris_execute_version(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: scalingRuleArisExecuteVersion: The change of the property leads to the execution of all the scaling rule aris in ScalingRuleAris.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scalingRuleArisExecuteVersion"))

    @scaling_rule_aris_execute_version.setter
    def scaling_rule_aris_execute_version(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc33c8b007ec3836c344a45b6e7f6616f99acfbbdfd9d4cbf5d4d872106c19c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingRuleArisExecuteVersion", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingGroupEnable.AttachOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"entrusted": "entrusted", "lifecycle_hook": "lifecycleHook"},
    )
    class AttachOptionsProperty:
        def __init__(
            self,
            *,
            entrusted: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            lifecycle_hook: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param entrusted: 
            :param lifecycle_hook: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ae68c32181514bf62b7a3ce7d5d23e3c8c9df1a43ad7ab86bc8c64e6ffcbbdfc)
                check_type(argname="argument entrusted", value=entrusted, expected_type=type_hints["entrusted"])
                check_type(argname="argument lifecycle_hook", value=lifecycle_hook, expected_type=type_hints["lifecycle_hook"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if entrusted is not None:
                self._values["entrusted"] = entrusted
            if lifecycle_hook is not None:
                self._values["lifecycle_hook"] = lifecycle_hook

        @builtins.property
        def entrusted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            entrusted: Specifies whether the scaling group manages the lifecycle of instances that are manually added to the scaling group. Valid values:

            - true: The scaling group manages the lifecycle of instances that are manually added in a similar manner in which the scaling group manages the lifecycle of automatically created instances. When the instances are removed from the scaling group, the instances are automatically released. However, if you call the DetachInstances operation to remove the instances from the scaling group, the instances are not released.
            - false: The scaling group does not manage the lifecycle of instances that are manually added. After the instances are removed from the scaling group, the instances are not released.
            Default value: false.
            Note: This property is unavailable for subscription instances.
            '''
            result = self._values.get("entrusted")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def lifecycle_hook(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            lifecycleHook: Specifies whether to trigger a lifecycle hook for the scaling group to which instances are being added. Valid values:

            - true
            - false
            Default value: false.
            '''
            result = self._values.get("lifecycle_hook")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AttachOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingGroupEnable.DetachOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "decrease_desired_capacity": "decreaseDesiredCapacity",
            "detach_option": "detachOption",
            "lifecycle_hook": "lifecycleHook",
        },
    )
    class DetachOptionsProperty:
        def __init__(
            self,
            *,
            decrease_desired_capacity: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            detach_option: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            lifecycle_hook: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param decrease_desired_capacity: 
            :param detach_option: 
            :param lifecycle_hook: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6c471aa1063b0248a3e90b088766fe7831bb33481b0b57231d71984ed6b171e1)
                check_type(argname="argument decrease_desired_capacity", value=decrease_desired_capacity, expected_type=type_hints["decrease_desired_capacity"])
                check_type(argname="argument detach_option", value=detach_option, expected_type=type_hints["detach_option"])
                check_type(argname="argument lifecycle_hook", value=lifecycle_hook, expected_type=type_hints["lifecycle_hook"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if decrease_desired_capacity is not None:
                self._values["decrease_desired_capacity"] = decrease_desired_capacity
            if detach_option is not None:
                self._values["detach_option"] = detach_option
            if lifecycle_hook is not None:
                self._values["lifecycle_hook"] = lifecycle_hook

        @builtins.property
        def decrease_desired_capacity(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            decreaseDesiredCapacity: Specifies whether to adjust the expected number of instances in the scaling group. Valid values:

            - true: After a specific number of instances are removed from the scaling group, the expected number of instances in the scaling group decreases.
            - false: After a specific number of instances are removed from the scaling group, the expected number of instances in the scaling group remains unchanged.
            Default value: true.
            '''
            result = self._values.get("decrease_desired_capacity")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def detach_option(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            detachOption: Specifies whether to remove the instances from the default server groups and vServer groups of the Server Load Balancer (SLB) instance that is associated with the scaling group, and whether to remove the IP addresses of the instances from the whitelist that manages access to the ApsaraDB RDS instance that is associated with the scaling group.
            If you set this parameter to both, the instances are removed from the default sever groups and vServer groups of the associated SLB instance, and the IP addresses of the instances are removed from the whitelist that manages access to the associated ApsaraDB RDS instance.
            '''
            result = self._values.get("detach_option")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def lifecycle_hook(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            lifecycleHook: Specifies whether to trigger the lifecycle hook for the scaling group when you remove instances from the scaling group. Valid values:

            - true
            - false
            Default value: false.
            '''
            result = self._values.get("lifecycle_hook")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DetachOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosScalingGroupEnableProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "attach_options": "attachOptions",
        "detach_options": "detachOptions",
        "instance_ids": "instanceIds",
        "remove_instance_ids": "removeInstanceIds",
        "scaling_configuration_id": "scalingConfigurationId",
        "scaling_rule_aris": "scalingRuleAris",
        "scaling_rule_aris_execute_version": "scalingRuleArisExecuteVersion",
    },
)
class RosScalingGroupEnableProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        attach_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroupEnable.AttachOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        detach_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroupEnable.DetachOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        remove_instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        scaling_configuration_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_rule_aris: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        scaling_rule_aris_execute_version: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosScalingGroupEnable``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalinggroupenable

        :param scaling_group_id: 
        :param attach_options: 
        :param detach_options: 
        :param instance_ids: 
        :param remove_instance_ids: 
        :param scaling_configuration_id: 
        :param scaling_rule_aris: 
        :param scaling_rule_aris_execute_version: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b65de3797a1bd96a4bdbb7a3cb2c3fb6fbbb3222213d00245060648693f3001b)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument attach_options", value=attach_options, expected_type=type_hints["attach_options"])
            check_type(argname="argument detach_options", value=detach_options, expected_type=type_hints["detach_options"])
            check_type(argname="argument instance_ids", value=instance_ids, expected_type=type_hints["instance_ids"])
            check_type(argname="argument remove_instance_ids", value=remove_instance_ids, expected_type=type_hints["remove_instance_ids"])
            check_type(argname="argument scaling_configuration_id", value=scaling_configuration_id, expected_type=type_hints["scaling_configuration_id"])
            check_type(argname="argument scaling_rule_aris", value=scaling_rule_aris, expected_type=type_hints["scaling_rule_aris"])
            check_type(argname="argument scaling_rule_aris_execute_version", value=scaling_rule_aris_execute_version, expected_type=type_hints["scaling_rule_aris_execute_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
        }
        if attach_options is not None:
            self._values["attach_options"] = attach_options
        if detach_options is not None:
            self._values["detach_options"] = detach_options
        if instance_ids is not None:
            self._values["instance_ids"] = instance_ids
        if remove_instance_ids is not None:
            self._values["remove_instance_ids"] = remove_instance_ids
        if scaling_configuration_id is not None:
            self._values["scaling_configuration_id"] = scaling_configuration_id
        if scaling_rule_aris is not None:
            self._values["scaling_rule_aris"] = scaling_rule_aris
        if scaling_rule_aris_execute_version is not None:
            self._values["scaling_rule_aris_execute_version"] = scaling_rule_aris_execute_version

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The id of operated scaling group.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def attach_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.AttachOptionsProperty]]:
        '''
        :Property: attachOptions: Options for attaching instances.
        '''
        result = self._values.get("attach_options")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.AttachOptionsProperty]], result)

    @builtins.property
    def detach_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.DetachOptionsProperty]]:
        '''
        :Property: detachOptions: Options for detaching instances.
        '''
        result = self._values.get("detach_options")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.DetachOptionsProperty]], result)

    @builtins.property
    def instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: instanceIds: The id list of ECS instance which will be attached. Max support 1000 instances.
        '''
        result = self._values.get("instance_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def remove_instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: removeInstanceIds: The id list of ECS instance which will be removed. Max support 1000 instances.
        '''
        result = self._values.get("remove_instance_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def scaling_configuration_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: scalingConfigurationId: The id of scaling configuration which will be activate.
        '''
        result = self._values.get("scaling_configuration_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_rule_aris(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        scalingRuleAris: A list of scaling rule aris which will be executed. Max support 10 scaling rule aris.
        When creating the resource, all the scaling rule aris in the list will be executed.
        When updating the resource, none of scaling rule aris in the list will be executed, unless ScalingRuleArisExecuteVersion is changed.
        '''
        result = self._values.get("scaling_rule_aris")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def scaling_rule_aris_execute_version(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: scalingRuleArisExecuteVersion: The change of the property leads to the execution of all the scaling rule aris in ScalingRuleAris.
        '''
        result = self._values.get("scaling_rule_aris_execute_version")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosScalingGroupEnableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosScalingGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "max_size": "maxSize",
        "min_size": "minSize",
        "allocation_strategy": "allocationStrategy",
        "az_balance": "azBalance",
        "compensate_with_on_demand": "compensateWithOnDemand",
        "container_group_id": "containerGroupId",
        "custom_policy_arn": "customPolicyArn",
        "db_instance_ids": "dbInstanceIds",
        "default_cooldown": "defaultCooldown",
        "desired_capacity": "desiredCapacity",
        "group_deletion_protection": "groupDeletionProtection",
        "group_type": "groupType",
        "health_check_type": "healthCheckType",
        "instance_id": "instanceId",
        "launch_template_id": "launchTemplateId",
        "launch_template_overrides": "launchTemplateOverrides",
        "launch_template_version": "launchTemplateVersion",
        "load_balancer_ids": "loadBalancerIds",
        "max_instance_lifetime": "maxInstanceLifetime",
        "multi_az_policy": "multiAzPolicy",
        "notification_configurations": "notificationConfigurations",
        "on_demand_base_capacity": "onDemandBaseCapacity",
        "on_demand_percentage_above_base_capacity": "onDemandPercentageAboveBaseCapacity",
        "protected_instances": "protectedInstances",
        "removal_policys": "removalPolicys",
        "resource_group_id": "resourceGroupId",
        "scaling_group_name": "scalingGroupName",
        "scaling_policy": "scalingPolicy",
        "server_groups": "serverGroups",
        "spot_allocation_strategy": "spotAllocationStrategy",
        "spot_instance_pools": "spotInstancePools",
        "spot_instance_remedy": "spotInstanceRemedy",
        "standby_instances": "standbyInstances",
        "tags": "tags",
        "v_switch_id": "vSwitchId",
        "v_switch_ids": "vSwitchIds",
    },
)
class RosScalingGroupProps:
    def __init__(
        self,
        *,
        max_size: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        min_size: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        allocation_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        az_balance: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        compensate_with_on_demand: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        container_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        custom_policy_arn: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        db_instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        default_cooldown: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        desired_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        group_deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        group_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        launch_template_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        launch_template_overrides: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.LaunchTemplateOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        launch_template_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        load_balancer_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        max_instance_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        multi_az_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        notification_configurations: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.NotificationConfigurationsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        on_demand_base_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        on_demand_percentage_above_base_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        protected_instances: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        removal_policys: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_group_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        server_groups: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.ServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        spot_allocation_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_instance_pools: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_instance_remedy: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        standby_instances: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosScalingGroup.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        v_switch_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosScalingGroup``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalinggroup

        :param max_size: 
        :param min_size: 
        :param allocation_strategy: 
        :param az_balance: 
        :param compensate_with_on_demand: 
        :param container_group_id: 
        :param custom_policy_arn: 
        :param db_instance_ids: 
        :param default_cooldown: 
        :param desired_capacity: 
        :param group_deletion_protection: 
        :param group_type: 
        :param health_check_type: 
        :param instance_id: 
        :param launch_template_id: 
        :param launch_template_overrides: 
        :param launch_template_version: 
        :param load_balancer_ids: 
        :param max_instance_lifetime: 
        :param multi_az_policy: 
        :param notification_configurations: 
        :param on_demand_base_capacity: 
        :param on_demand_percentage_above_base_capacity: 
        :param protected_instances: 
        :param removal_policys: 
        :param resource_group_id: 
        :param scaling_group_name: 
        :param scaling_policy: 
        :param server_groups: 
        :param spot_allocation_strategy: 
        :param spot_instance_pools: 
        :param spot_instance_remedy: 
        :param standby_instances: 
        :param tags: 
        :param v_switch_id: 
        :param v_switch_ids: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e755f6c8f9fe533d501c4e7f9273d2f128084280f4bc51b10d896f0712e52d9)
            check_type(argname="argument max_size", value=max_size, expected_type=type_hints["max_size"])
            check_type(argname="argument min_size", value=min_size, expected_type=type_hints["min_size"])
            check_type(argname="argument allocation_strategy", value=allocation_strategy, expected_type=type_hints["allocation_strategy"])
            check_type(argname="argument az_balance", value=az_balance, expected_type=type_hints["az_balance"])
            check_type(argname="argument compensate_with_on_demand", value=compensate_with_on_demand, expected_type=type_hints["compensate_with_on_demand"])
            check_type(argname="argument container_group_id", value=container_group_id, expected_type=type_hints["container_group_id"])
            check_type(argname="argument custom_policy_arn", value=custom_policy_arn, expected_type=type_hints["custom_policy_arn"])
            check_type(argname="argument db_instance_ids", value=db_instance_ids, expected_type=type_hints["db_instance_ids"])
            check_type(argname="argument default_cooldown", value=default_cooldown, expected_type=type_hints["default_cooldown"])
            check_type(argname="argument desired_capacity", value=desired_capacity, expected_type=type_hints["desired_capacity"])
            check_type(argname="argument group_deletion_protection", value=group_deletion_protection, expected_type=type_hints["group_deletion_protection"])
            check_type(argname="argument group_type", value=group_type, expected_type=type_hints["group_type"])
            check_type(argname="argument health_check_type", value=health_check_type, expected_type=type_hints["health_check_type"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument launch_template_id", value=launch_template_id, expected_type=type_hints["launch_template_id"])
            check_type(argname="argument launch_template_overrides", value=launch_template_overrides, expected_type=type_hints["launch_template_overrides"])
            check_type(argname="argument launch_template_version", value=launch_template_version, expected_type=type_hints["launch_template_version"])
            check_type(argname="argument load_balancer_ids", value=load_balancer_ids, expected_type=type_hints["load_balancer_ids"])
            check_type(argname="argument max_instance_lifetime", value=max_instance_lifetime, expected_type=type_hints["max_instance_lifetime"])
            check_type(argname="argument multi_az_policy", value=multi_az_policy, expected_type=type_hints["multi_az_policy"])
            check_type(argname="argument notification_configurations", value=notification_configurations, expected_type=type_hints["notification_configurations"])
            check_type(argname="argument on_demand_base_capacity", value=on_demand_base_capacity, expected_type=type_hints["on_demand_base_capacity"])
            check_type(argname="argument on_demand_percentage_above_base_capacity", value=on_demand_percentage_above_base_capacity, expected_type=type_hints["on_demand_percentage_above_base_capacity"])
            check_type(argname="argument protected_instances", value=protected_instances, expected_type=type_hints["protected_instances"])
            check_type(argname="argument removal_policys", value=removal_policys, expected_type=type_hints["removal_policys"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument scaling_group_name", value=scaling_group_name, expected_type=type_hints["scaling_group_name"])
            check_type(argname="argument scaling_policy", value=scaling_policy, expected_type=type_hints["scaling_policy"])
            check_type(argname="argument server_groups", value=server_groups, expected_type=type_hints["server_groups"])
            check_type(argname="argument spot_allocation_strategy", value=spot_allocation_strategy, expected_type=type_hints["spot_allocation_strategy"])
            check_type(argname="argument spot_instance_pools", value=spot_instance_pools, expected_type=type_hints["spot_instance_pools"])
            check_type(argname="argument spot_instance_remedy", value=spot_instance_remedy, expected_type=type_hints["spot_instance_remedy"])
            check_type(argname="argument standby_instances", value=standby_instances, expected_type=type_hints["standby_instances"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
            check_type(argname="argument v_switch_ids", value=v_switch_ids, expected_type=type_hints["v_switch_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "max_size": max_size,
            "min_size": min_size,
        }
        if allocation_strategy is not None:
            self._values["allocation_strategy"] = allocation_strategy
        if az_balance is not None:
            self._values["az_balance"] = az_balance
        if compensate_with_on_demand is not None:
            self._values["compensate_with_on_demand"] = compensate_with_on_demand
        if container_group_id is not None:
            self._values["container_group_id"] = container_group_id
        if custom_policy_arn is not None:
            self._values["custom_policy_arn"] = custom_policy_arn
        if db_instance_ids is not None:
            self._values["db_instance_ids"] = db_instance_ids
        if default_cooldown is not None:
            self._values["default_cooldown"] = default_cooldown
        if desired_capacity is not None:
            self._values["desired_capacity"] = desired_capacity
        if group_deletion_protection is not None:
            self._values["group_deletion_protection"] = group_deletion_protection
        if group_type is not None:
            self._values["group_type"] = group_type
        if health_check_type is not None:
            self._values["health_check_type"] = health_check_type
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_overrides is not None:
            self._values["launch_template_overrides"] = launch_template_overrides
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if load_balancer_ids is not None:
            self._values["load_balancer_ids"] = load_balancer_ids
        if max_instance_lifetime is not None:
            self._values["max_instance_lifetime"] = max_instance_lifetime
        if multi_az_policy is not None:
            self._values["multi_az_policy"] = multi_az_policy
        if notification_configurations is not None:
            self._values["notification_configurations"] = notification_configurations
        if on_demand_base_capacity is not None:
            self._values["on_demand_base_capacity"] = on_demand_base_capacity
        if on_demand_percentage_above_base_capacity is not None:
            self._values["on_demand_percentage_above_base_capacity"] = on_demand_percentage_above_base_capacity
        if protected_instances is not None:
            self._values["protected_instances"] = protected_instances
        if removal_policys is not None:
            self._values["removal_policys"] = removal_policys
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if scaling_group_name is not None:
            self._values["scaling_group_name"] = scaling_group_name
        if scaling_policy is not None:
            self._values["scaling_policy"] = scaling_policy
        if server_groups is not None:
            self._values["server_groups"] = server_groups
        if spot_allocation_strategy is not None:
            self._values["spot_allocation_strategy"] = spot_allocation_strategy
        if spot_instance_pools is not None:
            self._values["spot_instance_pools"] = spot_instance_pools
        if spot_instance_remedy is not None:
            self._values["spot_instance_remedy"] = spot_instance_remedy
        if standby_instances is not None:
            self._values["standby_instances"] = standby_instances
        if tags is not None:
            self._values["tags"] = tags
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if v_switch_ids is not None:
            self._values["v_switch_ids"] = v_switch_ids

    @builtins.property
    def max_size(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: maxSize: Maximum number of ECS instances in the scaling group. Value range: [0, 2000].
        '''
        result = self._values.get("max_size")
        assert result is not None, "Required property 'max_size' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def min_size(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: minSize: Minimum number of ECS instances in the scaling group. Value range: [0, 2000].
        '''
        result = self._values.get("min_size")
        assert result is not None, "Required property 'min_size' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def allocation_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        allocationStrategy: The allocation policy of instances. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - priority: Auto Scaling selects instance types based on the specified order to create the required number of instances.
        - lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.
        Default value: priority.
        '''
        result = self._values.get("allocation_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def az_balance(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        azBalance: Specifies whether to evenly distribute instances in the scaling group across multiple zones. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - true
        - false
        Default value: false.
        '''
        result = self._values.get("az_balance")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def compensate_with_on_demand(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        compensateWithOnDemand: Specifies whether to automatically create pay-as-you-go instances to meet the requirements on the number of instances when the expected capacity of preemptible instances cannot be fulfilled due to reasons such as high prices or insufficient resources. This parameter takes effect only when MultiAZPolicy is set to COST_OPTIMIZED.
        Default value: true.
        '''
        result = self._values.get("compensate_with_on_demand")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def container_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: containerGroupId: The ID of the elastic container instance.
        '''
        result = self._values.get("container_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def custom_policy_arn(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: customPolicyArn: The Alibaba Cloud Resource Name (ARN) of the custom scale-in policy (Function). This parameter takes effect only if you specify CustomPolicy as the value of first item of RemovalPolicys.
        '''
        result = self._values.get("custom_policy_arn")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def db_instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: dbInstanceIds: ID list of an RDS instance. A Json Array with format: [ "rm-id0", "rm-id1", ... "rm-idz" ], support up to 100 RDS instance.
        '''
        result = self._values.get("db_instance_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def default_cooldown(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        defaultCooldown: Default cool-down time (in seconds) of the scaling group. Value range: [0, 86400].
        The default value is 300s.
        '''
        result = self._values.get("default_cooldown")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def desired_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: desiredCapacity: The expected number of ECS instances in a scaling group. The scaling group automatically keeps the number of ECS instances as expected. The number of ECS instances cannot be greater than the value of MaxSize and cannot be less than the value of MinSize.
        '''
        result = self._values.get("desired_capacity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def group_deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        groupDeletionProtection: Whether to enable deletion protection for scaling group.
        Default to False.
        '''
        result = self._values.get("group_deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def group_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        groupType: The type of instances that are managed by the scaling group. Valid values:
        ECS
        ECI
        Default value: ECS.
        '''
        result = self._values.get("group_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: healthCheckType: The health check type. Allow values is "ECS" and "NONE", default to "ECS".
        '''
        result = self._values.get("health_check_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceId: The ID of the ECS instance from which the scaling group obtains configuration information of the specified instance.
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def launch_template_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: launchTemplateId: The ID of the instance launch template from which the scaling group obtains launch configurations.
        '''
        result = self._values.get("launch_template_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def launch_template_overrides(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.LaunchTemplateOverridesProperty]]]]:
        '''
        :Property:

        launchTemplateOverrides: You can specify up to 10 overrides.
        Note: This parameter takes effect only if you specify LaunchTemplateId.
        '''
        result = self._values.get("launch_template_overrides")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.LaunchTemplateOverridesProperty]]]], result)

    @builtins.property
    def launch_template_version(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        launchTemplateVersion: The version of the instance launch template. Valid values:
        A fixed template version numbe.
        Default: The default template version is always used.
        Latest: The latest template version is always used.
        '''
        result = self._values.get("launch_template_version")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def load_balancer_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: loadBalancerIds: ID list of a Server Load Balancer instance. A Json Array with format: [ "lb-id0", "lb-id1", ... "lb-idz" ], support up to 100 Load Balancer instance.
        '''
        result = self._values.get("load_balancer_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def max_instance_lifetime(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        maxInstanceLifetime: The maximum life span of an ECS instance in the scaling group. Unit: seconds.
        Valid values: 86400 to the value of Integer.maxValue.
        Default value: null.
        Note: This parameter is unavailable for scaling groups of the ECI type or scaling groups whose ScalingPolicy is set to recycle.
        '''
        result = self._values.get("max_instance_lifetime")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def multi_az_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        multiAzPolicy: ECS scaling strategy for multi availability zone. Allow value:

        1. PRIORITY: scaling the capacity according to the virtual switch (VSwitchIds.N) you define. ECS instances are automatically created using the next priority virtual switch when the higher priority virtual switch cannot be created in the available zone.
        2. BALANCE: evenly allocate ECS instances between the multiple available zone specified by the scaling group.
        3. COST_OPTIMIZED: During a scale-out activity, Auto Scaling attempts to create ECS instances that have vCPUs provided at the lowest price. During a scale-in activity, Auto Scaling attempts to remove ECS instances that have vCPUs provided at the highest price. Preemptible instances are preferentially created when preemptible instance types are specified in the active scaling configuration. You can configure the CompensateWithOnDemand parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.
        Note COST_OPTIMIZED is valid when multiple instance types are specified or at least one preemptible instance type is specified.
        4. COMPOSABLE: You can flexibly combine the preceding policies based on your business requirements.
        '''
        result = self._values.get("multi_az_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def notification_configurations(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.NotificationConfigurationsProperty]]]]:
        '''
        :Property: notificationConfigurations: When a scaling event occurs in a scaling group, ESS will send a notification to Cloud Monitor or MNS.
        '''
        result = self._values.get("notification_configurations")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.NotificationConfigurationsProperty]]]], result)

    @builtins.property
    def on_demand_base_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        onDemandBaseCapacity: The minimum number of pay-as-you-go instances required in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.
        If you set MultiAZPolicy to COMPOSABLE Policy, the default value of this parameter is 0.
        '''
        result = self._values.get("on_demand_base_capacity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def on_demand_percentage_above_base_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        onDemandPercentageAboveBaseCapacity: The percentage of pay-as-you-go instances that can be created when instances are added to the scaling group. This parameter takes effect when the number of pay-as-you-go instances reaches the value for the OnDemandBaseCapacity parameter. Valid values: 0 to 100.
        If you set MultiAZPolicy to COMPOSABLE, the default value of this parameter is 100.
        '''
        result = self._values.get("on_demand_percentage_above_base_capacity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def protected_instances(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: protectedInstances: ECS instances of protected mode in the scaling group.
        '''
        result = self._values.get("protected_instances")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def removal_policys(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        removalPolicys: Policy for removing ECS instances from the scaling group.
        Optional values:

        - OldestInstance: removes the first ECS instance attached to the scaling group.
        - NewestInstance: removes the first ECS instance attached to the scaling group.
        - OldestScalingConfiguration: removes the ECS instance with the oldest scaling configuration.
        - CustomPolicy: removes ECS instances based on the custom scale-in policy (Function).
        You can enter up to three removal policies.
        You cannot set any item of RemovalPolicys to the same value.
        The scaling configuration source specified by the OldestScalingConfiguration setting can be a scaling configuration or a launch template. You can specify CustomPolicy only as the value of first item of RemovalPolicys. If you set first item of RemovalPolicys to CustomPolicy, you must also specify CustomPolicyARN.
        Note: The removal of ECS instances from a scaling group is also affected by the value of MultiAZPolicy.
        '''
        result = self._values.get("removal_policys")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: Resource group id.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_group_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scalingGroupName: Name shown for the scaling group, which must contain 2-40 characters (English or Chinese). The name must begin with a number, an upper/lower-case letter or a Chinese character and may contain numbers, "_", "-" or ".". The account name is unique in the same region.
        If this parameter is not specified, the default value is ScalingGroupId.
        '''
        result = self._values.get("scaling_group_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scalingPolicy: The reclaim mode of the scaling group. Valid values:
        recycle
        release
        forcerelease
        ScalingPolicy specifies the reclaim modes of scaling groups, but the policy that is used to remove ECS instances from scaling groups is determined by the RemovePolicy parameter of the RemoveInstances operation.
        '''
        result = self._values.get("scaling_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def server_groups(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.ServerGroupsProperty]]]]:
        '''
        :Property: serverGroups: The config of server group.
        '''
        result = self._values.get("server_groups")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.ServerGroupsProperty]]]], result)

    @builtins.property
    def spot_allocation_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotAllocationStrategy: The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances.
        - lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.
        Default value: priority.
        '''
        result = self._values.get("spot_allocation_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_instance_pools(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spotInstancePools: The number of instance types that are available. The system creates preemptible instances of multiple instance types that are available at the lowest cost in the scaling group. Valid values: 1 to 10.
        If you set MultiAZPolicy to COMPOSABLE, the default value of this parameter is 2.
        '''
        result = self._values.get("spot_instance_pools")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_instance_remedy(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: spotInstanceRemedy: Specifies whether to supplement preemptible instances. If this parameter is set to true, Auto Scaling attempts to create an instance to replace a preemptible instance when Auto Scaling receives a system message which indicates that the preemptible instance is to be reclaimed.
        '''
        result = self._values.get("spot_instance_remedy")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def standby_instances(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: standbyInstances: ECS instances of standby mode in the scaling group.
        '''
        result = self._values.get("standby_instances")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosScalingGroup.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosScalingGroup.TagsProperty]], result)

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: vSwitchId: If you create a VPC scaling group, you must specify the ID of a VSwitch.
        '''
        result = self._values.get("v_switch_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def v_switch_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        vSwitchIds: Parameter VSwitchIds.N is used to create instance in multiple zones. Parameter VSwitchIds.N has a priority over parameter VSwitchId.
        The valid range of N is [1, 8], and you can specify at most 5 VSwitches in a VPC.
        The priority of VSwitches descends from 1 to 8, and 1 indicates the highest priority.
        When you fail to create an instance in the zone to which a specified VSwitch belongs, another VSwitch with less priority replaces the specified one automatically.
        '''
        result = self._values.get("v_switch_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosScalingGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosScalingRule(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosScalingRule",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::ScalingRule``, which is used to create a scaling rule.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``ScalingRule`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalingrule
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosScalingRuleProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__129b235f4eebc982530995cc5c759cbfddbf9d61bdc476c26f55e55462c0a47c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8f5df0f2651efca94af2ad637c4d076fee945e41d4b9c13f77e7ba12c76aab5)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleAri")
    def attr_scaling_rule_ari(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingRuleAri: Unique identifier of a scaling rule.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleAri"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleId")
    def attr_scaling_rule_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingRuleId: ID of a scaling rule, generated by the system and globally unique.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57c0a09d4b44ab20f853c445d3fd3cc56234dadce859970e1a0a0f8419f2d531)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: ID of the scaling group of a scaling rule.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c786db50f0a0f208c14558dcff68da6ff01f36305987e4643999f0d33b726238)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="adjustmentType")
    def adjustment_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        adjustmentType: Adjustment mode of a scaling rule. Optional values:

        - QuantityChangeInCapacity: It is used to increase or decrease a specified number of ECS instances.
        - PercentChangeInCapacity: It is used to increase or decrease a specified proportion of ECS instances.
        - TotalCapacity: It is used to adjust the quantity of ECS instances in the current scaling group to a specified value.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "adjustmentType"))

    @adjustment_type.setter
    def adjustment_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0d08278a5941d5fc64f3cda4e1f20843b36184fdd09b8083d6df2b650413803)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "adjustmentType", value)

    @builtins.property
    @jsii.member(jsii_name="adjustmentValue")
    def adjustment_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        adjustmentValue: Adjusted value of a scaling rule. Value range:

        - QuantityChangeInCapacity: [-500, 500]
        - PercentChangeInCapacity: [-100, 10000]
        - TotalCapacity: [0, 1000]
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "adjustmentValue"))

    @adjustment_value.setter
    def adjustment_value(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3087f00334aaf4ee344fd254d89a2c4643e8236560017433383aafadae3bd15a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "adjustmentValue", value)

    @builtins.property
    @jsii.member(jsii_name="cooldown")
    def cooldown(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: cooldown: Cool-down time of a scaling rule. Value range: [0, 86,400], in seconds. The default value is empty.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "cooldown"))

    @cooldown.setter
    def cooldown(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83751912a78083bfe569a097fbedc39acb72ea9202ae8ddd81b5e9c493e65304)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cooldown", value)

    @builtins.property
    @jsii.member(jsii_name="disableScaleIn")
    def disable_scale_in(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        disableScaleIn: Specifies whether to disable scale-in. This parameter is applicable only to target tracking scaling rules.
        Default value: false
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "disableScaleIn"))

    @disable_scale_in.setter
    def disable_scale_in(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37102122d52769f82116ce2761888967a01f71d319ac85fb878664a7a488d3bd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableScaleIn", value)

    @builtins.property
    @jsii.member(jsii_name="estimatedInstanceWarmup")
    def estimated_instance_warmup(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        estimatedInstanceWarmup: The warm-up period of the ECS instances. This parameter is applicable to target tracking scaling rules and step scaling rules. The system adds ECS instances that are in the warm-up state to the scaling group, but does not report monitoring data during the warm-up period to CloudMonitor.
        Note: When calculating the number of ECS instances to be adjusted, the system does not count ECS instances in the warm-up state as part of the current capacity of the scaling group.
        Valid values: 0 to 86400. Unit: seconds. Default value: 300.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "estimatedInstanceWarmup"))

    @estimated_instance_warmup.setter
    def estimated_instance_warmup(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b33d48f90948bb29e1ead1998a5cfb53d5da5b6baf4bb800ebf47e3dc6cd4a4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "estimatedInstanceWarmup", value)

    @builtins.property
    @jsii.member(jsii_name="initialMaxSize")
    def initial_max_size(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        initialMaxSize: The maximum number of ECS instances in the scaling group, which is used together with PredictiveValueBehavior.
        Default value: the same as the value of MaxSize
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "initialMaxSize"))

    @initial_max_size.setter
    def initial_max_size(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5cd06447e1435c72ef1948e66e5738a1e71d1b925533926d2824bede3f7ab48)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "initialMaxSize", value)

    @builtins.property
    @jsii.member(jsii_name="metricName")
    def metric_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        metricName: The predefined metric to monitor. This parameter is required and applicable only to target tracking scaling rules and predictive scaling rules.
        Valid values of a target tracking scaling rule:

        - CpuUtilization: the average CPU utilization- ClassicInternetRx: the average public network inbound traffic over the classic network
        - ClassicInternetTx: the average public network outbound traffic over the classic network
        - VpcInternetRx: the average public network inbound traffic over the VPC
        - VpcInternetTx: the average public network outbound traffic over the VPC
        - IntranetRx: the average internal network inbound traffic
        - IntranetTx: the average internal network outbound traffic
        Valid values of a predictive scaling rule:
        - CpuUtilization: the average CPU utilization
        - IntranetRx: the average internal network inbound traffic
        - IntranetTx: the average internal network outbound traffic
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "metricName"))

    @metric_name.setter
    def metric_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__765812aec3b0ba0dfcbc69e1347f72c82021308c7efd977d51c04cef169b9c04)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "metricName", value)

    @builtins.property
    @jsii.member(jsii_name="minAdjustmentMagnitude")
    def min_adjustment_magnitude(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: minAdjustmentMagnitude: The minimum number of ECS instances to be adjusted in a scaling rule. This parameter takes effect only when the scaling rule type is SimpleScalingRule or StepScalingRule and AdjustmentType is PercentChangeInCapacity.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "minAdjustmentMagnitude"))

    @min_adjustment_magnitude.setter
    def min_adjustment_magnitude(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b38a038b71ef903e183940ec184860def6fed0982ffedd1c4b5fbb1c17ad765)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minAdjustmentMagnitude", value)

    @builtins.property
    @jsii.member(jsii_name="predictiveScalingMode")
    def predictive_scaling_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        predictiveScalingMode: The mode of the predictive scaling rule. Valid values:

        - PredictAndScale: generates forecasts and creates forecast tasks.
        - PredictOnly: generates forecasts but does not create forecast tasks.
        Default value: PredictAndScale
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "predictiveScalingMode"))

    @predictive_scaling_mode.setter
    def predictive_scaling_mode(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a9732fed780bba511e36c946c860307ba4e43f521887ed5969bd24f51cd89fdf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "predictiveScalingMode", value)

    @builtins.property
    @jsii.member(jsii_name="predictiveTaskBufferTime")
    def predictive_task_buffer_time(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        predictiveTaskBufferTime: The amount of buffer time ahead of the forecast task execution time. By default, all scheduled tasks that are automatically created for a predictive scaling rule are executed at the beginning of each hour. You can set a buffer time to execute forecast tasks ahead of schedule, so that resources can be prepared in advance. Valid values: 0 to 60. Unit: minutes.
        Default value: 0
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "predictiveTaskBufferTime"))

    @predictive_task_buffer_time.setter
    def predictive_task_buffer_time(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ecadcf7d9ae6085d18fb768f68f2c5f193ba68ff8e80f320521be434333dc29)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "predictiveTaskBufferTime", value)

    @builtins.property
    @jsii.member(jsii_name="predictiveValueBehavior")
    def predictive_value_behavior(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        predictiveValueBehavior: The action taken on the predicted maximum value. Valid values:

        - MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for forecast tasks when the predicted value is greater than the initial maximum capacity.
        - PredictiveValueOverrideMax: uses the predicted value as the maximum value for forecast tasks when the predicted value is greater than the initial maximum capacity.
        - PredictiveValueOverrideMaxWithBuffer: increases the predicted value with a ratio, which is specified by PredictiveValueBuffer. If the value after the increase is greater than the initial maximum capacity, the value after the increase is used as the maximum value for forecast tasks.
        Default value: MaxOverridePredictiveValue
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "predictiveValueBehavior"))

    @predictive_value_behavior.setter
    def predictive_value_behavior(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2e8f2b798bb2ffe28dae2451cbd9d2e91a9b506b087cf06a14a56fcab5750fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "predictiveValueBehavior", value)

    @builtins.property
    @jsii.member(jsii_name="predictiveValueBuffer")
    def predictive_value_buffer(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        predictiveValueBuffer: The ratio of the increment to the predicted value when PredictiveValueBehavior is set to PredictiveValueOverrideMaxWithBuffer. When the value after the increase is greater than the initial maximum capacity, the value after the increase is used for forecast tasks. Valid values: 0 to 100
        Default value: 0
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "predictiveValueBuffer"))

    @predictive_value_buffer.setter
    def predictive_value_buffer(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60b00be9933eaaaa3ca12b96b1ce5a9298888ab2b96d413f7c024d4f695b6182)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "predictiveValueBuffer", value)

    @builtins.property
    @jsii.member(jsii_name="scaleInEvaluationCount")
    def scale_in_evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scaleInEvaluationCount: The number of consecutive times that the event-triggered task created for scale-in activities meets the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
        Default value: 15.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scaleInEvaluationCount"))

    @scale_in_evaluation_count.setter
    def scale_in_evaluation_count(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e944483e08ddeb0e7c19cb4f0e53cb0fabf2388aba72b723de37dff4d3286b6c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scaleInEvaluationCount", value)

    @builtins.property
    @jsii.member(jsii_name="scaleOutEvaluationCount")
    def scale_out_evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scaleOutEvaluationCount: The number of consecutive times that the event-triggered task created for scale-out activities meets the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
        Default value: 3.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scaleOutEvaluationCount"))

    @scale_out_evaluation_count.setter
    def scale_out_evaluation_count(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6071067a4d7e8288aee6f29d57af947d67dd9af024ecd42fbe8156336fa50f1f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scaleOutEvaluationCount", value)

    @builtins.property
    @jsii.member(jsii_name="scalingRuleName")
    def scaling_rule_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: scalingRuleName: Name shown for the scaling group, which is a string containing 2 to 40 English or Chinese characters. It must begin with a number, a letter (case-insensitive) or a Chinese character and can contain numbers, "_", "-" or ".". The account name in the same scaling group is unique in the same region. If this parameter value is not specified, the default value is ScalingRuleId.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scalingRuleName"))

    @scaling_rule_name.setter
    def scaling_rule_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b02c61d6b611e4a6b430a7bb7315cf8502d84d38d25450bdfa0e4c51ea58686d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingRuleName", value)

    @builtins.property
    @jsii.member(jsii_name="scalingRuleType")
    def scaling_rule_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scalingRuleType: The type of the scaling rule. Valid values:

        - SimpleScalingRule: scales ECS instances based on the values of AdjustmentType and AdjustmentValue.
        - TargetTrackingScalingRule: dynamically calculates the number of ECS instances to be adjusted and tries to keep the value of a predefined monitoring metric close to TargetValue.
        - StepScalingRule: scales ECS instances in steps based on specified thresholds and metric values.
        - PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and then predicts the future values of monitored metrics, the rule then automatically creates scheduled tasks to set the boundary values for the scaling group.
        If this parameter value is not specified, the default value is SimpleScalingRule.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scalingRuleType"))

    @scaling_rule_type.setter
    def scaling_rule_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99914e36616f4c5c8ad3cbd2f4cc409802dbc438af82e13fe264c20e4a0e5c7f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingRuleType", value)

    @builtins.property
    @jsii.member(jsii_name="stepAdjustment")
    def step_adjustment(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingRule.StepAdjustmentProperty"]]]]:
        '''
        :Property: stepAdjustment:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingRule.StepAdjustmentProperty"]]]], jsii.get(self, "stepAdjustment"))

    @step_adjustment.setter
    def step_adjustment(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosScalingRule.StepAdjustmentProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a4ba87bab268177a60fd866c0368f70f81f77db523524df16c020287892a9ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "stepAdjustment", value)

    @builtins.property
    @jsii.member(jsii_name="targetValue")
    def target_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: targetValue: The target value of a metric. This parameter is required and applicable only to target tracking scaling rules and predictive scaling rules. The value of TargetValue must be greater than 0 and can have a maximum of three decimal places.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "targetValue"))

    @target_value.setter
    def target_value(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8558041a7aa6a89b3a438f65522624bad1cb351b19ee16e2aa031baa036ba992)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "targetValue", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosScalingRule.StepAdjustmentProperty",
        jsii_struct_bases=[],
        name_mapping={
            "metric_interval_lower_bound": "metricIntervalLowerBound",
            "metric_interval_upper_bound": "metricIntervalUpperBound",
            "scaling_adjustment": "scalingAdjustment",
        },
    )
    class StepAdjustmentProperty:
        def __init__(
            self,
            *,
            metric_interval_lower_bound: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            metric_interval_upper_bound: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            scaling_adjustment: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param metric_interval_lower_bound: 
            :param metric_interval_upper_bound: 
            :param scaling_adjustment: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__821668dd812ead5b65c516c242d21b27465f7caae0485b61275e9c845cea774b)
                check_type(argname="argument metric_interval_lower_bound", value=metric_interval_lower_bound, expected_type=type_hints["metric_interval_lower_bound"])
                check_type(argname="argument metric_interval_upper_bound", value=metric_interval_upper_bound, expected_type=type_hints["metric_interval_upper_bound"])
                check_type(argname="argument scaling_adjustment", value=scaling_adjustment, expected_type=type_hints["scaling_adjustment"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metric_interval_lower_bound is not None:
                self._values["metric_interval_lower_bound"] = metric_interval_lower_bound
            if metric_interval_upper_bound is not None:
                self._values["metric_interval_upper_bound"] = metric_interval_upper_bound
            if scaling_adjustment is not None:
                self._values["scaling_adjustment"] = scaling_adjustment

        @builtins.property
        def metric_interval_lower_bound(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            metricIntervalLowerBound: The lower limit value specified in step adjustment N.
            Valid values: -9.999999E18 to 9.999999E18.
            '''
            result = self._values.get("metric_interval_lower_bound")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def metric_interval_upper_bound(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            metricIntervalUpperBound: The upper limit value specified in step adjustment N.
            Valid values: -9.999999E18 to 9.999999E18.
            '''
            result = self._values.get("metric_interval_upper_bound")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def scaling_adjustment(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: scalingAdjustment: The specified number of ECS instances to be adjusted in step adjustment.
            '''
            result = self._values.get("scaling_adjustment")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StepAdjustmentProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosScalingRuleProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "adjustment_type": "adjustmentType",
        "adjustment_value": "adjustmentValue",
        "cooldown": "cooldown",
        "disable_scale_in": "disableScaleIn",
        "estimated_instance_warmup": "estimatedInstanceWarmup",
        "initial_max_size": "initialMaxSize",
        "metric_name": "metricName",
        "min_adjustment_magnitude": "minAdjustmentMagnitude",
        "predictive_scaling_mode": "predictiveScalingMode",
        "predictive_task_buffer_time": "predictiveTaskBufferTime",
        "predictive_value_behavior": "predictiveValueBehavior",
        "predictive_value_buffer": "predictiveValueBuffer",
        "scale_in_evaluation_count": "scaleInEvaluationCount",
        "scale_out_evaluation_count": "scaleOutEvaluationCount",
        "scaling_rule_name": "scalingRuleName",
        "scaling_rule_type": "scalingRuleType",
        "step_adjustment": "stepAdjustment",
        "target_value": "targetValue",
    },
)
class RosScalingRuleProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        adjustment_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        adjustment_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cooldown: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        disable_scale_in: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        estimated_instance_warmup: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        initial_max_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        metric_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        min_adjustment_magnitude: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        predictive_scaling_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        predictive_task_buffer_time: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        predictive_value_behavior: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        predictive_value_buffer: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scale_in_evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scale_out_evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_rule_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_rule_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        step_adjustment: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingRule.StepAdjustmentProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        target_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosScalingRule``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalingrule

        :param scaling_group_id: 
        :param adjustment_type: 
        :param adjustment_value: 
        :param cooldown: 
        :param disable_scale_in: 
        :param estimated_instance_warmup: 
        :param initial_max_size: 
        :param metric_name: 
        :param min_adjustment_magnitude: 
        :param predictive_scaling_mode: 
        :param predictive_task_buffer_time: 
        :param predictive_value_behavior: 
        :param predictive_value_buffer: 
        :param scale_in_evaluation_count: 
        :param scale_out_evaluation_count: 
        :param scaling_rule_name: 
        :param scaling_rule_type: 
        :param step_adjustment: 
        :param target_value: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bbe292b0457dab715dd98b25a68cdefe5eca34a305fe53a40b812a933ae11822)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument adjustment_type", value=adjustment_type, expected_type=type_hints["adjustment_type"])
            check_type(argname="argument adjustment_value", value=adjustment_value, expected_type=type_hints["adjustment_value"])
            check_type(argname="argument cooldown", value=cooldown, expected_type=type_hints["cooldown"])
            check_type(argname="argument disable_scale_in", value=disable_scale_in, expected_type=type_hints["disable_scale_in"])
            check_type(argname="argument estimated_instance_warmup", value=estimated_instance_warmup, expected_type=type_hints["estimated_instance_warmup"])
            check_type(argname="argument initial_max_size", value=initial_max_size, expected_type=type_hints["initial_max_size"])
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument min_adjustment_magnitude", value=min_adjustment_magnitude, expected_type=type_hints["min_adjustment_magnitude"])
            check_type(argname="argument predictive_scaling_mode", value=predictive_scaling_mode, expected_type=type_hints["predictive_scaling_mode"])
            check_type(argname="argument predictive_task_buffer_time", value=predictive_task_buffer_time, expected_type=type_hints["predictive_task_buffer_time"])
            check_type(argname="argument predictive_value_behavior", value=predictive_value_behavior, expected_type=type_hints["predictive_value_behavior"])
            check_type(argname="argument predictive_value_buffer", value=predictive_value_buffer, expected_type=type_hints["predictive_value_buffer"])
            check_type(argname="argument scale_in_evaluation_count", value=scale_in_evaluation_count, expected_type=type_hints["scale_in_evaluation_count"])
            check_type(argname="argument scale_out_evaluation_count", value=scale_out_evaluation_count, expected_type=type_hints["scale_out_evaluation_count"])
            check_type(argname="argument scaling_rule_name", value=scaling_rule_name, expected_type=type_hints["scaling_rule_name"])
            check_type(argname="argument scaling_rule_type", value=scaling_rule_type, expected_type=type_hints["scaling_rule_type"])
            check_type(argname="argument step_adjustment", value=step_adjustment, expected_type=type_hints["step_adjustment"])
            check_type(argname="argument target_value", value=target_value, expected_type=type_hints["target_value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
        }
        if adjustment_type is not None:
            self._values["adjustment_type"] = adjustment_type
        if adjustment_value is not None:
            self._values["adjustment_value"] = adjustment_value
        if cooldown is not None:
            self._values["cooldown"] = cooldown
        if disable_scale_in is not None:
            self._values["disable_scale_in"] = disable_scale_in
        if estimated_instance_warmup is not None:
            self._values["estimated_instance_warmup"] = estimated_instance_warmup
        if initial_max_size is not None:
            self._values["initial_max_size"] = initial_max_size
        if metric_name is not None:
            self._values["metric_name"] = metric_name
        if min_adjustment_magnitude is not None:
            self._values["min_adjustment_magnitude"] = min_adjustment_magnitude
        if predictive_scaling_mode is not None:
            self._values["predictive_scaling_mode"] = predictive_scaling_mode
        if predictive_task_buffer_time is not None:
            self._values["predictive_task_buffer_time"] = predictive_task_buffer_time
        if predictive_value_behavior is not None:
            self._values["predictive_value_behavior"] = predictive_value_behavior
        if predictive_value_buffer is not None:
            self._values["predictive_value_buffer"] = predictive_value_buffer
        if scale_in_evaluation_count is not None:
            self._values["scale_in_evaluation_count"] = scale_in_evaluation_count
        if scale_out_evaluation_count is not None:
            self._values["scale_out_evaluation_count"] = scale_out_evaluation_count
        if scaling_rule_name is not None:
            self._values["scaling_rule_name"] = scaling_rule_name
        if scaling_rule_type is not None:
            self._values["scaling_rule_type"] = scaling_rule_type
        if step_adjustment is not None:
            self._values["step_adjustment"] = step_adjustment
        if target_value is not None:
            self._values["target_value"] = target_value

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: ID of the scaling group of a scaling rule.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def adjustment_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        adjustmentType: Adjustment mode of a scaling rule. Optional values:

        - QuantityChangeInCapacity: It is used to increase or decrease a specified number of ECS instances.
        - PercentChangeInCapacity: It is used to increase or decrease a specified proportion of ECS instances.
        - TotalCapacity: It is used to adjust the quantity of ECS instances in the current scaling group to a specified value.
        '''
        result = self._values.get("adjustment_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def adjustment_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        adjustmentValue: Adjusted value of a scaling rule. Value range:

        - QuantityChangeInCapacity: [-500, 500]
        - PercentChangeInCapacity: [-100, 10000]
        - TotalCapacity: [0, 1000]
        '''
        result = self._values.get("adjustment_value")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cooldown(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: cooldown: Cool-down time of a scaling rule. Value range: [0, 86,400], in seconds. The default value is empty.
        '''
        result = self._values.get("cooldown")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def disable_scale_in(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        disableScaleIn: Specifies whether to disable scale-in. This parameter is applicable only to target tracking scaling rules.
        Default value: false
        '''
        result = self._values.get("disable_scale_in")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def estimated_instance_warmup(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        estimatedInstanceWarmup: The warm-up period of the ECS instances. This parameter is applicable to target tracking scaling rules and step scaling rules. The system adds ECS instances that are in the warm-up state to the scaling group, but does not report monitoring data during the warm-up period to CloudMonitor.
        Note: When calculating the number of ECS instances to be adjusted, the system does not count ECS instances in the warm-up state as part of the current capacity of the scaling group.
        Valid values: 0 to 86400. Unit: seconds. Default value: 300.
        '''
        result = self._values.get("estimated_instance_warmup")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def initial_max_size(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        initialMaxSize: The maximum number of ECS instances in the scaling group, which is used together with PredictiveValueBehavior.
        Default value: the same as the value of MaxSize
        '''
        result = self._values.get("initial_max_size")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def metric_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        metricName: The predefined metric to monitor. This parameter is required and applicable only to target tracking scaling rules and predictive scaling rules.
        Valid values of a target tracking scaling rule:

        - CpuUtilization: the average CPU utilization- ClassicInternetRx: the average public network inbound traffic over the classic network
        - ClassicInternetTx: the average public network outbound traffic over the classic network
        - VpcInternetRx: the average public network inbound traffic over the VPC
        - VpcInternetTx: the average public network outbound traffic over the VPC
        - IntranetRx: the average internal network inbound traffic
        - IntranetTx: the average internal network outbound traffic
        Valid values of a predictive scaling rule:
        - CpuUtilization: the average CPU utilization
        - IntranetRx: the average internal network inbound traffic
        - IntranetTx: the average internal network outbound traffic
        '''
        result = self._values.get("metric_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def min_adjustment_magnitude(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: minAdjustmentMagnitude: The minimum number of ECS instances to be adjusted in a scaling rule. This parameter takes effect only when the scaling rule type is SimpleScalingRule or StepScalingRule and AdjustmentType is PercentChangeInCapacity.
        '''
        result = self._values.get("min_adjustment_magnitude")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def predictive_scaling_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        predictiveScalingMode: The mode of the predictive scaling rule. Valid values:

        - PredictAndScale: generates forecasts and creates forecast tasks.
        - PredictOnly: generates forecasts but does not create forecast tasks.
        Default value: PredictAndScale
        '''
        result = self._values.get("predictive_scaling_mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def predictive_task_buffer_time(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        predictiveTaskBufferTime: The amount of buffer time ahead of the forecast task execution time. By default, all scheduled tasks that are automatically created for a predictive scaling rule are executed at the beginning of each hour. You can set a buffer time to execute forecast tasks ahead of schedule, so that resources can be prepared in advance. Valid values: 0 to 60. Unit: minutes.
        Default value: 0
        '''
        result = self._values.get("predictive_task_buffer_time")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def predictive_value_behavior(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        predictiveValueBehavior: The action taken on the predicted maximum value. Valid values:

        - MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for forecast tasks when the predicted value is greater than the initial maximum capacity.
        - PredictiveValueOverrideMax: uses the predicted value as the maximum value for forecast tasks when the predicted value is greater than the initial maximum capacity.
        - PredictiveValueOverrideMaxWithBuffer: increases the predicted value with a ratio, which is specified by PredictiveValueBuffer. If the value after the increase is greater than the initial maximum capacity, the value after the increase is used as the maximum value for forecast tasks.
        Default value: MaxOverridePredictiveValue
        '''
        result = self._values.get("predictive_value_behavior")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def predictive_value_buffer(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        predictiveValueBuffer: The ratio of the increment to the predicted value when PredictiveValueBehavior is set to PredictiveValueOverrideMaxWithBuffer. When the value after the increase is greater than the initial maximum capacity, the value after the increase is used for forecast tasks. Valid values: 0 to 100
        Default value: 0
        '''
        result = self._values.get("predictive_value_buffer")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scale_in_evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scaleInEvaluationCount: The number of consecutive times that the event-triggered task created for scale-in activities meets the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
        Default value: 15.
        '''
        result = self._values.get("scale_in_evaluation_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scale_out_evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scaleOutEvaluationCount: The number of consecutive times that the event-triggered task created for scale-out activities meets the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
        Default value: 3.
        '''
        result = self._values.get("scale_out_evaluation_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_rule_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: scalingRuleName: Name shown for the scaling group, which is a string containing 2 to 40 English or Chinese characters. It must begin with a number, a letter (case-insensitive) or a Chinese character and can contain numbers, "_", "-" or ".". The account name in the same scaling group is unique in the same region. If this parameter value is not specified, the default value is ScalingRuleId.
        '''
        result = self._values.get("scaling_rule_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_rule_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scalingRuleType: The type of the scaling rule. Valid values:

        - SimpleScalingRule: scales ECS instances based on the values of AdjustmentType and AdjustmentValue.
        - TargetTrackingScalingRule: dynamically calculates the number of ECS instances to be adjusted and tries to keep the value of a predefined monitoring metric close to TargetValue.
        - StepScalingRule: scales ECS instances in steps based on specified thresholds and metric values.
        - PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and then predicts the future values of monitored metrics, the rule then automatically creates scheduled tasks to set the boundary values for the scaling group.
        If this parameter value is not specified, the default value is SimpleScalingRule.
        '''
        result = self._values.get("scaling_rule_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def step_adjustment(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingRule.StepAdjustmentProperty]]]]:
        '''
        :Property: stepAdjustment:
        '''
        result = self._values.get("step_adjustment")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingRule.StepAdjustmentProperty]]]], result)

    @builtins.property
    def target_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: targetValue: The target value of a metric. This parameter is required and applicable only to target tracking scaling rules and predictive scaling rules. The value of TargetValue must be greater than 0 and can have a maximum of three decimal places.
        '''
        result = self._values.get("target_value")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosScalingRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosScheduledTask(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosScheduledTask",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::ScheduledTask``, which is used to create a scheduled task by specifying properties.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``ScheduledTask`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scheduledtask
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosScheduledTaskProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e70bc04b53edd53f3bce0d503df1523fd03bd0bb516a961c08ff699dce3b0d94)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fd96b316a1db63f4c53ecbf41f6c0e15447938bc46d7e6dd994c797869bc0d7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrScheduledTaskId")
    def attr_scheduled_task_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScheduledTaskId: ID of the scheduled task, which is generated by the system and globally unique.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScheduledTaskId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d682d90f2764c362b0de59bffcb4db1466d1c383f844873148e15df9d978b2a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="launchTime")
    def launch_time(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        launchTime: Time point at which the scheduled task is triggered.
        The date format follows the ISO8601 standard and uses UTC time. It is in the format of YYYY-MM-DDThh:mmZ.
        If RecurrenceType is specified, the time point specified by this attribute is the default time point at which the circle is executed. If RecurrenceType is not specified, the task is executed once on the designated date and time.
        A time point 90 days after creation or modification cannot be entered.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "launchTime"))

    @launch_time.setter
    def launch_time(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb31aa7f563691cd64cc155834eac90ec976155d775b5c706c8d6fb0b4f9bb68)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "launchTime", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Description of the scheduled task, which is 2-200 characters (English or Chinese) long.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2eaa8eddc926f15444baa0faaddf87b3525da669452adebcf9549227412b6ac2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="desiredCapacity")
    def desired_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: desiredCapacity: The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the **ScalingGroupId** parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the **MinValue**, **MaxValue**, and **DesiredCapacity** parameters.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "desiredCapacity"))

    @desired_capacity.setter
    def desired_capacity(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9575497ac97a4c47f0569078655742bbb72a8174525f53d144e8ba7c78335344)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "desiredCapacity", value)

    @builtins.property
    @jsii.member(jsii_name="launchExpirationTime")
    def launch_expiration_time(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        launchExpirationTime: Time period within which the failed scheduled task is retried.
        The default value is 600s.
        Value range: [0, 21600]
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "launchExpirationTime"))

    @launch_expiration_time.setter
    def launch_expiration_time(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e700a30e7f61f86e59e301f681b402ab4341088b6d35971b4e9b05f6d5f5867)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "launchExpirationTime", value)

    @builtins.property
    @jsii.member(jsii_name="maxValue")
    def max_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        maxValue: The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.
        **Note**: You must specify the **DesiredCapacity** parameter when you create a scaling group.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "maxValue"))

    @max_value.setter
    def max_value(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17959617e4a579a72857eda6b31880d5dacad153cb9b06e24d32d7780c9046bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxValue", value)

    @builtins.property
    @jsii.member(jsii_name="minValue")
    def min_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: minValue: The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "minValue"))

    @min_value.setter
    def min_value(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2c316039d0ee171759a07b363ca5d57155e93e7ab5110dbd065a99a02e406df)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minValue", value)

    @builtins.property
    @jsii.member(jsii_name="recurrenceEndTime")
    def recurrence_end_time(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        recurrenceEndTime: End time of the scheduled task to be repeated.
        The date format follows the ISO8601 standard and uses UTC time. It is in the format of YYYY-MM-DDThh:mmZ.
        A time point 90 days after creation or modification cannot be entered.
        RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "recurrenceEndTime"))

    @recurrence_end_time.setter
    def recurrence_end_time(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7bb418b7d86edd47711bdab2f47a953a6b008bae794e5aeb7546a62f48263115)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "recurrenceEndTime", value)

    @builtins.property
    @jsii.member(jsii_name="recurrenceType")
    def recurrence_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        recurrenceType: Type of the scheduled task to be repeated. Optional values:

        - Daily: Recurrence interval by day for a scheduled task.
        - Weekly: Recurrence interval by week for a scheduled task.
        - Monthly: Recurrence interval by month for a scheduled task.
        RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "recurrenceType"))

    @recurrence_type.setter
    def recurrence_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6285fe5c3af7751d4321494438fe4d1639cb594587bd7e2d2c6678abb74f87fb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "recurrenceType", value)

    @builtins.property
    @jsii.member(jsii_name="recurrenceValue")
    def recurrence_value(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        recurrenceValue: Value of the scheduled task to be repeated.

        - Daily: Only one value in the range [1,31] can be filled.
        - Weekly: Multiple values can be filled. The values of Sunday to Saturday are 0 to 6 in sequence. Multiple values shall be separated by a comma ",".
        - Monthly: In the format of A-B. The value range of A and B is 1 to 31, and the B value must be greater than the A value.
        RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "recurrenceValue"))

    @recurrence_value.setter
    def recurrence_value(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1879f07c89ce8b289202d204538baf837ed6631d533a729a3b67443b096e479)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "recurrenceValue", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scalingGroupId: The globally unique ID of the scheduled task. The globally unique ID is generated by the system.
        **Note**: You cannot specify the **ScheduledAction** and **ScalingGroupId** parameters at the same time.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e2b689c1a4fd9eb3949e2aa762c3c594583354c96efbbcc1f80b8a299daefe4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="scheduledAction")
    def scheduled_action(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scheduledAction: Operations performed when the scheduled task is triggered. Fill in the unique identifier of the scaling rule.
        **Note**: You cannot specify the **ScheduledAction** and **ScalingGroupId** parameters at the same time.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scheduledAction"))

    @scheduled_action.setter
    def scheduled_action(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe8c4ff427551c663031027c2073507221d497209aa1910de654a5ac9a9ab9b1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scheduledAction", value)

    @builtins.property
    @jsii.member(jsii_name="scheduledTaskName")
    def scheduled_task_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scheduledTaskName: Display name of the scheduled task, which must be 2-40 characters (English or Chinese) long. It must begin with a number, an upper/lower-case letter or a Chinese character and may contain numbers, "_", "-" or ".".
        The account name is unique in the same region.
        If this parameter is not specified, the default value ScheduledScalingTaskId is used.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "scheduledTaskName"))

    @scheduled_task_name.setter
    def scheduled_task_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0c23ca1c33c432e39e4e13c90c13d50e98cac54b7e6ba7060b2161752e983d7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scheduledTaskName", value)

    @builtins.property
    @jsii.member(jsii_name="taskEnabled")
    def task_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        taskEnabled: Whether to enable the scheduled task.

        - When the parameter is set to true, the task is enabled.
        - When the parameter is set to false, the task is disabled.
        The default value is true.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "taskEnabled"))

    @task_enabled.setter
    def task_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3033cc4ab6eb4a69c3792d5564a9c17dfd649986fea21f84f7eedf279ee4fe2a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "taskEnabled", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosScheduledTaskProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_time": "launchTime",
        "description": "description",
        "desired_capacity": "desiredCapacity",
        "launch_expiration_time": "launchExpirationTime",
        "max_value": "maxValue",
        "min_value": "minValue",
        "recurrence_end_time": "recurrenceEndTime",
        "recurrence_type": "recurrenceType",
        "recurrence_value": "recurrenceValue",
        "scaling_group_id": "scalingGroupId",
        "scheduled_action": "scheduledAction",
        "scheduled_task_name": "scheduledTaskName",
        "task_enabled": "taskEnabled",
    },
)
class RosScheduledTaskProps:
    def __init__(
        self,
        *,
        launch_time: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        desired_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        launch_expiration_time: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        max_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        min_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        recurrence_end_time: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        recurrence_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        recurrence_value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scheduled_action: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scheduled_task_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        task_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosScheduledTask``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scheduledtask

        :param launch_time: 
        :param description: 
        :param desired_capacity: 
        :param launch_expiration_time: 
        :param max_value: 
        :param min_value: 
        :param recurrence_end_time: 
        :param recurrence_type: 
        :param recurrence_value: 
        :param scaling_group_id: 
        :param scheduled_action: 
        :param scheduled_task_name: 
        :param task_enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7edbad4a9e9b4186746734093edc2a4cde597d704007910bdb61acd82821ecbd)
            check_type(argname="argument launch_time", value=launch_time, expected_type=type_hints["launch_time"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument desired_capacity", value=desired_capacity, expected_type=type_hints["desired_capacity"])
            check_type(argname="argument launch_expiration_time", value=launch_expiration_time, expected_type=type_hints["launch_expiration_time"])
            check_type(argname="argument max_value", value=max_value, expected_type=type_hints["max_value"])
            check_type(argname="argument min_value", value=min_value, expected_type=type_hints["min_value"])
            check_type(argname="argument recurrence_end_time", value=recurrence_end_time, expected_type=type_hints["recurrence_end_time"])
            check_type(argname="argument recurrence_type", value=recurrence_type, expected_type=type_hints["recurrence_type"])
            check_type(argname="argument recurrence_value", value=recurrence_value, expected_type=type_hints["recurrence_value"])
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument scheduled_action", value=scheduled_action, expected_type=type_hints["scheduled_action"])
            check_type(argname="argument scheduled_task_name", value=scheduled_task_name, expected_type=type_hints["scheduled_task_name"])
            check_type(argname="argument task_enabled", value=task_enabled, expected_type=type_hints["task_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "launch_time": launch_time,
        }
        if description is not None:
            self._values["description"] = description
        if desired_capacity is not None:
            self._values["desired_capacity"] = desired_capacity
        if launch_expiration_time is not None:
            self._values["launch_expiration_time"] = launch_expiration_time
        if max_value is not None:
            self._values["max_value"] = max_value
        if min_value is not None:
            self._values["min_value"] = min_value
        if recurrence_end_time is not None:
            self._values["recurrence_end_time"] = recurrence_end_time
        if recurrence_type is not None:
            self._values["recurrence_type"] = recurrence_type
        if recurrence_value is not None:
            self._values["recurrence_value"] = recurrence_value
        if scaling_group_id is not None:
            self._values["scaling_group_id"] = scaling_group_id
        if scheduled_action is not None:
            self._values["scheduled_action"] = scheduled_action
        if scheduled_task_name is not None:
            self._values["scheduled_task_name"] = scheduled_task_name
        if task_enabled is not None:
            self._values["task_enabled"] = task_enabled

    @builtins.property
    def launch_time(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        launchTime: Time point at which the scheduled task is triggered.
        The date format follows the ISO8601 standard and uses UTC time. It is in the format of YYYY-MM-DDThh:mmZ.
        If RecurrenceType is specified, the time point specified by this attribute is the default time point at which the circle is executed. If RecurrenceType is not specified, the task is executed once on the designated date and time.
        A time point 90 days after creation or modification cannot be entered.
        '''
        result = self._values.get("launch_time")
        assert result is not None, "Required property 'launch_time' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Description of the scheduled task, which is 2-200 characters (English or Chinese) long.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def desired_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: desiredCapacity: The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the **ScalingGroupId** parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the **MinValue**, **MaxValue**, and **DesiredCapacity** parameters.
        '''
        result = self._values.get("desired_capacity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def launch_expiration_time(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        launchExpirationTime: Time period within which the failed scheduled task is retried.
        The default value is 600s.
        Value range: [0, 21600]
        '''
        result = self._values.get("launch_expiration_time")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def max_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        maxValue: The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.
        **Note**: You must specify the **DesiredCapacity** parameter when you create a scaling group.
        '''
        result = self._values.get("max_value")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def min_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: minValue: The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.
        '''
        result = self._values.get("min_value")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def recurrence_end_time(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        recurrenceEndTime: End time of the scheduled task to be repeated.
        The date format follows the ISO8601 standard and uses UTC time. It is in the format of YYYY-MM-DDThh:mmZ.
        A time point 90 days after creation or modification cannot be entered.
        RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        result = self._values.get("recurrence_end_time")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def recurrence_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        recurrenceType: Type of the scheduled task to be repeated. Optional values:

        - Daily: Recurrence interval by day for a scheduled task.
        - Weekly: Recurrence interval by week for a scheduled task.
        - Monthly: Recurrence interval by month for a scheduled task.
        RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        result = self._values.get("recurrence_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def recurrence_value(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        recurrenceValue: Value of the scheduled task to be repeated.

        - Daily: Only one value in the range [1,31] can be filled.
        - Weekly: Multiple values can be filled. The values of Sunday to Saturday are 0 to 6 in sequence. Multiple values shall be separated by a comma ",".
        - Monthly: In the format of A-B. The value range of A and B is 1 to 31, and the B value must be greater than the A value.
        RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        result = self._values.get("recurrence_value")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scalingGroupId: The globally unique ID of the scheduled task. The globally unique ID is generated by the system.
        **Note**: You cannot specify the **ScheduledAction** and **ScalingGroupId** parameters at the same time.
        '''
        result = self._values.get("scaling_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scheduled_action(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scheduledAction: Operations performed when the scheduled task is triggered. Fill in the unique identifier of the scaling rule.
        **Note**: You cannot specify the **ScheduledAction** and **ScalingGroupId** parameters at the same time.
        '''
        result = self._values.get("scheduled_action")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scheduled_task_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        scheduledTaskName: Display name of the scheduled task, which must be 2-40 characters (English or Chinese) long. It must begin with a number, an upper/lower-case letter or a Chinese character and may contain numbers, "_", "-" or ".".
        The account name is unique in the same region.
        If this parameter is not specified, the default value ScheduledScalingTaskId is used.
        '''
        result = self._values.get("scheduled_task_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def task_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        taskEnabled: Whether to enable the scheduled task.

        - When the parameter is set to true, the task is enabled.
        - When the parameter is set to false, the task is disabled.
        The default value is true.
        '''
        result = self._values.get("task_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosScheduledTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosServerGroupAttachment(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosServerGroupAttachment",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::ServerGroupAttachment``, which is used to add one or more Server Load Balancer (SLB) server groups to a scaling group.

    Supported SLB server groups include Application Load Balancer (ALB) server groups and Network Load Balancer (NLB) server groups.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``ServerGroupAttachment`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-servergroupattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosServerGroupAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d66cb44da9dc058cc161ebec2ab43db644f1f98b96e3fe515ec7964888608ea3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f4b79d3cf9f0e41fa8e07e1a23c2fa7d79e0c3e5f46165ee85085275d49709e)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingActivityId")
    def attr_scaling_activity_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute:

        ScalingActivityId: The ID of the scaling activity during which one or more SLB instances are attached to the scaling group and the ECS instances in the scaling group are added to the backend server groups of the SLB instances.
        Note This parameter is returned only after you set the ForceAttach parameter to true.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingActivityId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cdbae87cba96d50aeb537fe96775932b54796824b94469e14723f6be24c0c2da)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5eb48bc2a1c798164da5f9c2aac437d9687fbfbf668bc7bafa217cbb1746beb2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="serverGroups")
    def server_groups(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosServerGroupAttachment.ServerGroupsProperty"]]]:
        '''
        :Property: serverGroups: A collection of information about server groups.
        '''
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosServerGroupAttachment.ServerGroupsProperty"]]], jsii.get(self, "serverGroups"))

    @server_groups.setter
    def server_groups(
        self,
        value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosServerGroupAttachment.ServerGroupsProperty"]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca58907bfaca409ffe5abfa667f98685dc10d1e97732d157ccd3ae281e55a197)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serverGroups", value)

    @builtins.property
    @jsii.member(jsii_name="forceAttach")
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        forceAttach: Specifies whether to add the Elastic Compute Service (ECS) instances in the scaling group to the backend server group of the newly attached SLB instance. Valid values:
        true
        false
        Default value: false.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "forceAttach"))

    @force_attach.setter
    def force_attach(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95f9b530f89980e8ca5828f39be7a23f8fbc9d45335912e7731b09de6150444e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "forceAttach", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosServerGroupAttachment.ServerGroupsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "port": "port",
            "server_group_id": "serverGroupId",
            "type": "type",
            "weight": "weight",
        },
    )
    class ServerGroupsProperty:
        def __init__(
            self,
            *,
            port: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
            server_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        ) -> None:
            '''
            :param port: 
            :param server_group_id: 
            :param type: 
            :param weight: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__036603b41cb0389b758807236ac54d279545594ba19650113d7c267f866072da)
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument server_group_id", value=server_group_id, expected_type=type_hints["server_group_id"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
                check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "port": port,
                "server_group_id": server_group_id,
                "type": type,
                "weight": weight,
            }

        @builtins.property
        def port(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            port: The port number used by an ECS instance in the scaling group after Auto Scaling adds the ECS instance to backend server group.
            ALB server group port range [1,65535], NLB server group port range [0,65535].
            '''
            result = self._values.get("port")
            assert result is not None, "Required property 'port' is missing"
            return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def server_group_id(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: serverGroupId: The ID of backend server group.
            '''
            result = self._values.get("server_group_id")
            assert result is not None, "Required property 'server_group_id' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def type(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            type: The type of backend server group.
            Valid values:
            ALB
            NLB
            '''
            result = self._values.get("type")
            assert result is not None, "Required property 'type' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def weight(
            self,
        ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            weight: The weight of an ECS instance in the scaling group as a backend server after Auto Scaling adds the ECS instance to backend server group. Valid values: 0 to 100.
            If you increase the weight of an ECS instance in a backend server group, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance in a backend server group to 0, no access requests are forwarded to the ECS instance.
            '''
            result = self._values.get("weight")
            assert result is not None, "Required property 'weight' is missing"
            return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ServerGroupsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosServerGroupAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "server_groups": "serverGroups",
        "force_attach": "forceAttach",
    },
)
class RosServerGroupAttachmentProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        server_groups: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosServerGroupAttachment.ServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]],
        force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosServerGroupAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-servergroupattachment

        :param scaling_group_id: 
        :param server_groups: 
        :param force_attach: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fe123fb375be825f820c3a8e3b8421ae8c7a08538ced0a38d6721b6be7206a5)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument server_groups", value=server_groups, expected_type=type_hints["server_groups"])
            check_type(argname="argument force_attach", value=force_attach, expected_type=type_hints["force_attach"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
            "server_groups": server_groups,
        }
        if force_attach is not None:
            self._values["force_attach"] = force_attach

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def server_groups(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosServerGroupAttachment.ServerGroupsProperty]]]:
        '''
        :Property: serverGroups: A collection of information about server groups.
        '''
        result = self._values.get("server_groups")
        assert result is not None, "Required property 'server_groups' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosServerGroupAttachment.ServerGroupsProperty]]], result)

    @builtins.property
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        forceAttach: Specifies whether to add the Elastic Compute Service (ECS) instances in the scaling group to the backend server group of the newly attached SLB instance. Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("force_attach")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosServerGroupAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVServerGroupAttachment(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.RosVServerGroupAttachment",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::ESS::VServerGroupAttachment``, which is used to associate vServer groups of a Sever Load Balancer (SLB) instance with a scaling group.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``VServerGroupAttachment`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-vservergroupattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosVServerGroupAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47a7cbc3bc6aaf8d24d08f6acf23c7ed1bfd31586eac86225b0ea721a18a15bc)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3cb910ddf964228679a36936a31b08b6f9bd6b78f33ca08f1260e82bf84fa27)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ScalingGroupId: The ID of the scaling group.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1320f11624eea5f56ece49e6c8a302e3eb09a56e3b27793e6fa55d819877a62a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="scalingGroupId")
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "scalingGroupId"))

    @scaling_group_id.setter
    def scaling_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8acbaa9f57341e0acc4b5b5ed14786db224e9ff8219112934810265a85e8050)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="vServerGroups")
    def v_server_groups(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVServerGroupAttachment.VServerGroupsProperty"]]]:
        '''
        :Property: vServerGroups: A list of vserver groups attached on scaling group
        '''
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVServerGroupAttachment.VServerGroupsProperty"]]], jsii.get(self, "vServerGroups"))

    @v_server_groups.setter
    def v_server_groups(
        self,
        value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVServerGroupAttachment.VServerGroupsProperty"]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__451db23fc72b05a74fb69974a46f40f3410c21684453c3b444a565d656eac874)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vServerGroups", value)

    @builtins.property
    @jsii.member(jsii_name="forceAttach")
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        forceAttach: If instances of scaling group are attached/removed from slb backend server when attach/detach vserver group from scaling group.
        Valid values:
        true
        false
        Default value: false.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "forceAttach"))

    @force_attach.setter
    def force_attach(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c4e5bbc3a9dea2c733b079857cbc25ab7e1f80d0aaa2334eade7584e93b9bef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "forceAttach", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosVServerGroupAttachment.VServerGroupAttributesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "port": "port",
            "v_server_group_id": "vServerGroupId",
            "weight": "weight",
        },
    )
    class VServerGroupAttributesProperty:
        def __init__(
            self,
            *,
            port: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
            v_server_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param port: 
            :param v_server_group_id: 
            :param weight: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3bcf5c96a6970208ec27964aed5399fc680a2bab05ddb277dc2c82d49fe2a864)
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument v_server_group_id", value=v_server_group_id, expected_type=type_hints["v_server_group_id"])
                check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "port": port,
                "v_server_group_id": v_server_group_id,
            }
            if weight is not None:
                self._values["weight"] = weight

        @builtins.property
        def port(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: port: The port will be used for VServer Group backend server.
            '''
            result = self._values.get("port")
            assert result is not None, "Required property 'port' is missing"
            return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def v_server_group_id(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: vServerGroupId: ID of VServer Group.
            '''
            result = self._values.get("v_server_group_id")
            assert result is not None, "Required property 'v_server_group_id' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def weight(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            weight: The weight of an ECS instance attached to the VServer Group.
            Default value: 50.
            '''
            result = self._values.get("weight")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VServerGroupAttributesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ess.RosVServerGroupAttachment.VServerGroupsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "load_balancer_id": "loadBalancerId",
            "v_server_group_attributes": "vServerGroupAttributes",
        },
    )
    class VServerGroupsProperty:
        def __init__(
            self,
            *,
            load_balancer_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            v_server_group_attributes: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosVServerGroupAttachment.VServerGroupAttributesProperty", typing.Dict[builtins.str, typing.Any]]]]],
        ) -> None:
            '''
            :param load_balancer_id: 
            :param v_server_group_attributes: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b7434adc6c5717e87e2ee474ca25f2e7e29254b714af4df15e4256fc549799d0)
                check_type(argname="argument load_balancer_id", value=load_balancer_id, expected_type=type_hints["load_balancer_id"])
                check_type(argname="argument v_server_group_attributes", value=v_server_group_attributes, expected_type=type_hints["v_server_group_attributes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "load_balancer_id": load_balancer_id,
                "v_server_group_attributes": v_server_group_attributes,
            }

        @builtins.property
        def load_balancer_id(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: loadBalancerId: Load balancer server ID of VServer Group.
            '''
            result = self._values.get("load_balancer_id")
            assert result is not None, "Required property 'load_balancer_id' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def v_server_group_attributes(
            self,
        ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVServerGroupAttachment.VServerGroupAttributesProperty"]]]:
            '''
            :Property: vServerGroupAttributes: A list of VServer Group attributes.
            '''
            result = self._values.get("v_server_group_attributes")
            assert result is not None, "Required property 'v_server_group_attributes' is missing"
            return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVServerGroupAttachment.VServerGroupAttributesProperty"]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VServerGroupsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.RosVServerGroupAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "v_server_groups": "vServerGroups",
        "force_attach": "forceAttach",
    },
)
class RosVServerGroupAttachmentProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        v_server_groups: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVServerGroupAttachment.VServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]],
        force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosVServerGroupAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-vservergroupattachment

        :param scaling_group_id: 
        :param v_server_groups: 
        :param force_attach: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c40151e32f3620a0a4f64c6a3763a8c679ac1ed4738db19dd4c702e4e15ce0d)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument v_server_groups", value=v_server_groups, expected_type=type_hints["v_server_groups"])
            check_type(argname="argument force_attach", value=force_attach, expected_type=type_hints["force_attach"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
            "v_server_groups": v_server_groups,
        }
        if force_attach is not None:
            self._values["force_attach"] = force_attach

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: scalingGroupId: The ID of the scaling group.
        '''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def v_server_groups(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVServerGroupAttachment.VServerGroupsProperty]]]:
        '''
        :Property: vServerGroups: A list of vserver groups attached on scaling group
        '''
        result = self._values.get("v_server_groups")
        assert result is not None, "Required property 'v_server_groups' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVServerGroupAttachment.VServerGroupsProperty]]], result)

    @builtins.property
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        forceAttach: If instances of scaling group are attached/removed from slb backend server when attach/detach vserver group from scaling group.
        Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("force_attach")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVServerGroupAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ScalingConfiguration(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.ScalingConfiguration",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::ScalingConfiguration``, which is used to create a scaling configuration for a scaling group.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosScalingConfiguration``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalingconfiguration
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["ScalingConfigurationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a01e47ae6081577d2e6bcdab5668699ae058a3f0638a8fa9db1cdf5079c0c36)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrScalingConfigurationId")
    def attr_scaling_configuration_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingConfigurationId: The scaling configuration id.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingConfigurationId"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingGroupId: The id of the scaling group to which the scaling configuration belongs.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0395fae06d53f50cd9f9721a24c9bf49b852a775525223805b3fe0e9f4844817)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de3f33fec236662862eeba4a2c859474f30c8a91ab86fc7e5a86d93ebc83cf78)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "ScalingConfigurationProps":
        return typing.cast("ScalingConfigurationProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "ScalingConfigurationProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35d084ee45c5510ffa281ce8bc7f2ade9884bb0b98d5440bdb915d28b861fde9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec8adba54c443a74b1f71dd1817f2b6bbd9af97bda270758debf165d15d22ee5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.ScalingConfigurationProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "affinity": "affinity",
        "cpu": "cpu",
        "credit_specification": "creditSpecification",
        "dedicated_host_id": "dedicatedHostId",
        "deployment_set_id": "deploymentSetId",
        "disk_mappings": "diskMappings",
        "host_name": "hostName",
        "hpc_cluster_id": "hpcClusterId",
        "image_family": "imageFamily",
        "image_id": "imageId",
        "image_name": "imageName",
        "image_options_login_as_non_root": "imageOptionsLoginAsNonRoot",
        "instance_description": "instanceDescription",
        "instance_id": "instanceId",
        "instance_name": "instanceName",
        "instance_pattern_infos": "instancePatternInfos",
        "instance_type": "instanceType",
        "instance_type_overrides": "instanceTypeOverrides",
        "instance_types": "instanceTypes",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "ipv6_address_count": "ipv6AddressCount",
        "key_pair_name": "keyPairName",
        "load_balancer_weight": "loadBalancerWeight",
        "memory": "memory",
        "password": "password",
        "password_inherit": "passwordInherit",
        "private_pool_options": "privatePoolOptions",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "scaling_configuration_name": "scalingConfigurationName",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
        "spot_duration": "spotDuration",
        "spot_interruption_behavior": "spotInterruptionBehavior",
        "spot_price_limit": "spotPriceLimit",
        "spot_price_limit_for_instance_type": "spotPriceLimitForInstanceType",
        "spot_strategy": "spotStrategy",
        "system_disk_auto_snapshot_policy_id": "systemDiskAutoSnapshotPolicyId",
        "system_disk_bursting_enabled": "systemDiskBurstingEnabled",
        "system_disk_categories": "systemDiskCategories",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_encrypt_algorithm": "systemDiskEncryptAlgorithm",
        "system_disk_encrypted": "systemDiskEncrypted",
        "system_disk_kms_key_id": "systemDiskKmsKeyId",
        "system_disk_performance_level": "systemDiskPerformanceLevel",
        "system_disk_provisioned_iops": "systemDiskProvisionedIops",
        "system_disk_size": "systemDiskSize",
        "tag_list": "tagList",
        "tenancy": "tenancy",
        "user_data": "userData",
        "zone_id": "zoneId",
    },
)
class ScalingConfigurationProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        affinity: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        credit_specification: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        dedicated_host_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deployment_set_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        disk_mappings: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.DiskMappingsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        host_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        hpc_cluster_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_family: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        image_options_login_as_non_root: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_pattern_infos: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.InstancePatternInfosProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_type_overrides: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.InstanceTypeOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_max_bandwidth_in: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_max_bandwidth_out: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        io_optimized: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ipv6_address_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        key_pair_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        load_balancer_weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        password: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        private_pool_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.PrivatePoolOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ram_role_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_configuration_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_enhancement_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_group_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        spot_duration: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_interruption_behavior: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_price_limit_for_instance_type: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]] = None,
        spot_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_auto_snapshot_policy_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_categories: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        system_disk_category: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_disk_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_encrypt_algorithm: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_encrypted: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_kms_key_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_performance_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        system_disk_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tag_list: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.TagListProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tenancy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        user_data: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        zone_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``ScalingConfiguration``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalingconfiguration

        :param scaling_group_id: Property scalingGroupId: Scaling group id to create the scaling configuration.
        :param affinity: Property affinity: Specifies whether to associate an ECS instance on a dedicated host with the dedicated host. Valid values: - **default**: does not associate the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode and the original dedicated host has insufficient resources, the ECS instance is automatically deployed to another dedicated host in the automatic deployment resource pool. - **host**: associates the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the ECS instance fails to start. Default value: **default**
        :param cpu: Property cpu: The number of vCPUs. You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set CPU to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type. **Note**: You can specify **Cpu** and **Memory** to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
        :param credit_specification: Property creditSpecification: The performance mode of the burstable instance. Valid values: Standard: the standard mode. Unlimited: the unlimited mode.
        :param dedicated_host_id: Property dedicatedHostId: The ID of the dedicated host on which you want to create an ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify **DedicatedHostId**, **SpotStrategy** and **SpotPriceLimit** are ignored. You can call the **DescribeDedicatedHosts** operation to query dedicated host IDs.
        :param deployment_set_id: Property deploymentSetId: Deployment set ID.
        :param disk_mappings: Property diskMappings: Disk mappings to attach to instance.
        :param host_name: Property hostName: The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances: Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits. Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        :param hpc_cluster_id: Property hpcClusterId: The HPC cluster ID to which the instance belongs.
        :param image_family: Property imageFamily: The name of the image family. You can configure this parameter to obtain the latest available images within the specified image family. The images are used to create ECS instances. If you have set the ImageId parameter, you cannot set the ImageFamily parameter.
        :param image_id: Property imageId: Image ID to create ecs instance .
        :param image_name: Property imageName: The name of the image. Each image name must be unique in a region. If you specify **ImageId**, **ImageName** is ignored. You cannot use **ImageName** to specify images that are purchased from Alibaba Cloud Marketplace.
        :param image_options_login_as_non_root: Property imageOptionsLoginAsNonRoot: Whether the ecs instance is logged in as ecs-user.Valid values: - **true** - **false** Default value: **false**.
        :param instance_description: Property instanceDescription: The description of the ECS instance. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with http:// or https://.
        :param instance_id: Property instanceId: Source ECS instance to copy configuration, if the properties is setting, Which will copy the InstanceType, ImageId, InternetChargeType, IoOptimized,UserData, KeyPairName, RamRoleName, InternetMaxBandwidthIn,InternetMaxBandwidthOut, and first security group id from source instance, you can also specify the relative properties to overwrite the properties copy from source instance id.
        :param instance_name: Property instanceName: The name of the instance launched from the current scaling configuration.
        :param instance_pattern_infos: Property instancePatternInfos: Details of the intelligent configuration settings that determine the range of instance types that meet the specified criteria.
        :param instance_type: Property instanceType: ecs supported instance type.
        :param instance_type_overrides: Property instanceTypeOverrides: The instance types.
        :param instance_types: Property instanceTypes: ecs supported instance types. Length [1,10]. If InstanceTypes is specified,the InstanceType will be ignored.
        :param internet_charge_type: Property internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only.
        :param internet_max_bandwidth_in: Property internetMaxBandwidthIn: Maximum incoming bandwidth from the public network, measured in Mbps (Mega bit per second). The value range is [1,200]. If this parameter value is not specified, AliyunAPI automatically sets the value to 200 Mbps.
        :param internet_max_bandwidth_out: Property internetMaxBandwidthOut: Maximum outgoing bandwidth from the public network, measured in Mbps (Mega bit per second). The value range for PayByBandwidth is [0,100]. If this parameter value is not specified, AliyunAPI automatically sets the value to 0 Mbps. The value range for PayByTraffic is [0,100]. If this parameter value is not specified, an error is reported
        :param io_optimized: Property ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'none'.
        :param ipv6_address_count: Property ipv6AddressCount: The number of randomly generated IPv6 addresses to be assigned to the elastic network interface (ENI).
        :param key_pair_name: Property keyPairName: SSH key pair name.
        :param load_balancer_weight: Property loadBalancerWeight: The weight of the ECS instance as a backend server. Valid values: 1 to 100. Default value: 50.
        :param memory: Property memory: The memory size. Unit: GiB. You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type. **Note**: You can specify **Cpu** and **Memory** to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
        :param password: Property password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        :param password_inherit: Property passwordInherit: Whether to use the password pre-configured in the image you select or not. When PasswordInherit is specified, the Password must be null. For a secure access, make sure that the selected image has password configured.
        :param private_pool_options: Property privatePoolOptions: Option settings for private pools.
        :param ram_role_name: Property ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        :param resource_group_id: Property resourceGroupId: Resource group id.
        :param scaling_configuration_name: Property scalingConfigurationName: Name of created scaling configuration.
        :param security_enhancement_strategy: Property securityEnhancementStrategy: Specifies whether to enable security hardening. Valid values: - **Active**: enables security hardening. This value is applicable only to public images. - **Deactive**: disables security hardening. This value is applicable to all image types.
        :param security_group_id: Property securityGroupId: Security Group to create ecs instance.
        :param security_group_ids: Property securityGroupIds: The IDs of the security groups with which you want to associate the ECS instances that are created by using the scaling configuration. **Note**: If you specify **SecurityGroupId**, you cannot specify **SecurityGroupIds**.
        :param spot_duration: Property spotDuration: The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6. The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket. If you set this parameter to 0, no protection period is specified for the preemptible instance. Default value: 1
        :param spot_interruption_behavior: Property spotInterruptionBehavior: The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate. This value specifies that the preemptible instance is to be released.
        :param spot_price_limit: Property spotPriceLimit: Set the hourly maximum price for the instance. Supports a maximum of 3 decimal places, and the parameter takes effect only when the value of SpotStrategy is SpotWithPriceLimit.It is a default value for all instance types, and can be overwrite by SpotPriceLimitForInstanceType
        :param spot_price_limit_for_instance_type: Property spotPriceLimitForInstanceType: Set the hourly maximum price for the instance of specified instance type. The parameter takes effect only when the value of SpotStrategy is SpotWithPriceLimit. You should input the information of the tag with the format of the Key-Value, such as {"key1":"value1","key2":"value2", ... "key5":"value5"}. At most 50 items can be specified. Key ecs instance type Value Supports a maximum of 3 decimal places.
        :param spot_strategy: Property spotStrategy: Preemption strategy for post-paid instances. It takes effect when the parameter InstanceChargeType takes the value of PostPaid. Ranges: NoSpot: Normal pay-per-use instance SpotWithPriceLimit: Set a preemptive instance of the cap price SpotAsPriceGo: System automatic bidding, following the current market actual price Default: NoSpot.
        :param system_disk_auto_snapshot_policy_id: Property systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        :param system_disk_bursting_enabled: Property systemDiskBurstingEnabled: Specifies whether to enable the burst feature for the system disk. Valid values: - **true** - **false** **Note**: This parameter is available only if you set **SystemDiskCategory** to **cloud_auto**.
        :param system_disk_categories: Property systemDiskCategories: The categories of the system disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values: - **cloud**: basic disk - **cloud_efficiency**: ultra disk - **cloud_ssd**: standard SSD - **cloud_essd**: ESSD **Note**: If you specify **SystemDiskCategories**, you cannot specify **SystemDiskCategory**.
        :param system_disk_category: Property systemDiskCategory: Category of system disk. Default is cloud.support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd|cloud_auto
        :param system_disk_description: Property systemDiskDescription: The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with http:// or https://.
        :param system_disk_disk_name: Property systemDiskDiskName: The name of the system disk. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        :param system_disk_encrypt_algorithm: Property systemDiskEncryptAlgorithm: The encryption algorithm that you want to use to encrypt the system disk. Valid values: - **AES-256** - **SM4-128** Default value: **AES-256**
        :param system_disk_encrypted: Property systemDiskEncrypted: Specifies whether to encrypt the system disk. Valid values: - **true** - **false** Default value: **false**
        :param system_disk_kms_key_id: Property systemDiskKmsKeyId: The ID of the KMS key that you want to use to encrypt the system disk.
        :param system_disk_performance_level: Property systemDiskPerformanceLevel: The performance level of an ESSD.
        :param system_disk_provisioned_iops: Property systemDiskProvisionedIops: The IOPS metric that is preconfigured for the system disk. **Note**: IOPS measures the number of read and write operations that an EBS device can process per second.
        :param system_disk_size: Property systemDiskSize: Size of system disk. Unit is GB.
        :param tag_list: Property tagList: The tags of an instance in list format. Do not use with Tags at the same time. You should input the information of the tag with the format of Key-Value list, such as [{"Key":"key1","Value":"value1"}, ...]. At most 20 tags can be specified. Key It can be up to 64 characters in length. Cannot begin with aliyun. Cannot begin with http:// or https://. Cannot be a null string. Value It can be up to 128 characters in length. Cannot begin with aliyun. Cannot begin with http:// or https://. Can be a null string.If less then 20 tags are specified, ros will add a tag(Key: "ros-aliyun-created", Value:"<resource_name>*stack*<stack_id>") if possible.
        :param tenancy: Property tenancy: Specifies whether to create an ECS instance on a dedicated host. Valid values: - **default**: does not create an ECS instance on a dedicated host. - **host**: creates an ECS instance on a dedicated host. If you do not specify **DedicatedHostId**, Alibaba Cloud selects a dedicated host for the ECS instance. Default value: **default**
        :param user_data: Property userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        :param zone_id: Property zoneId: The zone ID of the ECS instance.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be85fb0fd4f1e809db57a66f784b75c19396cdd108753cbbde82e04a20a72d09)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            check_type(argname="argument credit_specification", value=credit_specification, expected_type=type_hints["credit_specification"])
            check_type(argname="argument dedicated_host_id", value=dedicated_host_id, expected_type=type_hints["dedicated_host_id"])
            check_type(argname="argument deployment_set_id", value=deployment_set_id, expected_type=type_hints["deployment_set_id"])
            check_type(argname="argument disk_mappings", value=disk_mappings, expected_type=type_hints["disk_mappings"])
            check_type(argname="argument host_name", value=host_name, expected_type=type_hints["host_name"])
            check_type(argname="argument hpc_cluster_id", value=hpc_cluster_id, expected_type=type_hints["hpc_cluster_id"])
            check_type(argname="argument image_family", value=image_family, expected_type=type_hints["image_family"])
            check_type(argname="argument image_id", value=image_id, expected_type=type_hints["image_id"])
            check_type(argname="argument image_name", value=image_name, expected_type=type_hints["image_name"])
            check_type(argname="argument image_options_login_as_non_root", value=image_options_login_as_non_root, expected_type=type_hints["image_options_login_as_non_root"])
            check_type(argname="argument instance_description", value=instance_description, expected_type=type_hints["instance_description"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument instance_name", value=instance_name, expected_type=type_hints["instance_name"])
            check_type(argname="argument instance_pattern_infos", value=instance_pattern_infos, expected_type=type_hints["instance_pattern_infos"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument instance_type_overrides", value=instance_type_overrides, expected_type=type_hints["instance_type_overrides"])
            check_type(argname="argument instance_types", value=instance_types, expected_type=type_hints["instance_types"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument internet_max_bandwidth_in", value=internet_max_bandwidth_in, expected_type=type_hints["internet_max_bandwidth_in"])
            check_type(argname="argument internet_max_bandwidth_out", value=internet_max_bandwidth_out, expected_type=type_hints["internet_max_bandwidth_out"])
            check_type(argname="argument io_optimized", value=io_optimized, expected_type=type_hints["io_optimized"])
            check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
            check_type(argname="argument key_pair_name", value=key_pair_name, expected_type=type_hints["key_pair_name"])
            check_type(argname="argument load_balancer_weight", value=load_balancer_weight, expected_type=type_hints["load_balancer_weight"])
            check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument password_inherit", value=password_inherit, expected_type=type_hints["password_inherit"])
            check_type(argname="argument private_pool_options", value=private_pool_options, expected_type=type_hints["private_pool_options"])
            check_type(argname="argument ram_role_name", value=ram_role_name, expected_type=type_hints["ram_role_name"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument scaling_configuration_name", value=scaling_configuration_name, expected_type=type_hints["scaling_configuration_name"])
            check_type(argname="argument security_enhancement_strategy", value=security_enhancement_strategy, expected_type=type_hints["security_enhancement_strategy"])
            check_type(argname="argument security_group_id", value=security_group_id, expected_type=type_hints["security_group_id"])
            check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
            check_type(argname="argument spot_duration", value=spot_duration, expected_type=type_hints["spot_duration"])
            check_type(argname="argument spot_interruption_behavior", value=spot_interruption_behavior, expected_type=type_hints["spot_interruption_behavior"])
            check_type(argname="argument spot_price_limit", value=spot_price_limit, expected_type=type_hints["spot_price_limit"])
            check_type(argname="argument spot_price_limit_for_instance_type", value=spot_price_limit_for_instance_type, expected_type=type_hints["spot_price_limit_for_instance_type"])
            check_type(argname="argument spot_strategy", value=spot_strategy, expected_type=type_hints["spot_strategy"])
            check_type(argname="argument system_disk_auto_snapshot_policy_id", value=system_disk_auto_snapshot_policy_id, expected_type=type_hints["system_disk_auto_snapshot_policy_id"])
            check_type(argname="argument system_disk_bursting_enabled", value=system_disk_bursting_enabled, expected_type=type_hints["system_disk_bursting_enabled"])
            check_type(argname="argument system_disk_categories", value=system_disk_categories, expected_type=type_hints["system_disk_categories"])
            check_type(argname="argument system_disk_category", value=system_disk_category, expected_type=type_hints["system_disk_category"])
            check_type(argname="argument system_disk_description", value=system_disk_description, expected_type=type_hints["system_disk_description"])
            check_type(argname="argument system_disk_disk_name", value=system_disk_disk_name, expected_type=type_hints["system_disk_disk_name"])
            check_type(argname="argument system_disk_encrypt_algorithm", value=system_disk_encrypt_algorithm, expected_type=type_hints["system_disk_encrypt_algorithm"])
            check_type(argname="argument system_disk_encrypted", value=system_disk_encrypted, expected_type=type_hints["system_disk_encrypted"])
            check_type(argname="argument system_disk_kms_key_id", value=system_disk_kms_key_id, expected_type=type_hints["system_disk_kms_key_id"])
            check_type(argname="argument system_disk_performance_level", value=system_disk_performance_level, expected_type=type_hints["system_disk_performance_level"])
            check_type(argname="argument system_disk_provisioned_iops", value=system_disk_provisioned_iops, expected_type=type_hints["system_disk_provisioned_iops"])
            check_type(argname="argument system_disk_size", value=system_disk_size, expected_type=type_hints["system_disk_size"])
            check_type(argname="argument tag_list", value=tag_list, expected_type=type_hints["tag_list"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user_data", value=user_data, expected_type=type_hints["user_data"])
            check_type(argname="argument zone_id", value=zone_id, expected_type=type_hints["zone_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
        }
        if affinity is not None:
            self._values["affinity"] = affinity
        if cpu is not None:
            self._values["cpu"] = cpu
        if credit_specification is not None:
            self._values["credit_specification"] = credit_specification
        if dedicated_host_id is not None:
            self._values["dedicated_host_id"] = dedicated_host_id
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if image_family is not None:
            self._values["image_family"] = image_family
        if image_id is not None:
            self._values["image_id"] = image_id
        if image_name is not None:
            self._values["image_name"] = image_name
        if image_options_login_as_non_root is not None:
            self._values["image_options_login_as_non_root"] = image_options_login_as_non_root
        if instance_description is not None:
            self._values["instance_description"] = instance_description
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if instance_pattern_infos is not None:
            self._values["instance_pattern_infos"] = instance_pattern_infos
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if instance_type_overrides is not None:
            self._values["instance_type_overrides"] = instance_type_overrides
        if instance_types is not None:
            self._values["instance_types"] = instance_types
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if load_balancer_weight is not None:
            self._values["load_balancer_weight"] = load_balancer_weight
        if memory is not None:
            self._values["memory"] = memory
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if private_pool_options is not None:
            self._values["private_pool_options"] = private_pool_options
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if scaling_configuration_name is not None:
            self._values["scaling_configuration_name"] = scaling_configuration_name
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if spot_duration is not None:
            self._values["spot_duration"] = spot_duration
        if spot_interruption_behavior is not None:
            self._values["spot_interruption_behavior"] = spot_interruption_behavior
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_price_limit_for_instance_type is not None:
            self._values["spot_price_limit_for_instance_type"] = spot_price_limit_for_instance_type
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_auto_snapshot_policy_id is not None:
            self._values["system_disk_auto_snapshot_policy_id"] = system_disk_auto_snapshot_policy_id
        if system_disk_bursting_enabled is not None:
            self._values["system_disk_bursting_enabled"] = system_disk_bursting_enabled
        if system_disk_categories is not None:
            self._values["system_disk_categories"] = system_disk_categories
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_encrypt_algorithm is not None:
            self._values["system_disk_encrypt_algorithm"] = system_disk_encrypt_algorithm
        if system_disk_encrypted is not None:
            self._values["system_disk_encrypted"] = system_disk_encrypted
        if system_disk_kms_key_id is not None:
            self._values["system_disk_kms_key_id"] = system_disk_kms_key_id
        if system_disk_performance_level is not None:
            self._values["system_disk_performance_level"] = system_disk_performance_level
        if system_disk_provisioned_iops is not None:
            self._values["system_disk_provisioned_iops"] = system_disk_provisioned_iops
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tag_list is not None:
            self._values["tag_list"] = tag_list
        if tenancy is not None:
            self._values["tenancy"] = tenancy
        if user_data is not None:
            self._values["user_data"] = user_data
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: Scaling group id to create the scaling configuration.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def affinity(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property affinity: Specifies whether to associate an ECS instance on a dedicated host with the dedicated host.

        Valid values:

        - **default**: does not associate the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode and the original dedicated host has insufficient resources, the ECS instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
        - **host**: associates the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the ECS instance fails to start.
          Default value: **default**
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cpu(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property cpu: The number of vCPUs.

        You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set CPU to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
        **Note**: You can specify **Cpu** and **Memory** to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def credit_specification(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property creditSpecification: The performance mode of the burstable instance.

        Valid values:
        Standard: the standard mode.
        Unlimited: the unlimited mode.
        '''
        result = self._values.get("credit_specification")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def dedicated_host_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property dedicatedHostId: The ID of the dedicated host on which you want to create an ECS instance.

        You cannot create preemptible instances on dedicated hosts. If you specify **DedicatedHostId**, **SpotStrategy** and **SpotPriceLimit** are ignored.
        You can call the **DescribeDedicatedHosts** operation to query dedicated host IDs.
        '''
        result = self._values.get("dedicated_host_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deployment_set_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property deploymentSetId: Deployment set ID.'''
        result = self._values.get("deployment_set_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.DiskMappingsProperty]]]]:
        '''Property diskMappings: Disk mappings to attach to instance.'''
        result = self._values.get("disk_mappings")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.DiskMappingsProperty]]]], result)

    @builtins.property
    def host_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property hostName: The hostname of the ECS instance.

        The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
        Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
        Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        '''
        result = self._values.get("host_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def hpc_cluster_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property hpcClusterId: The HPC cluster ID to which the instance belongs.'''
        result = self._values.get("hpc_cluster_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_family(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property imageFamily: The name of the image family.

        You can configure this parameter to obtain the latest available images within the specified image family. The images are used to create ECS instances. If you have set the ImageId parameter, you cannot set the ImageFamily parameter.
        '''
        result = self._values.get("image_family")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property imageId: Image ID to create ecs instance .'''
        result = self._values.get("image_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property imageName: The name of the image.

        Each image name must be unique in a region. If you specify **ImageId**, **ImageName** is ignored.
        You cannot use **ImageName** to specify images that are purchased from Alibaba Cloud Marketplace.
        '''
        result = self._values.get("image_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def image_options_login_as_non_root(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property imageOptionsLoginAsNonRoot: Whether the ecs instance is logged in as ecs-user.Valid values: - **true** - **false** Default value: **false**.'''
        result = self._values.get("image_options_login_as_non_root")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceDescription: The description of the ECS instance.

        The description must be 2 to 256 characters in length. The description can contain letters and cannot start with http:// or https://.
        '''
        result = self._values.get("instance_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceId: Source ECS instance to copy configuration, if the properties is setting, Which will copy the InstanceType, ImageId, InternetChargeType, IoOptimized,UserData, KeyPairName, RamRoleName, InternetMaxBandwidthIn,InternetMaxBandwidthOut, and first security group id from source instance, you can also specify the relative properties to overwrite the properties copy from source instance id.'''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceName: The name of the instance launched from the current scaling configuration.'''
        result = self._values.get("instance_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_pattern_infos(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstancePatternInfosProperty]]]]:
        '''Property instancePatternInfos: Details of the intelligent configuration settings that determine the range of instance types that meet the specified criteria.'''
        result = self._values.get("instance_pattern_infos")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstancePatternInfosProperty]]]], result)

    @builtins.property
    def instance_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceType: ecs supported instance type.'''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_type_overrides(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstanceTypeOverridesProperty]]]]:
        '''Property instanceTypeOverrides: The instance types.'''
        result = self._values.get("instance_type_overrides")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstanceTypeOverridesProperty]]]], result)

    @builtins.property
    def instance_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property instanceTypes: ecs supported instance types.

        Length [1,10]. If InstanceTypes is specified,the InstanceType will be ignored.
        '''
        result = self._values.get("instance_types")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only.'''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_max_bandwidth_in(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetMaxBandwidthIn: Maximum incoming bandwidth from the public network, measured in Mbps (Mega bit per second).

        The value range is [1,200]. If this parameter value is not specified, AliyunAPI automatically sets the value to 200 Mbps.
        '''
        result = self._values.get("internet_max_bandwidth_in")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_max_bandwidth_out(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetMaxBandwidthOut: Maximum outgoing bandwidth from the public network, measured in Mbps (Mega bit per second).

        The value range for PayByBandwidth is [0,100]. If this parameter value is not specified, AliyunAPI automatically sets the value to 0 Mbps.
        The value range for PayByTraffic is [0,100]. If this parameter value is not specified, an error is reported
        '''
        result = self._values.get("internet_max_bandwidth_out")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def io_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ioOptimized: The 'optimized' instance can provide better IO performance.

        Support 'none' and 'optimized' only, default is 'none'.
        '''
        result = self._values.get("io_optimized")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ipv6_address_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ipv6AddressCount: The number of randomly generated IPv6 addresses to be assigned to the elastic network interface (ENI).'''
        result = self._values.get("ipv6_address_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def key_pair_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property keyPairName: SSH key pair name.'''
        result = self._values.get("key_pair_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def load_balancer_weight(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property loadBalancerWeight: The weight of the ECS instance as a backend server.

        Valid values: 1 to 100.
        Default value: 50.
        '''
        result = self._values.get("load_balancer_weight")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def memory(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property memory: The memory size.

        Unit: GiB.
        You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
        **Note**: You can specify **Cpu** and **Memory** to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
        '''
        result = self._values.get("memory")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def password(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property password: Password of created ecs instance.

        Must contain at least 3 types of special character, lower character, upper character, number.
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property passwordInherit: Whether to use the password pre-configured in the image you select or not.

        When PasswordInherit is specified, the Password must be null. For a secure access, make sure that the selected image has password configured.
        '''
        result = self._values.get("password_inherit")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def private_pool_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.PrivatePoolOptionsProperty]]:
        '''Property privatePoolOptions: Option settings for private pools.'''
        result = self._values.get("private_pool_options")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.PrivatePoolOptionsProperty]], result)

    @builtins.property
    def ram_role_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ramRoleName: Instance RAM role name.

        The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        '''
        result = self._values.get("ram_role_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: Resource group id.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_configuration_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scalingConfigurationName: Name of created scaling configuration.'''
        result = self._values.get("scaling_configuration_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_enhancement_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property securityEnhancementStrategy: Specifies whether to enable security hardening.

        Valid values:

        - **Active**: enables security hardening. This value is applicable only to public images.
        - **Deactive**: disables security hardening. This value is applicable to all image types.
        '''
        result = self._values.get("security_enhancement_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property securityGroupId: Security Group to create ecs instance.'''
        result = self._values.get("security_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property securityGroupIds: The IDs of the security groups with which you want to associate the ECS instances that are created by using the scaling configuration.

        **Note**: If you specify **SecurityGroupId**, you cannot specify **SecurityGroupIds**.
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def spot_duration(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotDuration: The retention period of the preemptible instance.

        Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
        If you set this parameter to 0, no protection period is specified for the preemptible instance.
        Default value: 1
        '''
        result = self._values.get("spot_duration")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_interruption_behavior(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotInterruptionBehavior: The interruption mode of the preemptible instance.

        Default value: Terminate. Set the value to Terminate. This value specifies that the preemptible instance is to be released.
        '''
        result = self._values.get("spot_interruption_behavior")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_price_limit(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotPriceLimit: Set the hourly maximum price for the instance.

        Supports a maximum of 3 decimal places, and the parameter takes effect only when the value of SpotStrategy is SpotWithPriceLimit.It is a default value for all instance types, and can be overwrite by SpotPriceLimitForInstanceType
        '''
        result = self._values.get("spot_price_limit")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_price_limit_for_instance_type(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        '''Property spotPriceLimitForInstanceType: Set the hourly maximum price for the instance of specified instance type.

        The parameter takes effect only when the value of SpotStrategy is SpotWithPriceLimit.
        You should input the information of the tag with the format of the Key-Value, such as {"key1":"value1","key2":"value2", ... "key5":"value5"}.
        At most 50 items can be specified.
        Key
        ecs instance type
        Value
        Supports a maximum of 3 decimal places.
        '''
        result = self._values.get("spot_price_limit_for_instance_type")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]], result)

    @builtins.property
    def spot_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotStrategy: Preemption strategy for post-paid instances.

        It takes effect when the parameter InstanceChargeType takes the value of PostPaid. Ranges:
        NoSpot: Normal pay-per-use instance
        SpotWithPriceLimit: Set a preemptive instance of the cap price
        SpotAsPriceGo: System automatic bidding, following the current market actual price
        Default: NoSpot.
        '''
        result = self._values.get("spot_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_auto_snapshot_policy_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.'''
        result = self._values.get("system_disk_auto_snapshot_policy_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_bursting_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskBurstingEnabled: Specifies whether to enable the burst feature for the system disk.

        Valid values:

        - **true**
        - **false**
          **Note**: This parameter is available only if you set **SystemDiskCategory** to **cloud_auto**.
        '''
        result = self._values.get("system_disk_bursting_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_categories(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property systemDiskCategories: The categories of the system disks.

        If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:

        - **cloud**: basic disk
        - **cloud_efficiency**: ultra disk
        - **cloud_ssd**: standard SSD
        - **cloud_essd**: ESSD
          **Note**: If you specify **SystemDiskCategories**, you cannot specify **SystemDiskCategory**.
        '''
        result = self._values.get("system_disk_categories")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def system_disk_category(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskCategory: Category of system disk.

        Default is cloud.support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd|cloud_auto
        '''
        result = self._values.get("system_disk_category")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskDescription: The description of the system disk.

        The description must be 2 to 256 characters in length. The description can contain letters and cannot start with http:// or https://.
        '''
        result = self._values.get("system_disk_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_disk_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskDiskName: The name of the system disk.

        The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        '''
        result = self._values.get("system_disk_disk_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_encrypt_algorithm(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskEncryptAlgorithm: The encryption algorithm that you want to use to encrypt the system disk.

        Valid values:

        - **AES-256**
        - **SM4-128**
          Default value: **AES-256**
        '''
        result = self._values.get("system_disk_encrypt_algorithm")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskEncrypted: Specifies whether to encrypt the system disk.

        Valid values:

        - **true**
        - **false**
          Default value: **false**
        '''
        result = self._values.get("system_disk_encrypted")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_kms_key_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskKmsKeyId: The ID of the KMS key that you want to use to encrypt the system disk.'''
        result = self._values.get("system_disk_kms_key_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_performance_level(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskPerformanceLevel: The performance level of an ESSD.'''
        result = self._values.get("system_disk_performance_level")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_provisioned_iops(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskProvisionedIops: The IOPS metric that is preconfigured for the system disk.

        **Note**: IOPS measures the number of read and write operations that an EBS device can process per second.
        '''
        result = self._values.get("system_disk_provisioned_iops")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def system_disk_size(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property systemDiskSize: Size of system disk.

        Unit is GB.
        '''
        result = self._values.get("system_disk_size")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tag_list(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.TagListProperty]]]]:
        '''Property tagList: The tags of an instance in list format.

        Do not use with Tags at the same time.
        You should input the information of the tag with the format of Key-Value list, such as [{"Key":"key1","Value":"value1"}, ...].
        At most 20 tags can be specified.
        Key
        It can be up to 64 characters in length.
        Cannot begin with aliyun.
        Cannot begin with http:// or https://.
        Cannot be a null string.
        Value
        It can be up to 128 characters in length.
        Cannot begin with aliyun.
        Cannot begin with http:// or https://.
        Can be a null string.If less then 20 tags are specified, ros will add a tag(Key: "ros-aliyun-created", Value:"<resource_name>*stack*<stack_id>") if possible.
        '''
        result = self._values.get("tag_list")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.TagListProperty]]]], result)

    @builtins.property
    def tenancy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property tenancy: Specifies whether to create an ECS instance on a dedicated host.

        Valid values:

        - **default**: does not create an ECS instance on a dedicated host.
        - **host**: creates an ECS instance on a dedicated host. If you do not specify **DedicatedHostId**, Alibaba Cloud selects a dedicated host for the ECS instance.
          Default value: **default**
        '''
        result = self._values.get("tenancy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def user_data(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property userData: User data to pass to instance.

        [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def zone_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property zoneId: The zone ID of the ECS instance.'''
        result = self._values.get("zone_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ScalingConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ScalingGroup(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.ScalingGroup",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::ScalingGroup``, which is used to create a scaling group.

    A scaling group is a group of Elastic Compute Service (ECS) instances that are dynamically scaled based on the configured scenario. A scaling group does not immediately take effect after it is created. You must use ALIYUN::ESS::ScalingGroupEnable to enable the scaling group to trigger scaling activities and execute scaling rules.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosScalingGroup``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalinggroup
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["ScalingGroupProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68b84de07d5e2051623b6d18059552a6bcb0125c57e505bde03ea2c19f8aec8d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingGroupId: Scaling group Id.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupName")
    def attr_scaling_group_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingGroupName: Scaling group name.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupName"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7b16117c87ba7bd7a0d4f0b467240c6c2cbf2a39cd3fa024d78fe5101658d25)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc16af027ada6422aba14a6b5bb4c99a9742633e2983ff20aa15a32fe5ac6632)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "ScalingGroupProps":
        return typing.cast("ScalingGroupProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "ScalingGroupProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f758a095c4694bfb65eb64992aaf4de500dd9bb7a591df22314cbb54ad5c8469)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea2e9341d1fe7ce40ea43705013012e95bc0d18b5e7c4ce3536921fc4d5d3dfc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


class ScalingGroupEnable(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.ScalingGroupEnable",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::ScalingGroupEnable``, which is used to enable a scaling group.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosScalingGroupEnable``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalinggroupenable
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["ScalingGroupEnableProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d396c56ec076a081bf3195c789f7b407df745b52da435f8622a04bc50a684ec9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrLifecycleState")
    def attr_lifecycle_state(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute LifecycleState: The scaling group status.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrLifecycleState"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingGroupId: The scaling group id.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingInstanceDetails")
    def attr_scaling_instance_details(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingInstanceDetails: Detail information of auto created scaling instances.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingInstanceDetails"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingInstances")
    def attr_scaling_instances(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingInstances: The auto created scaling instances.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingInstances"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleArisExecuteErrorInfo")
    def attr_scaling_rule_aris_execute_error_info(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingRuleArisExecuteErrorInfo: The error info of the execution of scaling rule aris.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleArisExecuteErrorInfo"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleArisExecuteResultInstancesAdded")
    def attr_scaling_rule_aris_execute_result_instances_added(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingRuleArisExecuteResultInstancesAdded: Instances added via the execution of scaling rule aris.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleArisExecuteResultInstancesAdded"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleArisExecuteResultInstancesRemoved")
    def attr_scaling_rule_aris_execute_result_instances_removed(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingRuleArisExecuteResultInstancesRemoved: Instances removed via the execution of scaling rule aris.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleArisExecuteResultInstancesRemoved"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleArisExecuteResultNumberOfAddedInstances")
    def attr_scaling_rule_aris_execute_result_number_of_added_instances(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingRuleArisExecuteResultNumberOfAddedInstances: The number of added vm via the execution of scaling rule aris.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleArisExecuteResultNumberOfAddedInstances"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ad26d452cacf826b1d10c8b88038291eaff1a2bf26ae45fa3b8ff686391c979)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9fd7cae9848d5a2d39df88ce26d58239a5ae15a5b0986ec2eeba31e427b8e0b6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "ScalingGroupEnableProps":
        return typing.cast("ScalingGroupEnableProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "ScalingGroupEnableProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c369196601919501d33ecdc6fe8876eeba30b688433c7cdaa444b3c268f152e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78370563c4e134077d20c9c76a9db5098dab5338908e2af8d2a822f6c553c1f3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.ScalingGroupEnableProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "attach_options": "attachOptions",
        "detach_options": "detachOptions",
        "instance_ids": "instanceIds",
        "remove_instance_ids": "removeInstanceIds",
        "scaling_configuration_id": "scalingConfigurationId",
        "scaling_rule_aris": "scalingRuleAris",
        "scaling_rule_aris_execute_version": "scalingRuleArisExecuteVersion",
    },
)
class ScalingGroupEnableProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        attach_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroupEnable.AttachOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        detach_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroupEnable.DetachOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        remove_instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        scaling_configuration_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_rule_aris: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        scaling_rule_aris_execute_version: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``ScalingGroupEnable``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalinggroupenable

        :param scaling_group_id: Property scalingGroupId: The id of operated scaling group.
        :param attach_options: Property attachOptions: Options for attaching instances.
        :param detach_options: Property detachOptions: Options for detaching instances.
        :param instance_ids: Property instanceIds: The id list of ECS instance which will be attached. Max support 1000 instances.
        :param remove_instance_ids: Property removeInstanceIds: The id list of ECS instance which will be removed. Max support 1000 instances.
        :param scaling_configuration_id: Property scalingConfigurationId: The id of scaling configuration which will be activate.
        :param scaling_rule_aris: Property scalingRuleAris: A list of scaling rule aris which will be executed. Max support 10 scaling rule aris. When creating the resource, all the scaling rule aris in the list will be executed. When updating the resource, none of scaling rule aris in the list will be executed, unless ScalingRuleArisExecuteVersion is changed.
        :param scaling_rule_aris_execute_version: Property scalingRuleArisExecuteVersion: The change of the property leads to the execution of all the scaling rule aris in ScalingRuleAris.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27aa303aa686a6ae2cb5d268aa52c8632e0533ee95ea0d8c480839bc60d34365)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument attach_options", value=attach_options, expected_type=type_hints["attach_options"])
            check_type(argname="argument detach_options", value=detach_options, expected_type=type_hints["detach_options"])
            check_type(argname="argument instance_ids", value=instance_ids, expected_type=type_hints["instance_ids"])
            check_type(argname="argument remove_instance_ids", value=remove_instance_ids, expected_type=type_hints["remove_instance_ids"])
            check_type(argname="argument scaling_configuration_id", value=scaling_configuration_id, expected_type=type_hints["scaling_configuration_id"])
            check_type(argname="argument scaling_rule_aris", value=scaling_rule_aris, expected_type=type_hints["scaling_rule_aris"])
            check_type(argname="argument scaling_rule_aris_execute_version", value=scaling_rule_aris_execute_version, expected_type=type_hints["scaling_rule_aris_execute_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
        }
        if attach_options is not None:
            self._values["attach_options"] = attach_options
        if detach_options is not None:
            self._values["detach_options"] = detach_options
        if instance_ids is not None:
            self._values["instance_ids"] = instance_ids
        if remove_instance_ids is not None:
            self._values["remove_instance_ids"] = remove_instance_ids
        if scaling_configuration_id is not None:
            self._values["scaling_configuration_id"] = scaling_configuration_id
        if scaling_rule_aris is not None:
            self._values["scaling_rule_aris"] = scaling_rule_aris
        if scaling_rule_aris_execute_version is not None:
            self._values["scaling_rule_aris_execute_version"] = scaling_rule_aris_execute_version

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: The id of operated scaling group.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def attach_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.AttachOptionsProperty]]:
        '''Property attachOptions: Options for attaching instances.'''
        result = self._values.get("attach_options")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.AttachOptionsProperty]], result)

    @builtins.property
    def detach_options(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.DetachOptionsProperty]]:
        '''Property detachOptions: Options for detaching instances.'''
        result = self._values.get("detach_options")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.DetachOptionsProperty]], result)

    @builtins.property
    def instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property instanceIds: The id list of ECS instance which will be attached.

        Max support 1000 instances.
        '''
        result = self._values.get("instance_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def remove_instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property removeInstanceIds: The id list of ECS instance which will be removed.

        Max support 1000 instances.
        '''
        result = self._values.get("remove_instance_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def scaling_configuration_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scalingConfigurationId: The id of scaling configuration which will be activate.'''
        result = self._values.get("scaling_configuration_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_rule_aris(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property scalingRuleAris: A list of scaling rule aris which will be executed.

        Max support 10 scaling rule aris.
        When creating the resource, all the scaling rule aris in the list will be executed.
        When updating the resource, none of scaling rule aris in the list will be executed, unless ScalingRuleArisExecuteVersion is changed.
        '''
        result = self._values.get("scaling_rule_aris")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def scaling_rule_aris_execute_version(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scalingRuleArisExecuteVersion: The change of the property leads to the execution of all the scaling rule aris in ScalingRuleAris.'''
        result = self._values.get("scaling_rule_aris_execute_version")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ScalingGroupEnableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.ScalingGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "max_size": "maxSize",
        "min_size": "minSize",
        "allocation_strategy": "allocationStrategy",
        "az_balance": "azBalance",
        "compensate_with_on_demand": "compensateWithOnDemand",
        "container_group_id": "containerGroupId",
        "custom_policy_arn": "customPolicyArn",
        "db_instance_ids": "dbInstanceIds",
        "default_cooldown": "defaultCooldown",
        "desired_capacity": "desiredCapacity",
        "group_deletion_protection": "groupDeletionProtection",
        "group_type": "groupType",
        "health_check_type": "healthCheckType",
        "instance_id": "instanceId",
        "launch_template_id": "launchTemplateId",
        "launch_template_overrides": "launchTemplateOverrides",
        "launch_template_version": "launchTemplateVersion",
        "load_balancer_ids": "loadBalancerIds",
        "max_instance_lifetime": "maxInstanceLifetime",
        "multi_az_policy": "multiAzPolicy",
        "notification_configurations": "notificationConfigurations",
        "on_demand_base_capacity": "onDemandBaseCapacity",
        "on_demand_percentage_above_base_capacity": "onDemandPercentageAboveBaseCapacity",
        "protected_instances": "protectedInstances",
        "removal_policys": "removalPolicys",
        "resource_group_id": "resourceGroupId",
        "scaling_group_name": "scalingGroupName",
        "scaling_policy": "scalingPolicy",
        "server_groups": "serverGroups",
        "spot_allocation_strategy": "spotAllocationStrategy",
        "spot_instance_pools": "spotInstancePools",
        "spot_instance_remedy": "spotInstanceRemedy",
        "standby_instances": "standbyInstances",
        "tags": "tags",
        "v_switch_id": "vSwitchId",
        "v_switch_ids": "vSwitchIds",
    },
)
class ScalingGroupProps:
    def __init__(
        self,
        *,
        max_size: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        min_size: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        allocation_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        az_balance: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        compensate_with_on_demand: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        container_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        custom_policy_arn: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        db_instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        default_cooldown: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        desired_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        group_deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        group_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        launch_template_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        launch_template_overrides: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.LaunchTemplateOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        launch_template_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        load_balancer_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        max_instance_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        multi_az_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        notification_configurations: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.NotificationConfigurationsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        on_demand_base_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        on_demand_percentage_above_base_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        protected_instances: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        removal_policys: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_group_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        server_groups: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.ServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        spot_allocation_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_instance_pools: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spot_instance_remedy: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        standby_instances: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosScalingGroup.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        v_switch_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ) -> None:
        '''Properties for defining a ``ScalingGroup``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalinggroup

        :param max_size: Property maxSize: Maximum number of ECS instances in the scaling group. Value range: [0, 2000].
        :param min_size: Property minSize: Minimum number of ECS instances in the scaling group. Value range: [0, 2000].
        :param allocation_strategy: Property allocationStrategy: The allocation policy of instances. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values: - priority: Auto Scaling selects instance types based on the specified order to create the required number of instances. - lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances. Default value: priority.
        :param az_balance: Property azBalance: Specifies whether to evenly distribute instances in the scaling group across multiple zones. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values: - true - false Default value: false.
        :param compensate_with_on_demand: Property compensateWithOnDemand: Specifies whether to automatically create pay-as-you-go instances to meet the requirements on the number of instances when the expected capacity of preemptible instances cannot be fulfilled due to reasons such as high prices or insufficient resources. This parameter takes effect only when MultiAZPolicy is set to COST_OPTIMIZED. Default value: true.
        :param container_group_id: Property containerGroupId: The ID of the elastic container instance.
        :param custom_policy_arn: Property customPolicyArn: The Alibaba Cloud Resource Name (ARN) of the custom scale-in policy (Function). This parameter takes effect only if you specify CustomPolicy as the value of first item of RemovalPolicys.
        :param db_instance_ids: Property dbInstanceIds: ID list of an RDS instance. A Json Array with format: [ "rm-id0", "rm-id1", ... "rm-idz" ], support up to 100 RDS instance.
        :param default_cooldown: Property defaultCooldown: Default cool-down time (in seconds) of the scaling group. Value range: [0, 86400]. The default value is 300s.
        :param desired_capacity: Property desiredCapacity: The expected number of ECS instances in a scaling group. The scaling group automatically keeps the number of ECS instances as expected. The number of ECS instances cannot be greater than the value of MaxSize and cannot be less than the value of MinSize.
        :param group_deletion_protection: Property groupDeletionProtection: Whether to enable deletion protection for scaling group. Default to False.
        :param group_type: Property groupType: The type of instances that are managed by the scaling group. Valid values: ECS ECI Default value: ECS.
        :param health_check_type: Property healthCheckType: The health check type. Allow values is "ECS" and "NONE", default to "ECS".
        :param instance_id: Property instanceId: The ID of the ECS instance from which the scaling group obtains configuration information of the specified instance.
        :param launch_template_id: Property launchTemplateId: The ID of the instance launch template from which the scaling group obtains launch configurations.
        :param launch_template_overrides: Property launchTemplateOverrides: You can specify up to 10 overrides. Note: This parameter takes effect only if you specify LaunchTemplateId.
        :param launch_template_version: Property launchTemplateVersion: The version of the instance launch template. Valid values: A fixed template version numbe. Default: The default template version is always used. Latest: The latest template version is always used.
        :param load_balancer_ids: Property loadBalancerIds: ID list of a Server Load Balancer instance. A Json Array with format: [ "lb-id0", "lb-id1", ... "lb-idz" ], support up to 100 Load Balancer instance.
        :param max_instance_lifetime: Property maxInstanceLifetime: The maximum life span of an ECS instance in the scaling group. Unit: seconds. Valid values: 86400 to the value of Integer.maxValue. Default value: null. Note: This parameter is unavailable for scaling groups of the ECI type or scaling groups whose ScalingPolicy is set to recycle.
        :param multi_az_policy: Property multiAzPolicy: ECS scaling strategy for multi availability zone. Allow value: 1. PRIORITY: scaling the capacity according to the virtual switch (VSwitchIds.N) you define. ECS instances are automatically created using the next priority virtual switch when the higher priority virtual switch cannot be created in the available zone. 2. BALANCE: evenly allocate ECS instances between the multiple available zone specified by the scaling group. 3. COST_OPTIMIZED: During a scale-out activity, Auto Scaling attempts to create ECS instances that have vCPUs provided at the lowest price. During a scale-in activity, Auto Scaling attempts to remove ECS instances that have vCPUs provided at the highest price. Preemptible instances are preferentially created when preemptible instance types are specified in the active scaling configuration. You can configure the CompensateWithOnDemand parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources. Note COST_OPTIMIZED is valid when multiple instance types are specified or at least one preemptible instance type is specified. 4. COMPOSABLE: You can flexibly combine the preceding policies based on your business requirements.
        :param notification_configurations: Property notificationConfigurations: When a scaling event occurs in a scaling group, ESS will send a notification to Cloud Monitor or MNS.
        :param on_demand_base_capacity: Property onDemandBaseCapacity: The minimum number of pay-as-you-go instances required in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances. If you set MultiAZPolicy to COMPOSABLE Policy, the default value of this parameter is 0.
        :param on_demand_percentage_above_base_capacity: Property onDemandPercentageAboveBaseCapacity: The percentage of pay-as-you-go instances that can be created when instances are added to the scaling group. This parameter takes effect when the number of pay-as-you-go instances reaches the value for the OnDemandBaseCapacity parameter. Valid values: 0 to 100. If you set MultiAZPolicy to COMPOSABLE, the default value of this parameter is 100.
        :param protected_instances: Property protectedInstances: ECS instances of protected mode in the scaling group.
        :param removal_policys: Property removalPolicys: Policy for removing ECS instances from the scaling group. Optional values: - OldestInstance: removes the first ECS instance attached to the scaling group. - NewestInstance: removes the first ECS instance attached to the scaling group. - OldestScalingConfiguration: removes the ECS instance with the oldest scaling configuration. - CustomPolicy: removes ECS instances based on the custom scale-in policy (Function). You can enter up to three removal policies. You cannot set any item of RemovalPolicys to the same value. The scaling configuration source specified by the OldestScalingConfiguration setting can be a scaling configuration or a launch template. You can specify CustomPolicy only as the value of first item of RemovalPolicys. If you set first item of RemovalPolicys to CustomPolicy, you must also specify CustomPolicyARN. Note: The removal of ECS instances from a scaling group is also affected by the value of MultiAZPolicy.
        :param resource_group_id: Property resourceGroupId: Resource group id.
        :param scaling_group_name: Property scalingGroupName: Name shown for the scaling group, which must contain 2-40 characters (English or Chinese). The name must begin with a number, an upper/lower-case letter or a Chinese character and may contain numbers, "_", "-" or ".". The account name is unique in the same region. If this parameter is not specified, the default value is ScalingGroupId.
        :param scaling_policy: Property scalingPolicy: The reclaim mode of the scaling group. Valid values: recycle release forcerelease ScalingPolicy specifies the reclaim modes of scaling groups, but the policy that is used to remove ECS instances from scaling groups is determined by the RemovePolicy parameter of the RemoveInstances operation.
        :param server_groups: Property serverGroups: The config of server group.
        :param spot_allocation_strategy: Property spotAllocationStrategy: The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values: - priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances. - lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances. Default value: priority.
        :param spot_instance_pools: Property spotInstancePools: The number of instance types that are available. The system creates preemptible instances of multiple instance types that are available at the lowest cost in the scaling group. Valid values: 1 to 10. If you set MultiAZPolicy to COMPOSABLE, the default value of this parameter is 2.
        :param spot_instance_remedy: Property spotInstanceRemedy: Specifies whether to supplement preemptible instances. If this parameter is set to true, Auto Scaling attempts to create an instance to replace a preemptible instance when Auto Scaling receives a system message which indicates that the preemptible instance is to be reclaimed.
        :param standby_instances: Property standbyInstances: ECS instances of standby mode in the scaling group.
        :param tags: Property tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        :param v_switch_id: Property vSwitchId: If you create a VPC scaling group, you must specify the ID of a VSwitch.
        :param v_switch_ids: Property vSwitchIds: Parameter VSwitchIds.N is used to create instance in multiple zones. Parameter VSwitchIds.N has a priority over parameter VSwitchId. The valid range of N is [1, 8], and you can specify at most 5 VSwitches in a VPC. The priority of VSwitches descends from 1 to 8, and 1 indicates the highest priority. When you fail to create an instance in the zone to which a specified VSwitch belongs, another VSwitch with less priority replaces the specified one automatically.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6837af1a639272cbc496040a393943d064eb5b0b946dc9e706e4ca881d10b4ba)
            check_type(argname="argument max_size", value=max_size, expected_type=type_hints["max_size"])
            check_type(argname="argument min_size", value=min_size, expected_type=type_hints["min_size"])
            check_type(argname="argument allocation_strategy", value=allocation_strategy, expected_type=type_hints["allocation_strategy"])
            check_type(argname="argument az_balance", value=az_balance, expected_type=type_hints["az_balance"])
            check_type(argname="argument compensate_with_on_demand", value=compensate_with_on_demand, expected_type=type_hints["compensate_with_on_demand"])
            check_type(argname="argument container_group_id", value=container_group_id, expected_type=type_hints["container_group_id"])
            check_type(argname="argument custom_policy_arn", value=custom_policy_arn, expected_type=type_hints["custom_policy_arn"])
            check_type(argname="argument db_instance_ids", value=db_instance_ids, expected_type=type_hints["db_instance_ids"])
            check_type(argname="argument default_cooldown", value=default_cooldown, expected_type=type_hints["default_cooldown"])
            check_type(argname="argument desired_capacity", value=desired_capacity, expected_type=type_hints["desired_capacity"])
            check_type(argname="argument group_deletion_protection", value=group_deletion_protection, expected_type=type_hints["group_deletion_protection"])
            check_type(argname="argument group_type", value=group_type, expected_type=type_hints["group_type"])
            check_type(argname="argument health_check_type", value=health_check_type, expected_type=type_hints["health_check_type"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument launch_template_id", value=launch_template_id, expected_type=type_hints["launch_template_id"])
            check_type(argname="argument launch_template_overrides", value=launch_template_overrides, expected_type=type_hints["launch_template_overrides"])
            check_type(argname="argument launch_template_version", value=launch_template_version, expected_type=type_hints["launch_template_version"])
            check_type(argname="argument load_balancer_ids", value=load_balancer_ids, expected_type=type_hints["load_balancer_ids"])
            check_type(argname="argument max_instance_lifetime", value=max_instance_lifetime, expected_type=type_hints["max_instance_lifetime"])
            check_type(argname="argument multi_az_policy", value=multi_az_policy, expected_type=type_hints["multi_az_policy"])
            check_type(argname="argument notification_configurations", value=notification_configurations, expected_type=type_hints["notification_configurations"])
            check_type(argname="argument on_demand_base_capacity", value=on_demand_base_capacity, expected_type=type_hints["on_demand_base_capacity"])
            check_type(argname="argument on_demand_percentage_above_base_capacity", value=on_demand_percentage_above_base_capacity, expected_type=type_hints["on_demand_percentage_above_base_capacity"])
            check_type(argname="argument protected_instances", value=protected_instances, expected_type=type_hints["protected_instances"])
            check_type(argname="argument removal_policys", value=removal_policys, expected_type=type_hints["removal_policys"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument scaling_group_name", value=scaling_group_name, expected_type=type_hints["scaling_group_name"])
            check_type(argname="argument scaling_policy", value=scaling_policy, expected_type=type_hints["scaling_policy"])
            check_type(argname="argument server_groups", value=server_groups, expected_type=type_hints["server_groups"])
            check_type(argname="argument spot_allocation_strategy", value=spot_allocation_strategy, expected_type=type_hints["spot_allocation_strategy"])
            check_type(argname="argument spot_instance_pools", value=spot_instance_pools, expected_type=type_hints["spot_instance_pools"])
            check_type(argname="argument spot_instance_remedy", value=spot_instance_remedy, expected_type=type_hints["spot_instance_remedy"])
            check_type(argname="argument standby_instances", value=standby_instances, expected_type=type_hints["standby_instances"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
            check_type(argname="argument v_switch_ids", value=v_switch_ids, expected_type=type_hints["v_switch_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "max_size": max_size,
            "min_size": min_size,
        }
        if allocation_strategy is not None:
            self._values["allocation_strategy"] = allocation_strategy
        if az_balance is not None:
            self._values["az_balance"] = az_balance
        if compensate_with_on_demand is not None:
            self._values["compensate_with_on_demand"] = compensate_with_on_demand
        if container_group_id is not None:
            self._values["container_group_id"] = container_group_id
        if custom_policy_arn is not None:
            self._values["custom_policy_arn"] = custom_policy_arn
        if db_instance_ids is not None:
            self._values["db_instance_ids"] = db_instance_ids
        if default_cooldown is not None:
            self._values["default_cooldown"] = default_cooldown
        if desired_capacity is not None:
            self._values["desired_capacity"] = desired_capacity
        if group_deletion_protection is not None:
            self._values["group_deletion_protection"] = group_deletion_protection
        if group_type is not None:
            self._values["group_type"] = group_type
        if health_check_type is not None:
            self._values["health_check_type"] = health_check_type
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_overrides is not None:
            self._values["launch_template_overrides"] = launch_template_overrides
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if load_balancer_ids is not None:
            self._values["load_balancer_ids"] = load_balancer_ids
        if max_instance_lifetime is not None:
            self._values["max_instance_lifetime"] = max_instance_lifetime
        if multi_az_policy is not None:
            self._values["multi_az_policy"] = multi_az_policy
        if notification_configurations is not None:
            self._values["notification_configurations"] = notification_configurations
        if on_demand_base_capacity is not None:
            self._values["on_demand_base_capacity"] = on_demand_base_capacity
        if on_demand_percentage_above_base_capacity is not None:
            self._values["on_demand_percentage_above_base_capacity"] = on_demand_percentage_above_base_capacity
        if protected_instances is not None:
            self._values["protected_instances"] = protected_instances
        if removal_policys is not None:
            self._values["removal_policys"] = removal_policys
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if scaling_group_name is not None:
            self._values["scaling_group_name"] = scaling_group_name
        if scaling_policy is not None:
            self._values["scaling_policy"] = scaling_policy
        if server_groups is not None:
            self._values["server_groups"] = server_groups
        if spot_allocation_strategy is not None:
            self._values["spot_allocation_strategy"] = spot_allocation_strategy
        if spot_instance_pools is not None:
            self._values["spot_instance_pools"] = spot_instance_pools
        if spot_instance_remedy is not None:
            self._values["spot_instance_remedy"] = spot_instance_remedy
        if standby_instances is not None:
            self._values["standby_instances"] = standby_instances
        if tags is not None:
            self._values["tags"] = tags
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if v_switch_ids is not None:
            self._values["v_switch_ids"] = v_switch_ids

    @builtins.property
    def max_size(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property maxSize: Maximum number of ECS instances in the scaling group.

        Value range: [0, 2000].
        '''
        result = self._values.get("max_size")
        assert result is not None, "Required property 'max_size' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def min_size(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property minSize: Minimum number of ECS instances in the scaling group.

        Value range: [0, 2000].
        '''
        result = self._values.get("min_size")
        assert result is not None, "Required property 'min_size' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def allocation_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property allocationStrategy: The allocation policy of instances.

        Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - priority: Auto Scaling selects instance types based on the specified order to create the required number of instances.
        - lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.
          Default value: priority.
        '''
        result = self._values.get("allocation_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def az_balance(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property azBalance: Specifies whether to evenly distribute instances in the scaling group across multiple zones.

        This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - true
        - false
          Default value: false.
        '''
        result = self._values.get("az_balance")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def compensate_with_on_demand(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property compensateWithOnDemand: Specifies whether to automatically create pay-as-you-go instances to meet the requirements on the number of instances when the expected capacity of preemptible instances cannot be fulfilled due to reasons such as high prices or insufficient resources.

        This parameter takes effect only when MultiAZPolicy is set to COST_OPTIMIZED.
        Default value: true.
        '''
        result = self._values.get("compensate_with_on_demand")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def container_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property containerGroupId: The ID of the elastic container instance.'''
        result = self._values.get("container_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def custom_policy_arn(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property customPolicyArn: The Alibaba Cloud Resource Name (ARN) of the custom scale-in policy (Function).

        This parameter takes effect only if you specify CustomPolicy as the value of first item of RemovalPolicys.
        '''
        result = self._values.get("custom_policy_arn")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def db_instance_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property dbInstanceIds: ID list of an RDS instance.

        A Json Array with format: [ "rm-id0", "rm-id1", ... "rm-idz" ], support up to 100 RDS instance.
        '''
        result = self._values.get("db_instance_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def default_cooldown(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property defaultCooldown: Default cool-down time (in seconds) of the scaling group.

        Value range: [0, 86400].
        The default value is 300s.
        '''
        result = self._values.get("default_cooldown")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def desired_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property desiredCapacity: The expected number of ECS instances in a scaling group.

        The scaling group automatically keeps the number of ECS instances as expected. The number of ECS instances cannot be greater than the value of MaxSize and cannot be less than the value of MinSize.
        '''
        result = self._values.get("desired_capacity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def group_deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property groupDeletionProtection: Whether to enable deletion protection for scaling group.

        Default to False.
        '''
        result = self._values.get("group_deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def group_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property groupType: The type of instances that are managed by the scaling group.

        Valid values:
        ECS
        ECI
        Default value: ECS.
        '''
        result = self._values.get("group_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property healthCheckType: The health check type.

        Allow values is "ECS" and "NONE", default to "ECS".
        '''
        result = self._values.get("health_check_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceId: The ID of the ECS instance from which the scaling group obtains configuration information of the specified instance.'''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def launch_template_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property launchTemplateId: The ID of the instance launch template from which the scaling group obtains launch configurations.'''
        result = self._values.get("launch_template_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def launch_template_overrides(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.LaunchTemplateOverridesProperty]]]]:
        '''Property launchTemplateOverrides: You can specify up to 10 overrides.

        Note: This parameter takes effect only if you specify LaunchTemplateId.
        '''
        result = self._values.get("launch_template_overrides")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.LaunchTemplateOverridesProperty]]]], result)

    @builtins.property
    def launch_template_version(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property launchTemplateVersion: The version of the instance launch template.

        Valid values:
        A fixed template version numbe.
        Default: The default template version is always used.
        Latest: The latest template version is always used.
        '''
        result = self._values.get("launch_template_version")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def load_balancer_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property loadBalancerIds: ID list of a Server Load Balancer instance.

        A Json Array with format: [ "lb-id0", "lb-id1", ... "lb-idz" ], support up to 100 Load Balancer instance.
        '''
        result = self._values.get("load_balancer_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def max_instance_lifetime(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property maxInstanceLifetime: The maximum life span of an ECS instance in the scaling group.

        Unit: seconds.
        Valid values: 86400 to the value of Integer.maxValue.
        Default value: null.
        Note: This parameter is unavailable for scaling groups of the ECI type or scaling groups whose ScalingPolicy is set to recycle.
        '''
        result = self._values.get("max_instance_lifetime")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def multi_az_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property multiAzPolicy: ECS scaling strategy for multi availability zone.

        Allow value:

        1. PRIORITY: scaling the capacity according to the virtual switch (VSwitchIds.N) you define. ECS instances are automatically created using the next priority virtual switch when the higher priority virtual switch cannot be created in the available zone.
        2. BALANCE: evenly allocate ECS instances between the multiple available zone specified by the scaling group.
        3. COST_OPTIMIZED: During a scale-out activity, Auto Scaling attempts to create ECS instances that have vCPUs provided at the lowest price. During a scale-in activity, Auto Scaling attempts to remove ECS instances that have vCPUs provided at the highest price. Preemptible instances are preferentially created when preemptible instance types are specified in the active scaling configuration. You can configure the CompensateWithOnDemand parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.
           Note COST_OPTIMIZED is valid when multiple instance types are specified or at least one preemptible instance type is specified.
        4. COMPOSABLE: You can flexibly combine the preceding policies based on your business requirements.
        '''
        result = self._values.get("multi_az_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def notification_configurations(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.NotificationConfigurationsProperty]]]]:
        '''Property notificationConfigurations: When a scaling event occurs in a scaling group, ESS will send a notification to Cloud Monitor or MNS.'''
        result = self._values.get("notification_configurations")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.NotificationConfigurationsProperty]]]], result)

    @builtins.property
    def on_demand_base_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property onDemandBaseCapacity: The minimum number of pay-as-you-go instances required in the scaling group.

        Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.
        If you set MultiAZPolicy to COMPOSABLE Policy, the default value of this parameter is 0.
        '''
        result = self._values.get("on_demand_base_capacity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def on_demand_percentage_above_base_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property onDemandPercentageAboveBaseCapacity: The percentage of pay-as-you-go instances that can be created when instances are added to the scaling group.

        This parameter takes effect when the number of pay-as-you-go instances reaches the value for the OnDemandBaseCapacity parameter. Valid values: 0 to 100.
        If you set MultiAZPolicy to COMPOSABLE, the default value of this parameter is 100.
        '''
        result = self._values.get("on_demand_percentage_above_base_capacity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def protected_instances(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property protectedInstances: ECS instances of protected mode in the scaling group.'''
        result = self._values.get("protected_instances")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def removal_policys(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property removalPolicys: Policy for removing ECS instances from the scaling group.

        Optional values:

        - OldestInstance: removes the first ECS instance attached to the scaling group.
        - NewestInstance: removes the first ECS instance attached to the scaling group.
        - OldestScalingConfiguration: removes the ECS instance with the oldest scaling configuration.
        - CustomPolicy: removes ECS instances based on the custom scale-in policy (Function).
          You can enter up to three removal policies.
          You cannot set any item of RemovalPolicys to the same value.
          The scaling configuration source specified by the OldestScalingConfiguration setting can be a scaling configuration or a launch template. You can specify CustomPolicy only as the value of first item of RemovalPolicys. If you set first item of RemovalPolicys to CustomPolicy, you must also specify CustomPolicyARN.
          Note: The removal of ECS instances from a scaling group is also affected by the value of MultiAZPolicy.
        '''
        result = self._values.get("removal_policys")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: Resource group id.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_group_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scalingGroupName: Name shown for the scaling group, which must contain 2-40 characters (English or Chinese).

        The name must begin with a number, an upper/lower-case letter or a Chinese character and may contain numbers, "_", "-" or ".". The account name is unique in the same region.
        If this parameter is not specified, the default value is ScalingGroupId.
        '''
        result = self._values.get("scaling_group_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scalingPolicy: The reclaim mode of the scaling group.

        Valid values:
        recycle
        release
        forcerelease
        ScalingPolicy specifies the reclaim modes of scaling groups, but the policy that is used to remove ECS instances from scaling groups is determined by the RemovePolicy parameter of the RemoveInstances operation.
        '''
        result = self._values.get("scaling_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def server_groups(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.ServerGroupsProperty]]]]:
        '''Property serverGroups: The config of server group.'''
        result = self._values.get("server_groups")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.ServerGroupsProperty]]]], result)

    @builtins.property
    def spot_allocation_strategy(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotAllocationStrategy: The allocation policy of preemptible instances.

        You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only if you set MultiAZPolicy to COMPOSABLE. Valid values:

        - priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances.
        - lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.
          Default value: priority.
        '''
        result = self._values.get("spot_allocation_strategy")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_instance_pools(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotInstancePools: The number of instance types that are available.

        The system creates preemptible instances of multiple instance types that are available at the lowest cost in the scaling group. Valid values: 1 to 10.
        If you set MultiAZPolicy to COMPOSABLE, the default value of this parameter is 2.
        '''
        result = self._values.get("spot_instance_pools")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spot_instance_remedy(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spotInstanceRemedy: Specifies whether to supplement preemptible instances.

        If this parameter is set to true, Auto Scaling attempts to create an instance to replace a preemptible instance when Auto Scaling receives a system message which indicates that the preemptible instance is to be reclaimed.
        '''
        result = self._values.get("spot_instance_remedy")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def standby_instances(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property standbyInstances: ECS instances of standby mode in the scaling group.'''
        result = self._values.get("standby_instances")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosScalingGroup.TagsProperty]]:
        '''Property tags: Tags to attach to instance.

        Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosScalingGroup.TagsProperty]], result)

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property vSwitchId: If you create a VPC scaling group, you must specify the ID of a VSwitch.'''
        result = self._values.get("v_switch_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def v_switch_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property vSwitchIds: Parameter VSwitchIds.N is used to create instance in multiple zones. Parameter VSwitchIds.N has a priority over parameter VSwitchId. The valid range of N is [1, 8], and you can specify at most 5 VSwitches in a VPC. The priority of VSwitches descends from 1 to 8, and 1 indicates the highest priority. When you fail to create an instance in the zone to which a specified VSwitch belongs, another VSwitch with less priority replaces the specified one automatically.'''
        result = self._values.get("v_switch_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ScalingGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ScalingRule(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.ScalingRule",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::ScalingRule``, which is used to create a scaling rule.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosScalingRule``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalingrule
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["ScalingRuleProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28114355f5083d0439f61b045758db9345ad9c7c8c56da82f7d33b1cb5803910)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleAri")
    def attr_scaling_rule_ari(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingRuleAri: Unique identifier of a scaling rule.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleAri"))

    @builtins.property
    @jsii.member(jsii_name="attrScalingRuleId")
    def attr_scaling_rule_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingRuleId: ID of a scaling rule, generated by the system and globally unique.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingRuleId"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79c8386db18265a921eaa0628996eaa54568721e293584cc9881a394c346a305)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b802fc6903d8d1356dc5436db70b776e7f3699f8aee6c367c01ec1f0913696e6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "ScalingRuleProps":
        return typing.cast("ScalingRuleProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "ScalingRuleProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__249e9795c16f7e465f235b09adcd9d3320288fd568bb591ab5afc13ae780bd01)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ffde865bcd630a9e4902965b5e1b81b5efe6a45a159c29fc672576b45cf6436)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.ScalingRuleProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "adjustment_type": "adjustmentType",
        "adjustment_value": "adjustmentValue",
        "cooldown": "cooldown",
        "disable_scale_in": "disableScaleIn",
        "estimated_instance_warmup": "estimatedInstanceWarmup",
        "initial_max_size": "initialMaxSize",
        "metric_name": "metricName",
        "min_adjustment_magnitude": "minAdjustmentMagnitude",
        "predictive_scaling_mode": "predictiveScalingMode",
        "predictive_task_buffer_time": "predictiveTaskBufferTime",
        "predictive_value_behavior": "predictiveValueBehavior",
        "predictive_value_buffer": "predictiveValueBuffer",
        "scale_in_evaluation_count": "scaleInEvaluationCount",
        "scale_out_evaluation_count": "scaleOutEvaluationCount",
        "scaling_rule_name": "scalingRuleName",
        "scaling_rule_type": "scalingRuleType",
        "step_adjustment": "stepAdjustment",
        "target_value": "targetValue",
    },
)
class ScalingRuleProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        adjustment_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        adjustment_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        cooldown: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        disable_scale_in: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        estimated_instance_warmup: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        initial_max_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        metric_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        min_adjustment_magnitude: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        predictive_scaling_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        predictive_task_buffer_time: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        predictive_value_behavior: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        predictive_value_buffer: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scale_in_evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scale_out_evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_rule_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_rule_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        step_adjustment: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingRule.StepAdjustmentProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        target_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``ScalingRule``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scalingrule

        :param scaling_group_id: Property scalingGroupId: ID of the scaling group of a scaling rule.
        :param adjustment_type: Property adjustmentType: Adjustment mode of a scaling rule. Optional values: - QuantityChangeInCapacity: It is used to increase or decrease a specified number of ECS instances. - PercentChangeInCapacity: It is used to increase or decrease a specified proportion of ECS instances. - TotalCapacity: It is used to adjust the quantity of ECS instances in the current scaling group to a specified value.
        :param adjustment_value: Property adjustmentValue: Adjusted value of a scaling rule. Value range: - QuantityChangeInCapacity: [-500, 500] - PercentChangeInCapacity: [-100, 10000] - TotalCapacity: [0, 1000]
        :param cooldown: Property cooldown: Cool-down time of a scaling rule. Value range: [0, 86,400], in seconds. The default value is empty.
        :param disable_scale_in: Property disableScaleIn: Specifies whether to disable scale-in. This parameter is applicable only to target tracking scaling rules. Default value: false
        :param estimated_instance_warmup: Property estimatedInstanceWarmup: The warm-up period of the ECS instances. This parameter is applicable to target tracking scaling rules and step scaling rules. The system adds ECS instances that are in the warm-up state to the scaling group, but does not report monitoring data during the warm-up period to CloudMonitor. Note: When calculating the number of ECS instances to be adjusted, the system does not count ECS instances in the warm-up state as part of the current capacity of the scaling group. Valid values: 0 to 86400. Unit: seconds. Default value: 300.
        :param initial_max_size: Property initialMaxSize: The maximum number of ECS instances in the scaling group, which is used together with PredictiveValueBehavior. Default value: the same as the value of MaxSize
        :param metric_name: Property metricName: The predefined metric to monitor. This parameter is required and applicable only to target tracking scaling rules and predictive scaling rules. Valid values of a target tracking scaling rule: - CpuUtilization: the average CPU utilization- ClassicInternetRx: the average public network inbound traffic over the classic network - ClassicInternetTx: the average public network outbound traffic over the classic network - VpcInternetRx: the average public network inbound traffic over the VPC - VpcInternetTx: the average public network outbound traffic over the VPC - IntranetRx: the average internal network inbound traffic - IntranetTx: the average internal network outbound traffic Valid values of a predictive scaling rule: - CpuUtilization: the average CPU utilization - IntranetRx: the average internal network inbound traffic - IntranetTx: the average internal network outbound traffic
        :param min_adjustment_magnitude: Property minAdjustmentMagnitude: The minimum number of ECS instances to be adjusted in a scaling rule. This parameter takes effect only when the scaling rule type is SimpleScalingRule or StepScalingRule and AdjustmentType is PercentChangeInCapacity.
        :param predictive_scaling_mode: Property predictiveScalingMode: The mode of the predictive scaling rule. Valid values: - PredictAndScale: generates forecasts and creates forecast tasks. - PredictOnly: generates forecasts but does not create forecast tasks. Default value: PredictAndScale
        :param predictive_task_buffer_time: Property predictiveTaskBufferTime: The amount of buffer time ahead of the forecast task execution time. By default, all scheduled tasks that are automatically created for a predictive scaling rule are executed at the beginning of each hour. You can set a buffer time to execute forecast tasks ahead of schedule, so that resources can be prepared in advance. Valid values: 0 to 60. Unit: minutes. Default value: 0
        :param predictive_value_behavior: Property predictiveValueBehavior: The action taken on the predicted maximum value. Valid values: - MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for forecast tasks when the predicted value is greater than the initial maximum capacity. - PredictiveValueOverrideMax: uses the predicted value as the maximum value for forecast tasks when the predicted value is greater than the initial maximum capacity. - PredictiveValueOverrideMaxWithBuffer: increases the predicted value with a ratio, which is specified by PredictiveValueBuffer. If the value after the increase is greater than the initial maximum capacity, the value after the increase is used as the maximum value for forecast tasks. Default value: MaxOverridePredictiveValue
        :param predictive_value_buffer: Property predictiveValueBuffer: The ratio of the increment to the predicted value when PredictiveValueBehavior is set to PredictiveValueOverrideMaxWithBuffer. When the value after the increase is greater than the initial maximum capacity, the value after the increase is used for forecast tasks. Valid values: 0 to 100 Default value: 0
        :param scale_in_evaluation_count: Property scaleInEvaluationCount: The number of consecutive times that the event-triggered task created for scale-in activities meets the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule. Default value: 15.
        :param scale_out_evaluation_count: Property scaleOutEvaluationCount: The number of consecutive times that the event-triggered task created for scale-out activities meets the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule. Default value: 3.
        :param scaling_rule_name: Property scalingRuleName: Name shown for the scaling group, which is a string containing 2 to 40 English or Chinese characters. It must begin with a number, a letter (case-insensitive) or a Chinese character and can contain numbers, "_", "-" or ".". The account name in the same scaling group is unique in the same region. If this parameter value is not specified, the default value is ScalingRuleId.
        :param scaling_rule_type: Property scalingRuleType: The type of the scaling rule. Valid values: - SimpleScalingRule: scales ECS instances based on the values of AdjustmentType and AdjustmentValue. - TargetTrackingScalingRule: dynamically calculates the number of ECS instances to be adjusted and tries to keep the value of a predefined monitoring metric close to TargetValue. - StepScalingRule: scales ECS instances in steps based on specified thresholds and metric values. - PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and then predicts the future values of monitored metrics, the rule then automatically creates scheduled tasks to set the boundary values for the scaling group. If this parameter value is not specified, the default value is SimpleScalingRule.
        :param step_adjustment: Property stepAdjustment:.
        :param target_value: Property targetValue: The target value of a metric. This parameter is required and applicable only to target tracking scaling rules and predictive scaling rules. The value of TargetValue must be greater than 0 and can have a maximum of three decimal places.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a303e009feea4147bbfda85fb8136affa7e8281bb9359bd8b6996aaf2647a1b)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument adjustment_type", value=adjustment_type, expected_type=type_hints["adjustment_type"])
            check_type(argname="argument adjustment_value", value=adjustment_value, expected_type=type_hints["adjustment_value"])
            check_type(argname="argument cooldown", value=cooldown, expected_type=type_hints["cooldown"])
            check_type(argname="argument disable_scale_in", value=disable_scale_in, expected_type=type_hints["disable_scale_in"])
            check_type(argname="argument estimated_instance_warmup", value=estimated_instance_warmup, expected_type=type_hints["estimated_instance_warmup"])
            check_type(argname="argument initial_max_size", value=initial_max_size, expected_type=type_hints["initial_max_size"])
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument min_adjustment_magnitude", value=min_adjustment_magnitude, expected_type=type_hints["min_adjustment_magnitude"])
            check_type(argname="argument predictive_scaling_mode", value=predictive_scaling_mode, expected_type=type_hints["predictive_scaling_mode"])
            check_type(argname="argument predictive_task_buffer_time", value=predictive_task_buffer_time, expected_type=type_hints["predictive_task_buffer_time"])
            check_type(argname="argument predictive_value_behavior", value=predictive_value_behavior, expected_type=type_hints["predictive_value_behavior"])
            check_type(argname="argument predictive_value_buffer", value=predictive_value_buffer, expected_type=type_hints["predictive_value_buffer"])
            check_type(argname="argument scale_in_evaluation_count", value=scale_in_evaluation_count, expected_type=type_hints["scale_in_evaluation_count"])
            check_type(argname="argument scale_out_evaluation_count", value=scale_out_evaluation_count, expected_type=type_hints["scale_out_evaluation_count"])
            check_type(argname="argument scaling_rule_name", value=scaling_rule_name, expected_type=type_hints["scaling_rule_name"])
            check_type(argname="argument scaling_rule_type", value=scaling_rule_type, expected_type=type_hints["scaling_rule_type"])
            check_type(argname="argument step_adjustment", value=step_adjustment, expected_type=type_hints["step_adjustment"])
            check_type(argname="argument target_value", value=target_value, expected_type=type_hints["target_value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
        }
        if adjustment_type is not None:
            self._values["adjustment_type"] = adjustment_type
        if adjustment_value is not None:
            self._values["adjustment_value"] = adjustment_value
        if cooldown is not None:
            self._values["cooldown"] = cooldown
        if disable_scale_in is not None:
            self._values["disable_scale_in"] = disable_scale_in
        if estimated_instance_warmup is not None:
            self._values["estimated_instance_warmup"] = estimated_instance_warmup
        if initial_max_size is not None:
            self._values["initial_max_size"] = initial_max_size
        if metric_name is not None:
            self._values["metric_name"] = metric_name
        if min_adjustment_magnitude is not None:
            self._values["min_adjustment_magnitude"] = min_adjustment_magnitude
        if predictive_scaling_mode is not None:
            self._values["predictive_scaling_mode"] = predictive_scaling_mode
        if predictive_task_buffer_time is not None:
            self._values["predictive_task_buffer_time"] = predictive_task_buffer_time
        if predictive_value_behavior is not None:
            self._values["predictive_value_behavior"] = predictive_value_behavior
        if predictive_value_buffer is not None:
            self._values["predictive_value_buffer"] = predictive_value_buffer
        if scale_in_evaluation_count is not None:
            self._values["scale_in_evaluation_count"] = scale_in_evaluation_count
        if scale_out_evaluation_count is not None:
            self._values["scale_out_evaluation_count"] = scale_out_evaluation_count
        if scaling_rule_name is not None:
            self._values["scaling_rule_name"] = scaling_rule_name
        if scaling_rule_type is not None:
            self._values["scaling_rule_type"] = scaling_rule_type
        if step_adjustment is not None:
            self._values["step_adjustment"] = step_adjustment
        if target_value is not None:
            self._values["target_value"] = target_value

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: ID of the scaling group of a scaling rule.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def adjustment_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property adjustmentType: Adjustment mode of a scaling rule.

        Optional values:

        - QuantityChangeInCapacity: It is used to increase or decrease a specified number of ECS instances.
        - PercentChangeInCapacity: It is used to increase or decrease a specified proportion of ECS instances.
        - TotalCapacity: It is used to adjust the quantity of ECS instances in the current scaling group to a specified value.
        '''
        result = self._values.get("adjustment_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def adjustment_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property adjustmentValue: Adjusted value of a scaling rule.

        Value range:

        - QuantityChangeInCapacity: [-500, 500]
        - PercentChangeInCapacity: [-100, 10000]
        - TotalCapacity: [0, 1000]
        '''
        result = self._values.get("adjustment_value")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def cooldown(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property cooldown: Cool-down time of a scaling rule.

        Value range: [0, 86,400], in seconds. The default value is empty.
        '''
        result = self._values.get("cooldown")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def disable_scale_in(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property disableScaleIn: Specifies whether to disable scale-in.

        This parameter is applicable only to target tracking scaling rules.
        Default value: false
        '''
        result = self._values.get("disable_scale_in")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def estimated_instance_warmup(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property estimatedInstanceWarmup: The warm-up period of the ECS instances.

        This parameter is applicable to target tracking scaling rules and step scaling rules. The system adds ECS instances that are in the warm-up state to the scaling group, but does not report monitoring data during the warm-up period to CloudMonitor.
        Note: When calculating the number of ECS instances to be adjusted, the system does not count ECS instances in the warm-up state as part of the current capacity of the scaling group.
        Valid values: 0 to 86400. Unit: seconds. Default value: 300.
        '''
        result = self._values.get("estimated_instance_warmup")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def initial_max_size(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property initialMaxSize: The maximum number of ECS instances in the scaling group, which is used together with PredictiveValueBehavior.

        Default value: the same as the value of MaxSize
        '''
        result = self._values.get("initial_max_size")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def metric_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property metricName: The predefined metric to monitor.

        This parameter is required and applicable only to target tracking scaling rules and predictive scaling rules.
        Valid values of a target tracking scaling rule:

        - CpuUtilization: the average CPU utilization- ClassicInternetRx: the average public network inbound traffic over the classic network
        - ClassicInternetTx: the average public network outbound traffic over the classic network
        - VpcInternetRx: the average public network inbound traffic over the VPC
        - VpcInternetTx: the average public network outbound traffic over the VPC
        - IntranetRx: the average internal network inbound traffic
        - IntranetTx: the average internal network outbound traffic
          Valid values of a predictive scaling rule:
        - CpuUtilization: the average CPU utilization
        - IntranetRx: the average internal network inbound traffic
        - IntranetTx: the average internal network outbound traffic
        '''
        result = self._values.get("metric_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def min_adjustment_magnitude(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property minAdjustmentMagnitude: The minimum number of ECS instances to be adjusted in a scaling rule.

        This parameter takes effect only when the scaling rule type is SimpleScalingRule or StepScalingRule and AdjustmentType is PercentChangeInCapacity.
        '''
        result = self._values.get("min_adjustment_magnitude")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def predictive_scaling_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property predictiveScalingMode: The mode of the predictive scaling rule.

        Valid values:

        - PredictAndScale: generates forecasts and creates forecast tasks.
        - PredictOnly: generates forecasts but does not create forecast tasks.
          Default value: PredictAndScale
        '''
        result = self._values.get("predictive_scaling_mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def predictive_task_buffer_time(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property predictiveTaskBufferTime: The amount of buffer time ahead of the forecast task execution time.

        By default, all scheduled tasks that are automatically created for a predictive scaling rule are executed at the beginning of each hour. You can set a buffer time to execute forecast tasks ahead of schedule, so that resources can be prepared in advance. Valid values: 0 to 60. Unit: minutes.
        Default value: 0
        '''
        result = self._values.get("predictive_task_buffer_time")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def predictive_value_behavior(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property predictiveValueBehavior: The action taken on the predicted maximum value.

        Valid values:

        - MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for forecast tasks when the predicted value is greater than the initial maximum capacity.

          - PredictiveValueOverrideMax: uses the predicted value as the maximum value for forecast tasks when the predicted value is greater than the initial maximum capacity.
          - PredictiveValueOverrideMaxWithBuffer: increases the predicted value with a ratio, which is specified by PredictiveValueBuffer. If the value after the increase is greater than the initial maximum capacity, the value after the increase is used as the maximum value for forecast tasks.
            Default value: MaxOverridePredictiveValue
        '''
        result = self._values.get("predictive_value_behavior")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def predictive_value_buffer(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property predictiveValueBuffer: The ratio of the increment to the predicted value when PredictiveValueBehavior is set to PredictiveValueOverrideMaxWithBuffer.

        When the value after the increase is greater than the initial maximum capacity, the value after the increase is used for forecast tasks. Valid values: 0 to 100
        Default value: 0
        '''
        result = self._values.get("predictive_value_buffer")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scale_in_evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scaleInEvaluationCount: The number of consecutive times that the event-triggered task created for scale-in activities meets the threshold conditions before an alert is triggered.

        After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
        Default value: 15.
        '''
        result = self._values.get("scale_in_evaluation_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scale_out_evaluation_count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scaleOutEvaluationCount: The number of consecutive times that the event-triggered task created for scale-out activities meets the threshold conditions before an alert is triggered.

        After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
        Default value: 3.
        '''
        result = self._values.get("scale_out_evaluation_count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_rule_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scalingRuleName: Name shown for the scaling group, which is a string containing 2 to 40 English or Chinese characters.

        It must begin with a number, a letter (case-insensitive) or a Chinese character and can contain numbers, "_", "-" or ".". The account name in the same scaling group is unique in the same region. If this parameter value is not specified, the default value is ScalingRuleId.
        '''
        result = self._values.get("scaling_rule_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_rule_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scalingRuleType: The type of the scaling rule.

        Valid values:

        - SimpleScalingRule: scales ECS instances based on the values of AdjustmentType and AdjustmentValue.
        - TargetTrackingScalingRule: dynamically calculates the number of ECS instances to be adjusted and tries to keep the value of a predefined monitoring metric close to TargetValue.
        - StepScalingRule: scales ECS instances in steps based on specified thresholds and metric values.
        - PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and then predicts the future values of monitored metrics, the rule then automatically creates scheduled tasks to set the boundary values for the scaling group.
          If this parameter value is not specified, the default value is SimpleScalingRule.
        '''
        result = self._values.get("scaling_rule_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def step_adjustment(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingRule.StepAdjustmentProperty]]]]:
        '''Property stepAdjustment:.'''
        result = self._values.get("step_adjustment")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingRule.StepAdjustmentProperty]]]], result)

    @builtins.property
    def target_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property targetValue: The target value of a metric.

        This parameter is required and applicable only to target tracking scaling rules and predictive scaling rules. The value of TargetValue must be greater than 0 and can have a maximum of three decimal places.
        '''
        result = self._values.get("target_value")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ScalingRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ScheduledTask(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.ScheduledTask",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::ScheduledTask``, which is used to create a scheduled task by specifying properties.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosScheduledTask``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scheduledtask
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["ScheduledTaskProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__467b0ccce54c5e5c1a707486ece3255fafd9b19dcf2f7146927ec16858c4df14)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrScheduledTaskId")
    def attr_scheduled_task_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScheduledTaskId: ID of the scheduled task, which is generated by the system and globally unique.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScheduledTaskId"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2afdf1f5f8f6d827005eefba5ee943016d27c56906338968a3454757b6d800f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64a8c30770eb271296c31c5d414929c5f90d91ffe5485a4a8f4f758fbf166d02)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "ScheduledTaskProps":
        return typing.cast("ScheduledTaskProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "ScheduledTaskProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c3713261d1a913ac26a34888837ce94ab977e70b3c79da044fffb56ffcc5fd7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21cfad50534c50b0f7b942b1ad8e6cafa78be07f504531f70a06aff819761992)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.ScheduledTaskProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_time": "launchTime",
        "description": "description",
        "desired_capacity": "desiredCapacity",
        "launch_expiration_time": "launchExpirationTime",
        "max_value": "maxValue",
        "min_value": "minValue",
        "recurrence_end_time": "recurrenceEndTime",
        "recurrence_type": "recurrenceType",
        "recurrence_value": "recurrenceValue",
        "scaling_group_id": "scalingGroupId",
        "scheduled_action": "scheduledAction",
        "scheduled_task_name": "scheduledTaskName",
        "task_enabled": "taskEnabled",
    },
)
class ScheduledTaskProps:
    def __init__(
        self,
        *,
        launch_time: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        desired_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        launch_expiration_time: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        max_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        min_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        recurrence_end_time: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        recurrence_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        recurrence_value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scaling_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scheduled_action: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        scheduled_task_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        task_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``ScheduledTask``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-scheduledtask

        :param launch_time: Property launchTime: Time point at which the scheduled task is triggered. The date format follows the ISO8601 standard and uses UTC time. It is in the format of YYYY-MM-DDThh:mmZ. If RecurrenceType is specified, the time point specified by this attribute is the default time point at which the circle is executed. If RecurrenceType is not specified, the task is executed once on the designated date and time. A time point 90 days after creation or modification cannot be entered.
        :param description: Property description: Description of the scheduled task, which is 2-200 characters (English or Chinese) long.
        :param desired_capacity: Property desiredCapacity: The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the **ScalingGroupId** parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the **MinValue**, **MaxValue**, and **DesiredCapacity** parameters.
        :param launch_expiration_time: Property launchExpirationTime: Time period within which the failed scheduled task is retried. The default value is 600s. Value range: [0, 21600]
        :param max_value: Property maxValue: The expected number of instances in the scaling group if you specify the ScalingGroupId parameter. **Note**: You must specify the **DesiredCapacity** parameter when you create a scaling group.
        :param min_value: Property minValue: The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.
        :param recurrence_end_time: Property recurrenceEndTime: End time of the scheduled task to be repeated. The date format follows the ISO8601 standard and uses UTC time. It is in the format of YYYY-MM-DDThh:mmZ. A time point 90 days after creation or modification cannot be entered. RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        :param recurrence_type: Property recurrenceType: Type of the scheduled task to be repeated. Optional values: - Daily: Recurrence interval by day for a scheduled task. - Weekly: Recurrence interval by week for a scheduled task. - Monthly: Recurrence interval by month for a scheduled task. RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        :param recurrence_value: Property recurrenceValue: Value of the scheduled task to be repeated. - Daily: Only one value in the range [1,31] can be filled. - Weekly: Multiple values can be filled. The values of Sunday to Saturday are 0 to 6 in sequence. Multiple values shall be separated by a comma ",". - Monthly: In the format of A-B. The value range of A and B is 1 to 31, and the B value must be greater than the A value. RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        :param scaling_group_id: Property scalingGroupId: The globally unique ID of the scheduled task. The globally unique ID is generated by the system. **Note**: You cannot specify the **ScheduledAction** and **ScalingGroupId** parameters at the same time.
        :param scheduled_action: Property scheduledAction: Operations performed when the scheduled task is triggered. Fill in the unique identifier of the scaling rule. **Note**: You cannot specify the **ScheduledAction** and **ScalingGroupId** parameters at the same time.
        :param scheduled_task_name: Property scheduledTaskName: Display name of the scheduled task, which must be 2-40 characters (English or Chinese) long. It must begin with a number, an upper/lower-case letter or a Chinese character and may contain numbers, "_", "-" or ".". The account name is unique in the same region. If this parameter is not specified, the default value ScheduledScalingTaskId is used.
        :param task_enabled: Property taskEnabled: Whether to enable the scheduled task. - When the parameter is set to true, the task is enabled. - When the parameter is set to false, the task is disabled. The default value is true.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7004c843a4bba26c274ecbc7e81a969c44737fec24320bbb2366215d1aaa92f9)
            check_type(argname="argument launch_time", value=launch_time, expected_type=type_hints["launch_time"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument desired_capacity", value=desired_capacity, expected_type=type_hints["desired_capacity"])
            check_type(argname="argument launch_expiration_time", value=launch_expiration_time, expected_type=type_hints["launch_expiration_time"])
            check_type(argname="argument max_value", value=max_value, expected_type=type_hints["max_value"])
            check_type(argname="argument min_value", value=min_value, expected_type=type_hints["min_value"])
            check_type(argname="argument recurrence_end_time", value=recurrence_end_time, expected_type=type_hints["recurrence_end_time"])
            check_type(argname="argument recurrence_type", value=recurrence_type, expected_type=type_hints["recurrence_type"])
            check_type(argname="argument recurrence_value", value=recurrence_value, expected_type=type_hints["recurrence_value"])
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument scheduled_action", value=scheduled_action, expected_type=type_hints["scheduled_action"])
            check_type(argname="argument scheduled_task_name", value=scheduled_task_name, expected_type=type_hints["scheduled_task_name"])
            check_type(argname="argument task_enabled", value=task_enabled, expected_type=type_hints["task_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "launch_time": launch_time,
        }
        if description is not None:
            self._values["description"] = description
        if desired_capacity is not None:
            self._values["desired_capacity"] = desired_capacity
        if launch_expiration_time is not None:
            self._values["launch_expiration_time"] = launch_expiration_time
        if max_value is not None:
            self._values["max_value"] = max_value
        if min_value is not None:
            self._values["min_value"] = min_value
        if recurrence_end_time is not None:
            self._values["recurrence_end_time"] = recurrence_end_time
        if recurrence_type is not None:
            self._values["recurrence_type"] = recurrence_type
        if recurrence_value is not None:
            self._values["recurrence_value"] = recurrence_value
        if scaling_group_id is not None:
            self._values["scaling_group_id"] = scaling_group_id
        if scheduled_action is not None:
            self._values["scheduled_action"] = scheduled_action
        if scheduled_task_name is not None:
            self._values["scheduled_task_name"] = scheduled_task_name
        if task_enabled is not None:
            self._values["task_enabled"] = task_enabled

    @builtins.property
    def launch_time(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property launchTime: Time point at which the scheduled task is triggered.

        The date format follows the ISO8601 standard and uses UTC time. It is in the format of YYYY-MM-DDThh:mmZ.
        If RecurrenceType is specified, the time point specified by this attribute is the default time point at which the circle is executed. If RecurrenceType is not specified, the task is executed once on the designated date and time.
        A time point 90 days after creation or modification cannot be entered.
        '''
        result = self._values.get("launch_time")
        assert result is not None, "Required property 'launch_time' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Description of the scheduled task, which is 2-200 characters (English or Chinese) long.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def desired_capacity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property desiredCapacity: The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered.

        If you specify the **ScalingGroupId** parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the **MinValue**, **MaxValue**, and **DesiredCapacity** parameters.
        '''
        result = self._values.get("desired_capacity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def launch_expiration_time(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property launchExpirationTime: Time period within which the failed scheduled task is retried.

        The default value is 600s.
        Value range: [0, 21600]
        '''
        result = self._values.get("launch_expiration_time")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def max_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property maxValue: The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.

        **Note**: You must specify the **DesiredCapacity** parameter when you create a scaling group.
        '''
        result = self._values.get("max_value")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def min_value(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property minValue: The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.'''
        result = self._values.get("min_value")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def recurrence_end_time(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property recurrenceEndTime: End time of the scheduled task to be repeated.

        The date format follows the ISO8601 standard and uses UTC time. It is in the format of YYYY-MM-DDThh:mmZ.
        A time point 90 days after creation or modification cannot be entered.
        RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        result = self._values.get("recurrence_end_time")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def recurrence_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property recurrenceType: Type of the scheduled task to be repeated.

        Optional values:

        - Daily: Recurrence interval by day for a scheduled task.
        - Weekly: Recurrence interval by week for a scheduled task.
        - Monthly: Recurrence interval by month for a scheduled task.
          RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        result = self._values.get("recurrence_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def recurrence_value(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property recurrenceValue: Value of the scheduled task to be repeated.

        - Daily: Only one value in the range [1,31] can be filled.
        - Weekly: Multiple values can be filled. The values of Sunday to Saturday are 0 to 6 in sequence. Multiple values shall be separated by a comma ",".
        - Monthly: In the format of A-B. The value range of A and B is 1 to 31, and the B value must be greater than the A value.
          RecurrenceType, RecurrenceValue and RecurrenceEndTime must be specified.
        '''
        result = self._values.get("recurrence_value")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scalingGroupId: The globally unique ID of the scheduled task.

        The globally unique ID is generated by the system.
        **Note**: You cannot specify the **ScheduledAction** and **ScalingGroupId** parameters at the same time.
        '''
        result = self._values.get("scaling_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scheduled_action(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scheduledAction: Operations performed when the scheduled task is triggered.

        Fill in the unique identifier of the scaling rule.
        **Note**: You cannot specify the **ScheduledAction** and **ScalingGroupId** parameters at the same time.
        '''
        result = self._values.get("scheduled_action")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def scheduled_task_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property scheduledTaskName: Display name of the scheduled task, which must be 2-40 characters (English or Chinese) long.

        It must begin with a number, an upper/lower-case letter or a Chinese character and may contain numbers, "_", "-" or ".".
        The account name is unique in the same region.
        If this parameter is not specified, the default value ScheduledScalingTaskId is used.
        '''
        result = self._values.get("scheduled_task_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def task_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property taskEnabled: Whether to enable the scheduled task.

        - When the parameter is set to true, the task is enabled.
        - When the parameter is set to false, the task is disabled.
          The default value is true.
        '''
        result = self._values.get("task_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ScheduledTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ServerGroupAttachment(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.ServerGroupAttachment",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::ServerGroupAttachment``, which is used to add one or more Server Load Balancer (SLB) server groups to a scaling group.

    Supported SLB server groups include Application Load Balancer (ALB) server groups and Network Load Balancer (NLB) server groups.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosServerGroupAttachment``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-servergroupattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["ServerGroupAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b21d7ab1118b975bcb042769d90ca65a925a5007a54fdd34125384321ea8b3ab)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrScalingActivityId")
    def attr_scaling_activity_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingActivityId: The ID of the scaling activity during which one or more SLB instances are attached to the scaling group and the ECS instances in the scaling group are added to the backend server groups of the SLB instances.

        Note This parameter is returned only after you set the ForceAttach parameter to true.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingActivityId"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b354edc749bcfcebd56673b2857a22fafc1a4d0023d3390d096c1befc3c9f42)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3577d32d23d2957037421faecaec3aeb3585bd376dc1c3f77edd8d438b44004)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "ServerGroupAttachmentProps":
        return typing.cast("ServerGroupAttachmentProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "ServerGroupAttachmentProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__814614d5cc37f71818137aff5480971d3d0ebf7a2454c7dfe7edea3645549c76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a9999ef94f8ff59ffc8b7696623f11ebc4d1e1a08061240f530c156017ff65eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.ServerGroupAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "server_groups": "serverGroups",
        "force_attach": "forceAttach",
    },
)
class ServerGroupAttachmentProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        server_groups: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosServerGroupAttachment.ServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]],
        force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``ServerGroupAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-servergroupattachment

        :param scaling_group_id: Property scalingGroupId: The ID of the scaling group.
        :param server_groups: Property serverGroups: A collection of information about server groups.
        :param force_attach: Property forceAttach: Specifies whether to add the Elastic Compute Service (ECS) instances in the scaling group to the backend server group of the newly attached SLB instance. Valid values: true false Default value: false.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a14a629697d6d8c9c32dd794afc4333a4889f79099a1fbbb5764caa19e2aa48)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument server_groups", value=server_groups, expected_type=type_hints["server_groups"])
            check_type(argname="argument force_attach", value=force_attach, expected_type=type_hints["force_attach"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
            "server_groups": server_groups,
        }
        if force_attach is not None:
            self._values["force_attach"] = force_attach

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: The ID of the scaling group.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def server_groups(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosServerGroupAttachment.ServerGroupsProperty]]]:
        '''Property serverGroups: A collection of information about server groups.'''
        result = self._values.get("server_groups")
        assert result is not None, "Required property 'server_groups' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosServerGroupAttachment.ServerGroupsProperty]]], result)

    @builtins.property
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property forceAttach: Specifies whether to add the Elastic Compute Service (ECS) instances in the scaling group to the backend server group of the newly attached SLB instance.

        Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("force_attach")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServerGroupAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VServerGroupAttachment(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ess.VServerGroupAttachment",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::ESS::VServerGroupAttachment``, which is used to associate vServer groups of a Sever Load Balancer (SLB) instance with a scaling group.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosVServerGroupAttachment``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-vservergroupattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["VServerGroupAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0336e2df938044a599be1ee8ef82e6699b485c36595bfba8e9870d5807934d28)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrScalingGroupId")
    def attr_scaling_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ScalingGroupId: The ID of the scaling group.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrScalingGroupId"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def _enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @_enable_resource_property_constraint.setter
    def _enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ff15cd957254b846e90a1dc1ce8fb112a8bfe8f86dfa1249f72c063ed75a75a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="id")
    def _id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @_id.setter
    def _id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c997793d504cb2974904a0eda5d642e7ecb848708a36c165cc7ff625c50ff2bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "VServerGroupAttachmentProps":
        return typing.cast("VServerGroupAttachmentProps", jsii.get(self, "props"))

    @_props.setter
    def _props(self, value: "VServerGroupAttachmentProps") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f225bb4d3167e4842046975f679d156f29aa92740894c24004050e06ead320fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "props", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> _ros_cdk_core_7adfd82f.Construct:
        return typing.cast(_ros_cdk_core_7adfd82f.Construct, jsii.get(self, "scope"))

    @_scope.setter
    def _scope(self, value: _ros_cdk_core_7adfd82f.Construct) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a95407a74c79eff937e734a0c26f6d5067142843ee91edd348ee97de0a6193cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ess.VServerGroupAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "scaling_group_id": "scalingGroupId",
        "v_server_groups": "vServerGroups",
        "force_attach": "forceAttach",
    },
)
class VServerGroupAttachmentProps:
    def __init__(
        self,
        *,
        scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        v_server_groups: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVServerGroupAttachment.VServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]],
        force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``VServerGroupAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-ess-vservergroupattachment

        :param scaling_group_id: Property scalingGroupId: The ID of the scaling group.
        :param v_server_groups: Property vServerGroups: A list of vserver groups attached on scaling group.
        :param force_attach: Property forceAttach: If instances of scaling group are attached/removed from slb backend server when attach/detach vserver group from scaling group. Valid values: true false Default value: false.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f08b25875adfe287f2a814c6ba297536f62629bea912d653945184670fb3bdf8)
            check_type(argname="argument scaling_group_id", value=scaling_group_id, expected_type=type_hints["scaling_group_id"])
            check_type(argname="argument v_server_groups", value=v_server_groups, expected_type=type_hints["v_server_groups"])
            check_type(argname="argument force_attach", value=force_attach, expected_type=type_hints["force_attach"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scaling_group_id": scaling_group_id,
            "v_server_groups": v_server_groups,
        }
        if force_attach is not None:
            self._values["force_attach"] = force_attach

    @builtins.property
    def scaling_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property scalingGroupId: The ID of the scaling group.'''
        result = self._values.get("scaling_group_id")
        assert result is not None, "Required property 'scaling_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def v_server_groups(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVServerGroupAttachment.VServerGroupsProperty]]]:
        '''Property vServerGroups: A list of vserver groups attached on scaling group.'''
        result = self._values.get("v_server_groups")
        assert result is not None, "Required property 'v_server_groups' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVServerGroupAttachment.VServerGroupsProperty]]], result)

    @builtins.property
    def force_attach(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property forceAttach: If instances of scaling group are attached/removed from slb backend server when attach/detach vserver group from scaling group.

        Valid values:
        true
        false
        Default value: false.
        '''
        result = self._values.get("force_attach")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VServerGroupAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "AlarmTask",
    "AlarmTaskEnable",
    "AlarmTaskEnableProps",
    "AlarmTaskProps",
    "EciScalingConfiguration",
    "EciScalingConfigurationProps",
    "LifecycleHook",
    "LifecycleHookProps",
    "LoadBalancerAttachment",
    "LoadBalancerAttachmentProps",
    "RosAlarmTask",
    "RosAlarmTaskEnable",
    "RosAlarmTaskEnableProps",
    "RosAlarmTaskProps",
    "RosEciScalingConfiguration",
    "RosEciScalingConfigurationProps",
    "RosLifecycleHook",
    "RosLifecycleHookProps",
    "RosLoadBalancerAttachment",
    "RosLoadBalancerAttachmentProps",
    "RosScalingConfiguration",
    "RosScalingConfigurationProps",
    "RosScalingGroup",
    "RosScalingGroupEnable",
    "RosScalingGroupEnableProps",
    "RosScalingGroupProps",
    "RosScalingRule",
    "RosScalingRuleProps",
    "RosScheduledTask",
    "RosScheduledTaskProps",
    "RosServerGroupAttachment",
    "RosServerGroupAttachmentProps",
    "RosVServerGroupAttachment",
    "RosVServerGroupAttachmentProps",
    "ScalingConfiguration",
    "ScalingConfigurationProps",
    "ScalingGroup",
    "ScalingGroupEnable",
    "ScalingGroupEnableProps",
    "ScalingGroupProps",
    "ScalingRule",
    "ScalingRuleProps",
    "ScheduledTask",
    "ScheduledTaskProps",
    "ServerGroupAttachment",
    "ServerGroupAttachmentProps",
    "VServerGroupAttachment",
    "VServerGroupAttachmentProps",
    "datasource",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import datasource

def _typecheckingstub__764fd1e9940f9a4c2bd11667c7fcd7ef227eff77dfff31f08b24eeba648816c2(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[AlarmTaskProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__656bc8e7e2cd713b40829edb78f9902c139c66957afc8c05cff0ebebfca02b79(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb45a08e208657a480c1fdf7b01a768809d02dcd7d42d16ed8b6d17e86c14e8f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eac56b8808d25d8bfa2204143ec8e0a3047367d208aacf5cca935ac9474d1012(
    value: AlarmTaskProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2f5f766a2bae3e866252f519cf401c35c47c1d90d31303666a9a3808f344c46(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77a2d7f90f91a5d104a5e4d7bfb6465099d560e28e764973f09d0ece596d4cb8(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[AlarmTaskEnableProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__808106288d1b399e6a867d2d2745bef36cc84b0ed54ff1d8bfeea4aa309f9e6e(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__104bfdbaa6e4d77aae32090f49b8a36df8a781bcfc8c724f4dd7392ec70543e1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2346f974467e3fd4cf93a8382d83a01a3cf05d1a6b753ee7124480bf7fbb069(
    value: AlarmTaskEnableProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d2f05e307b73d87e2b480ebc998658ad8cda47c0860e336a70e6f9a185b62cf(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75a8133c27a4af819b5d126cd149ee508c1190e31b974a1e5fc006293bc5a9dd(
    *,
    alarm_task_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    enable: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe1bbef50f679260f65ae6805fe47532b6529a1892faf30864bd62d2686929dc(
    *,
    alarm_action: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    metric_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    threshold: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    comparison_operator: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    dimensions: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosAlarmTask.DimensionsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    group_id: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    metric_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    statistics: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39109add3ecef7540ac58097bf0b39ab67f7bf2f374548a64bb835cf8ab52f10(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[EciScalingConfigurationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__917dd3344f5fb5b15c588d85800130336cda7e8d397c433eefa1203128e42e07(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98c2802e5cf090b5c362a1a3c8eeb42a21ddf0e4f45798018b048026289292c0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1a6f2dee81fef2fe00513b0e56c04d1d3a21c7a4240fd469d48a4757b1ed45a(
    value: EciScalingConfigurationProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61c7f70fe419399ae79938b3af56e2520701645dca0d4af4aa40117e5ff4899d(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b78155524ac74038acaeb38336f9eaeeb5bef2f32e15fafca07ef8fa222f89a4(
    *,
    container_group_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    scaling_configuration_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    security_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    acr_registry_infos: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.AcrRegistryInfosProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    active_deadline_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    auto_create_eip: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    auto_match_image_cache: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    containers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.ContainersProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    cost_optimization: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cpu_options_core: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cpu_options_threads_per_core: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    data_cache_bucket: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    data_cache_bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    data_cache_pl: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    data_cache_provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    dns_config_name_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    dns_config_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.DnsConfigOptionsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    dns_config_searches: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    dns_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    egress_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    eip_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ephemeral_storage: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    host_aliases: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.HostAliasesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    host_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_registry_credentials: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.ImageRegistryCredentialsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    image_snapshot_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ingress_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    init_containers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.InitContainersProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    instance_family_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ipv6_address_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    load_balancer_weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ntp_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ram_role_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    restart_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_context_sysctls: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.SecurityContextSysctlsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosEciScalingConfiguration.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    termination_grace_period_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    volumes: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.VolumesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a46acbc5eea4a5d296bd421987f038384ed987aab61df47d148ad1b4a2652d98(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[LifecycleHookProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9af4bc06b84894559ee64939b8493f1f755461c8790a4b0dc1bc0b21a5147036(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff221ff9e556df1d9fc72b3f40ab3dd40db965ab7f0e14d09b55370b3d1a36d0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4aa3f16e803b3cd0cc4eb4a6751c60f5baebfebd7280c4056034163aa459fa9(
    value: LifecycleHookProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ad588985aca96043418aa5c3f2a5b04f9b207dfff2c57da644276053f28d34f(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39288e4e5a908e6823a89dff616afc7789d49b00d3caa357804e5bc122c3e567(
    *,
    lifecycle_transition: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    default_result: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    heartbeat_timeout: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    lifecycle_hook_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    notification_arn: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    notification_metadata: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62fe53d34abac965cf63ba70dddd384ffbbf6e7b88df744d6e4ffb35e5650dd7(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[LoadBalancerAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__746e2946fec566d7a4484982a19c7f0f25accc40e0884075b2b7ce5396b07236(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e4aeecc6037f428cdb9d9c87874e97f65168f12b2981eda77e4ba9ec1ff59b0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3eca8a0e5809818dce2237b196af6018ff7b701e40abeffce8116216048e3d88(
    value: LoadBalancerAttachmentProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89eca0685b8edc16d985a3cf31377c841c0bb6b7cbc36188a9186ab8734bab72(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d1ebb0e99a7f927dbf70ef94f674316b18b4477d2490cd795522db1f39bae62(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    load_balancer_configs: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosLoadBalancerAttachment.LoadBalancerConfigsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    load_balancers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3eb80b3c31c2b41e5d5e8306df2ab31c4ff39f81b50fe27869f0670ea1bfb40a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosAlarmTaskProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6796c5bba06fb562ed8b27c1c6fc84b2909c57695b8e15e7830e8839fb9387fb(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d13091f926f7657bec2ab7c0cd1af9a4512f4bc5ffa61c0cd120418385223df8(
    value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5be23e1c30e0fbae43c2696d9b53c74a9a5e2b247c81f3466d5a127a799d60f0(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f9dfdbb38418540a3d26cd424eeb263ef91660ec877023f7c95d7c0e12fd5a1(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8136464bf45f1d4649f7aa3ce5212fb707030b8defb693fadf82de892c2a11c4(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e63f19e679a5784a82c81a2b5b95a27fdff751e74206b3b98c7b1ae69249c615(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f04064a2f89e1ac709550173c46556bc9ae4907a64088c2ba0ec7ad51e7563e9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d678fc56c0f275e2b7d239bb27d284ca197989f69738f6d40b4f02d2f721aeeb(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bf48aa27bda8ead168e18ce80b7e0a45dc2cfcc6ebd5e3edc02bc3d44bc578d(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosAlarmTask.DimensionsProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ab01163c87782e041f2f0bfbf071af73581984504f002b705c2722f362b25ab(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17931261e9b56f5f58c5171c0f60301ccb8a2bcefb7a3b3eb833044ed170ac59(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccc57156b5d9f1d2228b9ac46f7627fecfeea0acec4ace57edb6317bc70badc0(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a013839a3b7b21230a3f8e9e7325093061786b809abb176f5dda53d02e2a5405(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1cdfaba7837beb53a11dbaf264a0b400a5c20ef658526e476b8a8282fa48cbea(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c54d43d13fd887073f924482638470f8912d843b7ed472754f29ec8d2a24da77(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__927873148fe5fdcb8f53aef85bccbbe2b446c081291af2be6a7f5f9232e9895a(
    *,
    dimension_key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    dimension_value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86714b938065c8c7d6551a5b836f5b46d7cf74e5faccc01f30939895d0504650(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosAlarmTaskEnableProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1970446a951382325d8bec921e95b93e0485e8f35b67350dc17f65380c338d2(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34b3fadf57d5228431617808f59a3be4380027130b828d42a521dfb6de499dc5(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79d619ff674ae5d503a6a7fa65e2e003480eaedefc0f4a732de13c065df2eaa5(
    value: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e31943b5be512c8bde7ae0e7022c0afe238ce1916157a33ea595a13e8c320b3(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2de0f32081aceab0bd1817d06a630419b7a6bbb55ef1059547c5a925dd800847(
    *,
    alarm_task_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    enable: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0c045eb527f889a67d502b0666891d9bb0b606496d0933a7ee0844124901b24(
    *,
    alarm_action: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    metric_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    threshold: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    comparison_operator: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    dimensions: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosAlarmTask.DimensionsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    group_id: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    metric_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    statistics: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5c1d94e48e33f7c11cff82fa747cc05fcbee422c36ac85018b8998da9e5330a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosEciScalingConfigurationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a3e3294dbf857cc26d0ad249e1f1b8b9cee070ec11e23b04db4d18205129ffd(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1595b8ec5e3da517ddace113991e16e62d1b107fa5987e8bbc78ba09415ad084(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72927c36addd5fa805153680e32f83e92782374d6a9147bf1a126c2f9a71ea3a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94f6e933d6afe07f84353132c90b2c0ee4fe8351b48f7349aa2afe4f59304c7e(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dde602ec77cd02f6692bd27676aae7f8111565e0eec9c81235161b31c8973f0b(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3583b534df7dd65037666c0286c6363790ecaa6ea04cf6aa5be3f5060b8de8bb(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42111fcfbee6e8903c4f61cf9cdb4de02c197e1c631edb2ad8e1e3401a42aeef(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.AcrRegistryInfosProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e63dc0c8d127b685f76869b976495db17f20e3199302e0c79321197c4d13ae39(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8757955c0cf1cc3e869168b326a422a2cba4b5793de85f1d5f3df722c82b3fc0(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88db3b098d11a0e5ef570688afa5c70e361e87be936e85349590ff30c1200f72(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5516e351022bc8f40e28ff7051321cef8ca3780483f0b0cc54b1c258f164a21(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.ContainersProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7a172789d99e1f9e20f43f8e0b2de99781427287dd96ca9f30ff9c126905bcb(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__902a3a398b334da43384a2979e01b8b06dae114cf3161f3f0c8e5a7511ea6c04(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4956467311e5c365b2c53cd45bb5c970e4b243a305b90e8f660a9eda1679cf07(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c614f008a578647d4a412bcd1e04f2ccf5a91b92950183820dddc5e0bd7ebd9(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6462fa76bd6299f1707f61143118800858865af0efa9797e6ef6d471622f3e2(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28ab08981010c07df6f5846d7baeffd912824407b74d334e2c85ff040ec92f22(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc78e6dcb307e70c2de75fa9c29dd6fad33d839c8ef19b9d1f6792135603b97d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adf18b16be00a0fa4b04b5e86a445a88ff719230e167031ae6f44e28ade7cadc(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__691bff489f315813d8c476193056b568b4d4aa6edc5360d7f869577882d98a09(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9987613d95bf4fdde8ceb05188229da7135a6033a0a8de66664cd9b2cabdb78a(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.DnsConfigOptionsProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd64aab24843f9f7cc07c8200033042422e592ea2d71f7beea3c099b2deddb53(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af8fb157cecd753253ed5705e919281efd7475c51a569c96b7c5d91633274702(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9688d2b9e7e41ee9fc41379f5b0b865267b294813ff15442f5e230acf67a9b8(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5b9a2f7d5dfd55e285dc20bc33844be609fb08cfdcf31df2dc441e390102b70(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f330a91967ee74512abca49e70ef3981a53d6b183f40dc1821c78633add371b(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f10803aace714c609259512b015d4b968f6852d898fc5979e82e2963cf09a9f(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.HostAliasesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09559f30fd79d7881f7c5a58c0ba7e7323d087ff06084807f5c696180d35e796(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__051082393b01b48fba2c600d4549f3f05d9e9bb46937ba7f8b70a58deba52af9(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.ImageRegistryCredentialsProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b139b8a2372e89acb4a7e6f117f9712b3f6aefb1fc2cbf8b946b589ea656eafa(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7a88b415c60df09821be0bbec34114ae1ad44b87ff9305896878c67cd4852ec(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c69aec5915dad12a97a657096c044663095c5975528b2539515603ed2377edd7(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.InitContainersProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0765a982548e8019b4cc835d12b495dd6686df931cde340be744774de190808(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0766ca54140ce9f286c0a5d4390196da15f7c50ec5bab58119a411bb2b6ab94(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6ecd64860aeffee7d3dd0d028ae6d50568440acfd770605fe2279fe94b3397c(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5651e4badd54d1c278f026f1c3b650aff370ea7d5994c22b4e2550772a794335(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__604e64f92e92a95bce3e77875844beaad21cb43c659eb9dadb509c96f9103b13(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1904679c97e96f6e3e2a578d338e55a936e23f253d8139d00e7223221fd28676(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b939e8a62fd22d50f7e3bbbf04e8bd190477b580a1a6017bf04f62c3d5fce1c4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e6ff50eb2b3fd06f75a7d580e47cf7260bc428733fa5ee1bbdd2d8ed18e7a96(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3aeb9eeffa8af2804227b16c12ee7457a4a25eaf4886e67a552976b6ff63e170(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eeb197eebe6c1d30ac58f865ad36473558e213cfb4f3cdaeef465c57f77666d0(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.SecurityContextSysctlsProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f832f5175c578e5c76a5de2e20c3fca71a08e83a21d3003273219f1cd2aa3b7(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98a84689628f1be8faf60c63ea4078da47c4ada57f1e3e716ee70f76444d1c19(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09dd498a8613c77a13c0cacc2d7c0c236e7c95ed31f7975dec9a0bb84d2c4933(
    value: typing.Optional[typing.List[RosEciScalingConfiguration.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__750e2f6a89e95b266866b93549b02571282af0889311af450d32b0dea9cef258(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62c38703c1d958c2ece5966398176faf79d5456d3d855808a9a0d8d4d46b214b(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosEciScalingConfiguration.VolumesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bafeb7b65a226e8881fa92dd717db233d3ba7b39fb180ffe980555366f7476c(
    *,
    instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    domains: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    instance_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__887853bfac1a566d05500956a325457df796764eb16d9292ce95bc979b258a70(
    *,
    path: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    content: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    mode: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef2b673e79853fd0265c258438c46538e47388664e7daf462f9825035a092956(
    *,
    image: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    args: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    commands: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    environment_vars: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.EnvironmentVarsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    gpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_pull_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_exec_commands: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    liveness_probe_failure_threshold: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_http_get_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_http_get_port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_http_get_scheme: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_initial_delay_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_period_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_success_threshold: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_tcp_socket_port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    liveness_probe_timeout_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ports: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.PortsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    readiness_probe_exec_commands: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    readiness_probe_failure_threshold: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    readiness_probe_http_get_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    readiness_probe_http_get_port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    readiness_probe_http_get_scheme: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    readiness_probe_initial_delay_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    readiness_probe_period_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    readiness_probe_success_threshold: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    readiness_probe_tcp_socket_port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    readiness_probe_timeout_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_context_capabilities_add: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    security_context_run_as_user: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    stdin: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    stdin_once: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tty: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    volume_mounts: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.VolumeMountsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    working_dir: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4552ceca2e0aa9aa04175ed7b3a498970fad83a02a24e5c7bfece86fc6abedf(
    *,
    name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d29abef720cee450a827324af882dc91cf773d9ca0592924b58786338d1afc0(
    *,
    key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e259bad51f461cdea1146866233a1e864009a39e22527e67c2cd66ea418bdd3(
    *,
    ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    hostnames: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a86573574f449fa3687b2285951ad1ce8cee97f6f90841d75f394b5f440e3eeb(
    *,
    password: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    server: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    user_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__885a60b86b8cc49c77ff00dd75a856bdb27b864bc96215db131b08d7709784d0(
    *,
    key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a0d7f06a62f52c062dc5590f87d60b48e8817a5443277d9820b5957923db460(
    *,
    name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    mount_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    mount_propagation: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    read_only: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    sub_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f017c9ad7ada79531dabc892f37ae9c555c876ef1cef11f3df9be1d6221db21b(
    *,
    image: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    args: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    commands: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    gpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_pull_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    init_container_environment_vars: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.InitContainerEnvironmentVarsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    init_container_volume_mounts: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.InitContainerVolumeMountsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_context_capabilities_add: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    security_context_run_as_user: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    working_dir: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70e67a5ca07333e8321bd0b9e226cc03ca0045ae37c4b0fc429a9029c95e05a0(
    *,
    port: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb506c9af7ae01f50b06d9cec92c7636e5732c0e339ed057e05e79834c6f1bf9(
    *,
    name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee399228c1d63e998cccab53248ddf5785ca9c39fc2d92dc9784ea81c3f20cb3(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e841ead24d9b47e35466acd9743b3e12b44eaab1168b4d6dd3e55545ce57906(
    *,
    mount_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    mount_propagation: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    read_only: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    sub_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbd9283c90fdeb3c67159528b37d03751c5875aa6da2cb5d47fce1ca609f87e3(
    *,
    name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    config_file_volume_config_file_to_paths: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.ConfigFileVolumeConfigFileToPathsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    config_file_volume_default_mode: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disk_volume_disk_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disk_volume_disk_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    empty_dir_volume_medium: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    empty_dir_volume_size_limit: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    flex_volume_driver: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    flex_volume_fs_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    flex_volume_options: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    host_path_volume_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    host_path_volume_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nfs_volume_path: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nfs_volume_read_only: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nfs_volume_server: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fa9c01f03cf393a6f19aee8bf6ad4d48077b24466f0bd3101d65c5015470b47(
    *,
    container_group_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    scaling_configuration_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    security_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    acr_registry_infos: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.AcrRegistryInfosProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    active_deadline_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    auto_create_eip: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    auto_match_image_cache: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    containers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.ContainersProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    cost_optimization: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cpu_options_core: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cpu_options_threads_per_core: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    data_cache_bucket: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    data_cache_bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    data_cache_pl: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    data_cache_provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    dns_config_name_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    dns_config_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.DnsConfigOptionsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    dns_config_searches: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    dns_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    egress_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    eip_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ephemeral_storage: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    host_aliases: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.HostAliasesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    host_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_registry_credentials: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.ImageRegistryCredentialsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    image_snapshot_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ingress_bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    init_containers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.InitContainersProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    instance_family_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ipv6_address_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    load_balancer_weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ntp_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ram_role_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    restart_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_context_sysctls: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.SecurityContextSysctlsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosEciScalingConfiguration.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    termination_grace_period_seconds: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    volumes: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosEciScalingConfiguration.VolumesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57fc91d59300f2336a829dda4336fca4ac11f861ae726b5665cbaf2ac7896d7a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosLifecycleHookProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__563fbf537f7f2273e12479327c31d8505c72a5d4c26cb8d51e655fac84f91f1b(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95d065d4f23e8eef8aa5fd7edd92721e2245694e4654f50a736876a5ef7b7643(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c13363b80b50095519ed91f638b1d9eb01b904905e81366d97081b667916733(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37fe5fbf2a782dff958f12ba54369b88a85baede98b47d7330f8902aa0415cb8(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6745b82ad4e1c00bf9b973d8ef3581f023e2e79433be4bfe28e56fe4f1a721b7(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5bb60926d7f23fa1e74fcd7976e770f42260bab55175f08aaa3e908ed90dae8(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95d2e9b29a1a604979ea9d8aaf662758fedb0b9572bccd910da9291841aebb16(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29048251e06c6a5e43b470a7f61fd643c99d57c1c9a954b45604da8537bd9541(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7adee079de4117785e3460431cc7da7925ecc448c7685c32e09f6c7583383077(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__345795d75b456d230f585dd18d3f509731a817828c61adb2a97fcb035a1b6979(
    *,
    lifecycle_transition: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    default_result: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    heartbeat_timeout: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    lifecycle_hook_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    notification_arn: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    notification_metadata: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__961c8bd385ec262ef9ab3840e388f8722bec7794f114732c0668fd3b8cf4073b(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosLoadBalancerAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e34492297afe3f420b968411f360b233afe06d52f99b89586c8a7f4896062dd9(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a8db7946cc94363a94aa3a3dc30a147a403571bc0f7bc24cc60baf317324ca4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e69ad2e3f71a5d56575f03c05069dbcac833022c2a3e160fe13558fc3ee6432(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f8ce650c86ae3724460dd8f30ceadc56a300eb28c8321bc7edb2cc590f8f32a(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a04dd62b04c34e9239bad9c7ee1eb49ede46f4ddae0a7dda35db0a76a0e8ce7(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosLoadBalancerAttachment.LoadBalancerConfigsProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59e877aafc4932abb675ae3c68433e455b5ab47b2818be612b78c705836e2858(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8905b9145f6b218e588c83b56ee0e9df0a4a729bee9b7d6a5c86daed6154d9e9(
    *,
    load_balancer_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d92760cafdb81677fdb1fd97cbe39aac8264baaad3789d261614f6e1ea69f01(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    load_balancer_configs: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosLoadBalancerAttachment.LoadBalancerConfigsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    load_balancers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc3736789ace51b21bdd3a49d37f206468c342c52ac58836d144f0ad0bf4c0b3(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosScalingConfigurationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce5fc6b0b04b705dcb94889a9b28263700dd07e064088a31128d0dcca0bfd6ff(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__677601f93c951dbba697f77d3d43fbc56744a2ebf62b9311403cd99503cfae57(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef08af6738238cf4e4c1164bfcb6d0ba5a2090cc7daad9c422f998fc46bf2976(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__108d521660dc86e34746f1ff1f0646487869024d59f224ba11d5cd7d49c8f083(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7379c6129374bdddf86a2e72b21dfe52ab706bbce03ea7e2e1a955c4503045dc(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59cad1eda38f8b1f3a519eda8eec57034069181365df94b7181c64191b3904ca(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be1849591ef4ab200da867a262a8778851b216ee75f3fff670a49a14c14de6de(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bccf97da4f501af5332dd1a446d88c6df992a21ff423811246dd338878510db(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__606c2339da212d24c73c450529b9fe22b8f0e42dc81d501c22c35e1e70974bee(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.DiskMappingsProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7454d0761f0ff372c417eb10319e916f7a9bd9096020f78f95808ac1ed433324(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc8259f421174d1c0e8469b66ff1ca8ba738dfb74325daa2013c4019dba223ee(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e7f892fd57c1468945a1e8d0aef617f820f835724ea5e103df5281cc8cf2a2c(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73ce4f619c8e8d29bee52fbba82dca5a791764d5e3b6f947c6c57e1b9408b868(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2bd4ab96a23f80dda993dd4e7eea21ee8ff11bdb921e80e5c20d5f717830d19a(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e9b5b848944a6142d06d1e43e33180547c78a8343499f2d6c236af25cb9053e(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c696b79a7c8acf18f4d7ffce8cf42a44fd61f6504a0cdc7547f9e7b6845959d3(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa70661252f24661fcab63e263e524859463b15f7ad7030f6a0827c66d9e6c8a(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90a7b777c5e3e9c274f9abefe866f66d0374573092a3c712d2c2c8d7e9583085(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8685d17f6d29d932480992f19ab5f674c62a24f8574b7071a45ecd0c33067e3e(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstancePatternInfosProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__499b99e8e9caf3e37220501480d14ffcdd37f171bc281b947c91b11e27ad984f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52e5db7e641abec46db3bdb63ac928b5e4f5cd0a8fa0198feb91e3a4141bc18c(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.InstanceTypeOverridesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c40e0ecaf94abb2433f8ee24dd27aef0953fb451acf9a7ff5bb95b818102ad0(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62bce03693933e15732b4dce2e438265e6eb8b152b7da5d639f8d5df2e327ac9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afe3eb121d779ad7a4f2b1a000e290a01dfc6ac1112763362511f54abf004459(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ebca14c40b2e5f8dafd24f736f6e7cddb5ac1fcda6f79ec0dd5a00bcf59c0fe(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d9337c47a3c04319e70c6e3e08aff2b439ca37f711547a69e148cbca33a9e89(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4e77bb5a6076dc184e17fe78d20d63bd473daecddd345ff77afc7ef0be861f0(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf8507da5e2684304087d5457b6af939b823a7f1b8eaa4352218db6ba016c2bc(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0e1476480a95d457d5860b75481675cb823c4c68737693da803b912f4a883c9(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fb2367746f52f1f30d3df05a59a3dd8c0a43593a16941a0071e64f27fb8e073(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f97d659ac8c2000d609920da7ec42611e7e47fdf53b6a542ff353da520d0b097(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e11312a10a96ffda3ba1a28a4a45086695bc163669c649cf51f575038a97cf2(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1daee1062f92e2c882d399ecf9350bce387dfa05c6e7de6d8866f507de80e467(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.PrivatePoolOptionsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6957f0fbf659bbfddecc46e4b1bd454b6e6f6a101dc7a56bd2054ad870b4bae4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__285e84e0da51e82ee3070d78b5a37cfb677b64889900647873c13b34c4265bae(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f326fb86f2d25015d3e15b87ed4b673bb36d3f822c8382804bfbf236bdd73031(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c71ce8bab5a98e432882f1924c1da91fde695b10b984a65cc50182fd4e3a26f5(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0a9c4e8fd23c88aee36c37063331c06480078aa58234cb0bd0de61d40b1bf28(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e97224c373ce70670616a24e381166860b051512514d4ac32f88aacf040441e4(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07f7b3cd10964e4a6974538f46ef760af035a7ff7e03f95970b1625faaa0b202(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eea29678ed7ce88aeeededa614412e50d322a9ff018dabb7a0c512a4d013fcaf(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5923896a7836c06a59c03cf6dfae4661aee5e0262516a32d908422e5303f95e(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84df159d08dbf2b916e17aecb46858724488564bd2c2bbcd74f879ff441f4994(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82183a4e74d7c5bf1696a2dacad67d9a6b499c7b9586f0895533b69a7b1bd447(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__005e62578e59057a9e0c73dd92bea6e8961433c82cab3490c637ce3357dd83d3(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e273b5850a310395fe1592b15ff1848c1835fdf6583b14107a2fa23512f7a2da(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fb0586c2335d3daad0feae6ed4663251982450525300d5e9f7efafb8b1e1931(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53c95809a2d2aa1a7a5db90b65f1f5ddb03fa7dd67386f85ee7bb31324c7f5c7(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf5c1f5fa362889cf95c569a43e014f013749a9485084df420351a6ed65feca8(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62d6f8be398f7ca22f17712b07582255036c4b65c0801766ccbb827ae47c189e(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04ed1c07f81060372984760f7ebaafa0ed9724f1a3c8aae891a85520c59ad985(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45a73fc36b84d2c8b76bcae1656bb0267aaa77d4a0c4f2ac0a7ff45ba35dab74(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e20f671b6f1f37a981aba385b3cc60791017e7eea371079d5c2848d963616eae(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20ef09969b6c99e34652e5b2667ded51363e7a7c313f96f346c2d497d8cc3d5e(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a73425c441c415a2410bddda46c5f3ccb3ba79433c15b83dd9b0f1b59a294b4f(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67afe00d58cf231eb7ac3fb6d20a5d57f5a5d97715838efea03719bb35274d87(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4d794f90bc9a0d9a63fac47f839b7179ea525633a90bbfb1e5e25df0f1479fb(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingConfiguration.TagListProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea65102667116d8b14b389e9f55dc8ade376ea10c90bbefe74a6e5acbc721adc(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a35c288ff84684af77eecedbac0b5b5e3e217408c1bc24487558436ace951c36(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d0aba72d23d92660608444287ded7823802fdd5bb007837dda9514e49e996d8(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b66734dff1e85145b6907c20fedb10194946ad52ef783e3df39fede6235aab5(
    *,
    auto_snapshot_policy_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    categories: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    category: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    delete_with_instance: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    device: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disk_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    encrypted: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    kms_key_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    performance_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    size: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    snapshot_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45c3c52027a82825ec576c0beadee9b0534f99e85e7ed7752e9e032bcca10689(
    *,
    architectures: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    burstable_performance: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cores: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    excluded_instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    instance_family_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    max_price: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__181783adb53885162463202afc6641a4c6c7415934934c4d866cd2ab39cb73ce(
    *,
    instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    weighted_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df368e21643e5131a5135d400a904db38cb23dd35b82daa617b7963be87e3f06(
    *,
    id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    match_criteria: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7fc9909d468266827c82c3c6fd1c807046dd022f01a8aca3c828f004e50bae89(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__905bee6bae5d29de4a63d35773e0cffe2dc5253364ba66148204dae2c1fce9fb(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    affinity: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    credit_specification: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    dedicated_host_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deployment_set_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disk_mappings: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.DiskMappingsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    host_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    hpc_cluster_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_family: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_options_login_as_non_root: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_pattern_infos: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.InstancePatternInfosProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_type_overrides: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.InstanceTypeOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_max_bandwidth_in: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_max_bandwidth_out: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    io_optimized: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipv6_address_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    key_pair_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    load_balancer_weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    password: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    password_inherit: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    private_pool_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.PrivatePoolOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ram_role_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_configuration_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_enhancement_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_group_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    spot_duration: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_interruption_behavior: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_price_limit_for_instance_type: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]] = None,
    spot_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_auto_snapshot_policy_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_categories: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    system_disk_category: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_disk_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_encrypt_algorithm: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_encrypted: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_kms_key_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_performance_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tag_list: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.TagListProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tenancy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    user_data: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    zone_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfa8b82548057b4e9d5f9c6bd95ae16437c0db8d85167b967047184a24f0a34b(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosScalingGroupProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7398d701f1411574f7cd0f34f85c5290dd37a39695ad3d0ea3df46c073c00358(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae7fa6593d4f0ea468c6cc425c55de188d9e0de2cd943d4dc09b0bb61700d2fe(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__259d3ba494d0f568e0bece082a54d68311b0fe3761742166fd72c7a0cbc8c618(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a856925e6a009a3cc49de033c3276063254e99fdc4199f22d9b0d27a2fb739e5(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f226b1c92924883009e3639ee437d170ccc1c2c061a413d4db9deadf6f60a0ce(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__325e4b22ada2192ccdfc2e79847ec39620e7ec6e2c09019df52bca25dc34af61(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__622e769201dfa85f491249382aa53de1745e68a31d350f7c47449add7de8d6aa(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba6e0b53d0a7502850e4c9644d38a94b48668220098ada358e96431b9276ed1d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52a9680bc4c0d1237fd88fef783c5f1711f8a59d6a6dfe9eec287146d5c606e9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a30f6746f533d8bfd535369285272c733415eb661498aab045acd6bfe09822b7(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6f937972608ea2d4024eeed7b11364fec06288f2c7fdf5b2309c67078fe1c51(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4d5eb01602656e907db7fa24e08bbef91d742852c9a2e7fbf3b985b5b6a5721(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2400a8e87ed65ba3de3bf8c4a801684544c22766a78437b98ac93a630feb9eea(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20e1ecf3ca71846d8209c14231525cd5c8634b6c8a11e18fcb393324775400a5(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39253d0e28ca008795d0e03f22a05e9eb793a226848740b2c8c93a87f40b002f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abd6d54f88a291134c2ab9e40c41139ef3fe50d4c4a0725117908c4194e784d7(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39df13437fa9d0f777138c254bbfdf5e177b9c7567289c0238c53d80f3baf93d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e933e92bb09e7b956484ae54909f8983cee5dad4075a0f1dc6ad7a77639bbb9e(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.LaunchTemplateOverridesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a7c9656e1d9d041f0b9dccaa5f9c4490acce3611b5eb453537598aac85b0046(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54a6b0c08e5cbb1033dd2411ccb79487a9b3b0454c38a47d1dbc63776b46187a(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3e6ab024fdd04e2f2be22cd7a1a34b359b86ff5bf23407c63c47d6dcaaca740(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0aeb879a5358ae247001507514d85e74668f2fbf068b939a223caf731f19d8fd(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a780f6d8e00e2de9fe9587c2335da4daed205a167b2778888fc9cba167ef7af(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.NotificationConfigurationsProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__677d6daacd8b880640a37b24380ed5f265f12a7686e4031c18876a953b4c5fdc(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a47bff9878f440174c1d06ffe17ef4e291f072f8691c8f1745288f50fd2a7d3(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ba23d4f1b1b13986485448c4865c1d362996e81ee96cc8d218fb89f43a55a96(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb1ae7bf69ce03ecdbf38049030bd93a03fe9edd6fe96d4bfce1e2e93b9f7437(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b04f8536f9d951f05ffcdd0fe60f1b97b5774a1feb54191c907648f114226377(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bea7851a0061153bcc143cb3c742b3a13f0f5cd4b7f09d3a120a41418304e4bf(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ce2499e40584a3bd5f1841bc51e26bd5230900b632f0c7e37fc76821057c12f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31dd1d9829bf55cbdc7d1ffe8c8dcf9f0ef230bfb0937e58b783ccd8d3eeb45e(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroup.ServerGroupsProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3467af9ff6f58714e69024cf8e1c08c8ec32d09d65f2c96e03714d85db51dc36(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__250942cb908afa21269feab72a08272451f38f9a2fbaba3c788d007ce3041810(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6b4928d284d8a5350acf8f00970f9e38a3a4b404badfddf4cfe55229a465980(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d9134ca622ee4a84454600eca80eaf573db508d200fa87f96aafe5ad5aaf74a(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f2e42911155afe3a66f087f36a15fb0a83ceebffcac36295bf25ce501cc4767(
    value: typing.Optional[typing.List[RosScalingGroup.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3daa4ce0b286e8173a9e1a47cf7593525e2cc43d1c96a8b2cac05773dbee6d33(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36d11bd02cd8c7ad32271c095146f7debd4bdef9d154248513dc830616b9f1ee(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__303a3d099eb216d8e0077bcde5871faae7fced1edd21e752245715afa1dc448c(
    *,
    instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    weighted_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa7fa1fd449930accb4c85d6202b4d7d427d20d67d67beb5ddbf1bc67b59f0d6(
    *,
    notification_arn: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    notification_types: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef24b8cd6ca2231b8e170ead63a5169d9a28e001a39c3096aecfaf8b11197d19(
    *,
    port: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    server_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc33954b83be2fe3bd435e61f80f69cdb44ec4d010264a424306a240cb55df80(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__347186367dab8c2838a3b5398a7d156c3f4e5025a4de886e82129dd1ba41c169(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosScalingGroupEnableProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8e7288c2591fe281bba6364a65ffa61dc280dcdbae28c8923890b3cd370a946(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c384b1680b0320bbf43dc5611d960429649b8095fd63f17cfbd384caac52d9e(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea368f54cc5fdae60852e1324fa97da9bbd07cc977bd449949ec35d3b8090e1b(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73b2950b30fc844ecd2d8aac5fcf64d2bac8a36488f62c720a2a3b8e5a2d571b(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.AttachOptionsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc2f9caf6b3eba7590f2192165362232567fa88bc3783179a48375c069c02fbf(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingGroupEnable.DetachOptionsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3833515c0b41629f2fda361d9ef5538668c22cb3d8232b522468d281e5e0698(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9ef031b2973f79001952ee47d835cc810d376904191390090b0818757a45e29(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__300913eaef0df2391f749e278ca8589356ebfecf16fcb552d8c98a8f3b02b91c(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c3c18288a0119ab7701236090591d4f28465a4a8656526525be25140d7444e5(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc33c8b007ec3836c344a45b6e7f6616f99acfbbdfd9d4cbf5d4d872106c19c3(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae68c32181514bf62b7a3ce7d5d23e3c8c9df1a43ad7ab86bc8c64e6ffcbbdfc(
    *,
    entrusted: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    lifecycle_hook: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c471aa1063b0248a3e90b088766fe7831bb33481b0b57231d71984ed6b171e1(
    *,
    decrease_desired_capacity: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    detach_option: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    lifecycle_hook: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b65de3797a1bd96a4bdbb7a3cb2c3fb6fbbb3222213d00245060648693f3001b(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    attach_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroupEnable.AttachOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    detach_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroupEnable.DetachOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    remove_instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    scaling_configuration_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_rule_aris: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    scaling_rule_aris_execute_version: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e755f6c8f9fe533d501c4e7f9273d2f128084280f4bc51b10d896f0712e52d9(
    *,
    max_size: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    min_size: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    allocation_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    az_balance: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    compensate_with_on_demand: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    container_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    custom_policy_arn: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    db_instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    default_cooldown: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    desired_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    group_deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    group_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    launch_template_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    launch_template_overrides: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.LaunchTemplateOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    launch_template_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    load_balancer_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    max_instance_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    multi_az_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    notification_configurations: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.NotificationConfigurationsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    on_demand_base_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    on_demand_percentage_above_base_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    protected_instances: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    removal_policys: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_group_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    server_groups: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.ServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    spot_allocation_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_instance_pools: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_instance_remedy: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    standby_instances: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosScalingGroup.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    v_switch_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__129b235f4eebc982530995cc5c759cbfddbf9d61bdc476c26f55e55462c0a47c(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosScalingRuleProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8f5df0f2651efca94af2ad637c4d076fee945e41d4b9c13f77e7ba12c76aab5(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57c0a09d4b44ab20f853c445d3fd3cc56234dadce859970e1a0a0f8419f2d531(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c786db50f0a0f208c14558dcff68da6ff01f36305987e4643999f0d33b726238(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0d08278a5941d5fc64f3cda4e1f20843b36184fdd09b8083d6df2b650413803(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3087f00334aaf4ee344fd254d89a2c4643e8236560017433383aafadae3bd15a(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83751912a78083bfe569a097fbedc39acb72ea9202ae8ddd81b5e9c493e65304(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37102122d52769f82116ce2761888967a01f71d319ac85fb878664a7a488d3bd(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b33d48f90948bb29e1ead1998a5cfb53d5da5b6baf4bb800ebf47e3dc6cd4a4(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5cd06447e1435c72ef1948e66e5738a1e71d1b925533926d2824bede3f7ab48(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__765812aec3b0ba0dfcbc69e1347f72c82021308c7efd977d51c04cef169b9c04(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b38a038b71ef903e183940ec184860def6fed0982ffedd1c4b5fbb1c17ad765(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a9732fed780bba511e36c946c860307ba4e43f521887ed5969bd24f51cd89fdf(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ecadcf7d9ae6085d18fb768f68f2c5f193ba68ff8e80f320521be434333dc29(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2e8f2b798bb2ffe28dae2451cbd9d2e91a9b506b087cf06a14a56fcab5750fe(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60b00be9933eaaaa3ca12b96b1ce5a9298888ab2b96d413f7c024d4f695b6182(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e944483e08ddeb0e7c19cb4f0e53cb0fabf2388aba72b723de37dff4d3286b6c(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6071067a4d7e8288aee6f29d57af947d67dd9af024ecd42fbe8156336fa50f1f(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b02c61d6b611e4a6b430a7bb7315cf8502d84d38d25450bdfa0e4c51ea58686d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99914e36616f4c5c8ad3cbd2f4cc409802dbc438af82e13fe264c20e4a0e5c7f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a4ba87bab268177a60fd866c0368f70f81f77db523524df16c020287892a9ce(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosScalingRule.StepAdjustmentProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8558041a7aa6a89b3a438f65522624bad1cb351b19ee16e2aa031baa036ba992(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__821668dd812ead5b65c516c242d21b27465f7caae0485b61275e9c845cea774b(
    *,
    metric_interval_lower_bound: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    metric_interval_upper_bound: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_adjustment: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbe292b0457dab715dd98b25a68cdefe5eca34a305fe53a40b812a933ae11822(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    adjustment_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    adjustment_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cooldown: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disable_scale_in: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    estimated_instance_warmup: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    initial_max_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    metric_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    min_adjustment_magnitude: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    predictive_scaling_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    predictive_task_buffer_time: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    predictive_value_behavior: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    predictive_value_buffer: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scale_in_evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scale_out_evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_rule_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_rule_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    step_adjustment: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingRule.StepAdjustmentProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    target_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e70bc04b53edd53f3bce0d503df1523fd03bd0bb516a961c08ff699dce3b0d94(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosScheduledTaskProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fd96b316a1db63f4c53ecbf41f6c0e15447938bc46d7e6dd994c797869bc0d7(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d682d90f2764c362b0de59bffcb4db1466d1c383f844873148e15df9d978b2a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb31aa7f563691cd64cc155834eac90ec976155d775b5c706c8d6fb0b4f9bb68(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2eaa8eddc926f15444baa0faaddf87b3525da669452adebcf9549227412b6ac2(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9575497ac97a4c47f0569078655742bbb72a8174525f53d144e8ba7c78335344(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e700a30e7f61f86e59e301f681b402ab4341088b6d35971b4e9b05f6d5f5867(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17959617e4a579a72857eda6b31880d5dacad153cb9b06e24d32d7780c9046bf(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2c316039d0ee171759a07b363ca5d57155e93e7ab5110dbd065a99a02e406df(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bb418b7d86edd47711bdab2f47a953a6b008bae794e5aeb7546a62f48263115(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6285fe5c3af7751d4321494438fe4d1639cb594587bd7e2d2c6678abb74f87fb(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1879f07c89ce8b289202d204538baf837ed6631d533a729a3b67443b096e479(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e2b689c1a4fd9eb3949e2aa762c3c594583354c96efbbcc1f80b8a299daefe4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe8c4ff427551c663031027c2073507221d497209aa1910de654a5ac9a9ab9b1(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0c23ca1c33c432e39e4e13c90c13d50e98cac54b7e6ba7060b2161752e983d7(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3033cc4ab6eb4a69c3792d5564a9c17dfd649986fea21f84f7eedf279ee4fe2a(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7edbad4a9e9b4186746734093edc2a4cde597d704007910bdb61acd82821ecbd(
    *,
    launch_time: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    desired_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    launch_expiration_time: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    max_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    min_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    recurrence_end_time: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    recurrence_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    recurrence_value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scheduled_action: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scheduled_task_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    task_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d66cb44da9dc058cc161ebec2ab43db644f1f98b96e3fe515ec7964888608ea3(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosServerGroupAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f4b79d3cf9f0e41fa8e07e1a23c2fa7d79e0c3e5f46165ee85085275d49709e(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdbae87cba96d50aeb537fe96775932b54796824b94469e14723f6be24c0c2da(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5eb48bc2a1c798164da5f9c2aac437d9687fbfbf668bc7bafa217cbb1746beb2(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca58907bfaca409ffe5abfa667f98685dc10d1e97732d157ccd3ae281e55a197(
    value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosServerGroupAttachment.ServerGroupsProperty]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95f9b530f89980e8ca5828f39be7a23f8fbc9d45335912e7731b09de6150444e(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__036603b41cb0389b758807236ac54d279545594ba19650113d7c267f866072da(
    *,
    port: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    server_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fe123fb375be825f820c3a8e3b8421ae8c7a08538ced0a38d6721b6be7206a5(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    server_groups: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosServerGroupAttachment.ServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]],
    force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47a7cbc3bc6aaf8d24d08f6acf23c7ed1bfd31586eac86225b0ea721a18a15bc(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosVServerGroupAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3cb910ddf964228679a36936a31b08b6f9bd6b78f33ca08f1260e82bf84fa27(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1320f11624eea5f56ece49e6c8a302e3eb09a56e3b27793e6fa55d819877a62a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8acbaa9f57341e0acc4b5b5ed14786db224e9ff8219112934810265a85e8050(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__451db23fc72b05a74fb69974a46f40f3410c21684453c3b444a565d656eac874(
    value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVServerGroupAttachment.VServerGroupsProperty]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c4e5bbc3a9dea2c733b079857cbc25ab7e1f80d0aaa2334eade7584e93b9bef(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3bcf5c96a6970208ec27964aed5399fc680a2bab05ddb277dc2c82d49fe2a864(
    *,
    port: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    v_server_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7434adc6c5717e87e2ee474ca25f2e7e29254b714af4df15e4256fc549799d0(
    *,
    load_balancer_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    v_server_group_attributes: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVServerGroupAttachment.VServerGroupAttributesProperty, typing.Dict[builtins.str, typing.Any]]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c40151e32f3620a0a4f64c6a3763a8c679ac1ed4738db19dd4c702e4e15ce0d(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    v_server_groups: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVServerGroupAttachment.VServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]],
    force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a01e47ae6081577d2e6bcdab5668699ae058a3f0638a8fa9db1cdf5079c0c36(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[ScalingConfigurationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0395fae06d53f50cd9f9721a24c9bf49b852a775525223805b3fe0e9f4844817(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de3f33fec236662862eeba4a2c859474f30c8a91ab86fc7e5a86d93ebc83cf78(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35d084ee45c5510ffa281ce8bc7f2ade9884bb0b98d5440bdb915d28b861fde9(
    value: ScalingConfigurationProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec8adba54c443a74b1f71dd1817f2b6bbd9af97bda270758debf165d15d22ee5(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be85fb0fd4f1e809db57a66f784b75c19396cdd108753cbbde82e04a20a72d09(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    affinity: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cpu: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    credit_specification: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    dedicated_host_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deployment_set_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disk_mappings: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.DiskMappingsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    host_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    hpc_cluster_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_family: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    image_options_login_as_non_root: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_pattern_infos: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.InstancePatternInfosProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_type_overrides: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.InstanceTypeOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    instance_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_max_bandwidth_in: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_max_bandwidth_out: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    io_optimized: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipv6_address_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    key_pair_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    load_balancer_weight: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    memory: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    password: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    password_inherit: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    private_pool_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.PrivatePoolOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ram_role_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_configuration_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_enhancement_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_group_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    spot_duration: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_interruption_behavior: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_price_limit: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_price_limit_for_instance_type: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Mapping[builtins.str, typing.Any]]] = None,
    spot_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_auto_snapshot_policy_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_bursting_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_categories: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    system_disk_category: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_disk_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_encrypt_algorithm: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_encrypted: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_kms_key_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_performance_level: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_provisioned_iops: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    system_disk_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tag_list: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingConfiguration.TagListProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tenancy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    user_data: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    zone_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68b84de07d5e2051623b6d18059552a6bcb0125c57e505bde03ea2c19f8aec8d(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[ScalingGroupProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7b16117c87ba7bd7a0d4f0b467240c6c2cbf2a39cd3fa024d78fe5101658d25(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc16af027ada6422aba14a6b5bb4c99a9742633e2983ff20aa15a32fe5ac6632(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f758a095c4694bfb65eb64992aaf4de500dd9bb7a591df22314cbb54ad5c8469(
    value: ScalingGroupProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea2e9341d1fe7ce40ea43705013012e95bc0d18b5e7c4ce3536921fc4d5d3dfc(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d396c56ec076a081bf3195c789f7b407df745b52da435f8622a04bc50a684ec9(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[ScalingGroupEnableProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ad26d452cacf826b1d10c8b88038291eaff1a2bf26ae45fa3b8ff686391c979(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9fd7cae9848d5a2d39df88ce26d58239a5ae15a5b0986ec2eeba31e427b8e0b6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c369196601919501d33ecdc6fe8876eeba30b688433c7cdaa444b3c268f152e9(
    value: ScalingGroupEnableProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78370563c4e134077d20c9c76a9db5098dab5338908e2af8d2a822f6c553c1f3(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27aa303aa686a6ae2cb5d268aa52c8632e0533ee95ea0d8c480839bc60d34365(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    attach_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroupEnable.AttachOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    detach_options: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroupEnable.DetachOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    remove_instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    scaling_configuration_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_rule_aris: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    scaling_rule_aris_execute_version: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6837af1a639272cbc496040a393943d064eb5b0b946dc9e706e4ca881d10b4ba(
    *,
    max_size: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    min_size: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    allocation_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    az_balance: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    compensate_with_on_demand: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    container_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    custom_policy_arn: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    db_instance_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    default_cooldown: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    desired_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    group_deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    group_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    launch_template_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    launch_template_overrides: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.LaunchTemplateOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    launch_template_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    load_balancer_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    max_instance_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    multi_az_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    notification_configurations: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.NotificationConfigurationsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    on_demand_base_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    on_demand_percentage_above_base_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    protected_instances: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    removal_policys: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_group_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    server_groups: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingGroup.ServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    spot_allocation_strategy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_instance_pools: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spot_instance_remedy: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    standby_instances: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosScalingGroup.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    v_switch_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28114355f5083d0439f61b045758db9345ad9c7c8c56da82f7d33b1cb5803910(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[ScalingRuleProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79c8386db18265a921eaa0628996eaa54568721e293584cc9881a394c346a305(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b802fc6903d8d1356dc5436db70b776e7f3699f8aee6c367c01ec1f0913696e6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__249e9795c16f7e465f235b09adcd9d3320288fd568bb591ab5afc13ae780bd01(
    value: ScalingRuleProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ffde865bcd630a9e4902965b5e1b81b5efe6a45a159c29fc672576b45cf6436(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a303e009feea4147bbfda85fb8136affa7e8281bb9359bd8b6996aaf2647a1b(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    adjustment_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    adjustment_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    cooldown: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disable_scale_in: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    estimated_instance_warmup: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    initial_max_size: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    metric_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    min_adjustment_magnitude: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    predictive_scaling_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    predictive_task_buffer_time: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    predictive_value_behavior: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    predictive_value_buffer: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scale_in_evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scale_out_evaluation_count: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_rule_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_rule_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    step_adjustment: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosScalingRule.StepAdjustmentProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    target_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__467b0ccce54c5e5c1a707486ece3255fafd9b19dcf2f7146927ec16858c4df14(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[ScheduledTaskProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2afdf1f5f8f6d827005eefba5ee943016d27c56906338968a3454757b6d800f4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64a8c30770eb271296c31c5d414929c5f90d91ffe5485a4a8f4f758fbf166d02(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c3713261d1a913ac26a34888837ce94ab977e70b3c79da044fffb56ffcc5fd7(
    value: ScheduledTaskProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21cfad50534c50b0f7b942b1ad8e6cafa78be07f504531f70a06aff819761992(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7004c843a4bba26c274ecbc7e81a969c44737fec24320bbb2366215d1aaa92f9(
    *,
    launch_time: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    desired_capacity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    launch_expiration_time: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    max_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    min_value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    recurrence_end_time: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    recurrence_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    recurrence_value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scaling_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scheduled_action: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    scheduled_task_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    task_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b21d7ab1118b975bcb042769d90ca65a925a5007a54fdd34125384321ea8b3ab(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[ServerGroupAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b354edc749bcfcebd56673b2857a22fafc1a4d0023d3390d096c1befc3c9f42(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3577d32d23d2957037421faecaec3aeb3585bd376dc1c3f77edd8d438b44004(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__814614d5cc37f71818137aff5480971d3d0ebf7a2454c7dfe7edea3645549c76(
    value: ServerGroupAttachmentProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a9999ef94f8ff59ffc8b7696623f11ebc4d1e1a08061240f530c156017ff65eb(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a14a629697d6d8c9c32dd794afc4333a4889f79099a1fbbb5764caa19e2aa48(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    server_groups: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosServerGroupAttachment.ServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]],
    force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0336e2df938044a599be1ee8ef82e6699b485c36595bfba8e9870d5807934d28(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[VServerGroupAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ff15cd957254b846e90a1dc1ce8fb112a8bfe8f86dfa1249f72c063ed75a75a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c997793d504cb2974904a0eda5d642e7ecb848708a36c165cc7ff625c50ff2bf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f225bb4d3167e4842046975f679d156f29aa92740894c24004050e06ead320fe(
    value: VServerGroupAttachmentProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a95407a74c79eff937e734a0c26f6d5067142843ee91edd348ee97de0a6193cc(
    value: _ros_cdk_core_7adfd82f.Construct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f08b25875adfe287f2a814c6ba297536f62629bea912d653945184670fb3bdf8(
    *,
    scaling_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    v_server_groups: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVServerGroupAttachment.VServerGroupsProperty, typing.Dict[builtins.str, typing.Any]]]]],
    force_attach: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass
