'''
## Aliyun ROS VPC Construct Library

This module is part of the AliCloud ROS Cloud Development Kit (ROS CDK) project.

```python
import * as VPC from '@alicloud/ros-cdk-vpc';
```
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import ros_cdk_core as _ros_cdk_core_7adfd82f


class AnycastEIP(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.AnycastEIP",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::AnycastEIP``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosAnycastEIP``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-anycasteip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Optional[typing.Union["AnycastEIPProps", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cebddfc9b32fc21ec059058e90be3c0bd145eb7a8d744237c9944c4cf07f2a40)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrAnycastId")
    def attr_anycast_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute AnycastId: Anycast EIP instance ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAnycastId"))

    @builtins.property
    @jsii.member(jsii_name="attrIpAddress")
    def attr_ip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute IpAddress: Anycase IP address.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpAddress"))

    @builtins.property
    @jsii.member(jsii_name="attrName")
    def attr_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Name: Anycast EIP instance name.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrName"))

    @builtins.property
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute OrderId: Order ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOrderId"))


class AnycastEIPAssociation(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.AnycastEIPAssociation",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::AnycastEIPAssociation``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosAnycastEIPAssociation``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-anycasteipassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["AnycastEIPAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__166fb29b693ed9ff04eb19406ca6b56101789793eb8eee09970d59231594cb70)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrAnycastId")
    def attr_anycast_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute AnycastId: Anycast EIP instance ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAnycastId"))

    @builtins.property
    @jsii.member(jsii_name="attrBindInstanceId")
    def attr_bind_instance_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute BindInstanceId: The ID of the cloud resource instance to be bound.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBindInstanceId"))

    @builtins.property
    @jsii.member(jsii_name="attrBindInstanceRegionId")
    def attr_bind_instance_region_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute BindInstanceRegionId: The region ID of the cloud resource instance to be bound.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBindInstanceRegionId"))

    @builtins.property
    @jsii.member(jsii_name="attrBindInstanceType")
    def attr_bind_instance_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute BindInstanceType: The cloud resource instance type to be bound.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBindInstanceType"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.AnycastEIPAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "anycast_id": "anycastId",
        "bind_instance_id": "bindInstanceId",
        "bind_instance_region_id": "bindInstanceRegionId",
        "bind_instance_type": "bindInstanceType",
    },
)
class AnycastEIPAssociationProps:
    def __init__(
        self,
        *,
        anycast_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        bind_instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        bind_instance_region_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        bind_instance_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``AnycastEIPAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-anycasteipassociation

        :param anycast_id: Property anycastId: Anycast EIP instance ID.
        :param bind_instance_id: Property bindInstanceId: The ID of the cloud resource instance to be bound.
        :param bind_instance_region_id: Property bindInstanceRegionId: The region ID of the cloud resource instance to be bound.
        :param bind_instance_type: Property bindInstanceType: The cloud resource instance type to be bound. Valid value: SlbInstance, SLB instance of private network type.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffcc3fa03387338053d8883b2d7c9c5d6d0be7b48cafdd2fec7b62123a31d067)
            check_type(argname="argument anycast_id", value=anycast_id, expected_type=type_hints["anycast_id"])
            check_type(argname="argument bind_instance_id", value=bind_instance_id, expected_type=type_hints["bind_instance_id"])
            check_type(argname="argument bind_instance_region_id", value=bind_instance_region_id, expected_type=type_hints["bind_instance_region_id"])
            check_type(argname="argument bind_instance_type", value=bind_instance_type, expected_type=type_hints["bind_instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "anycast_id": anycast_id,
            "bind_instance_id": bind_instance_id,
            "bind_instance_region_id": bind_instance_region_id,
            "bind_instance_type": bind_instance_type,
        }

    @builtins.property
    def anycast_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property anycastId: Anycast EIP instance ID.'''
        result = self._values.get("anycast_id")
        assert result is not None, "Required property 'anycast_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def bind_instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property bindInstanceId: The ID of the cloud resource instance to be bound.'''
        result = self._values.get("bind_instance_id")
        assert result is not None, "Required property 'bind_instance_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def bind_instance_region_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property bindInstanceRegionId: The region ID of the cloud resource instance to be bound.'''
        result = self._values.get("bind_instance_region_id")
        assert result is not None, "Required property 'bind_instance_region_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def bind_instance_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property bindInstanceType: The cloud resource instance type to be bound.

        Valid value: SlbInstance, SLB instance of private network type.
        '''
        result = self._values.get("bind_instance_type")
        assert result is not None, "Required property 'bind_instance_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AnycastEIPAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.AnycastEIPProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "description": "description",
        "instance_charge_type": "instanceChargeType",
        "internet_charge_type": "internetChargeType",
        "name": "name",
        "service_location": "serviceLocation",
    },
)
class AnycastEIPProps:
    def __init__(
        self,
        *,
        bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        service_location: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``AnycastEIP``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-anycasteip

        :param bandwidth: Property bandwidth: Anycast EIP instance bandwidth.
        :param description: Property description: Anycast EIP instance description.
        :param instance_charge_type: Property instanceChargeType: Anycast EIP instance charge type.
        :param internet_charge_type: Property internetChargeType: Anycast EIP instance access public network billing method.
        :param name: Property name: Anycast EIP instance name.
        :param service_location: Property serviceLocation: Anycast EIP instance access area.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__946956441595afdf68de9841caa54233890fc8d2174245e933aa9cbd1a786564)
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument service_location", value=service_location, expected_type=type_hints["service_location"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bandwidth is not None:
            self._values["bandwidth"] = bandwidth
        if description is not None:
            self._values["description"] = description
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if name is not None:
            self._values["name"] = name
        if service_location is not None:
            self._values["service_location"] = service_location

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property bandwidth: Anycast EIP instance bandwidth.'''
        result = self._values.get("bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Anycast EIP instance description.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceChargeType: Anycast EIP instance charge type.'''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetChargeType: Anycast EIP instance access public network billing method.'''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: Anycast EIP instance name.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def service_location(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property serviceLocation: Anycast EIP instance access area.'''
        result = self._values.get("service_location")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AnycastEIPProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BgpGroup(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.BgpGroup",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::BgpGroup``, which is used to create a Border Gateway Protocol (BGP) (Multi-ISP) group for a specified virtual border router (VBR).

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosBgpGroup``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgpgroup
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["BgpGroupProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcff6efde966e36b9b1d875ea0ddd3e0d7216a305ed3a31d9fe1ab2e80faf622)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrBgpGroupId")
    def attr_bgp_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute BgpGroupId: The ID of the BGP group.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBgpGroupId"))

    @builtins.property
    @jsii.member(jsii_name="attrName")
    def attr_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Name: The name of the BGP group.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrName"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.BgpGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "peer_asn": "peerAsn",
        "router_id": "routerId",
        "auth_key": "authKey",
        "description": "description",
        "is_fake_asn": "isFakeAsn",
        "local_asn": "localAsn",
        "name": "name",
    },
)
class BgpGroupProps:
    def __init__(
        self,
        *,
        peer_asn: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auth_key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        is_fake_asn: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``BgpGroup``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgpgroup

        :param peer_asn: Property peerAsn: The AS number of the BGP peer.
        :param router_id: Property routerId: The ID of the VBR.
        :param auth_key: Property authKey: The authentication key of the BGP group.
        :param description: Property description: The description of the BGP group. The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        :param is_fake_asn: Property isFakeAsn: A router that runs BGP typically belongs to only one AS. In some cases, for example, the AS needs to be migrated or is merged with another AS, a new AS number replaces the original one.
        :param local_asn: Property localAsn: The AS number on the Alibaba Cloud side.
        :param name: Property name: The name of the BGP group. The name must be 2 to 128 characters in length and can contain digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73091aa8c55b4a0e86a9edcb0eb8eda99974e97d356f429efd1290d7fd5aac2d)
            check_type(argname="argument peer_asn", value=peer_asn, expected_type=type_hints["peer_asn"])
            check_type(argname="argument router_id", value=router_id, expected_type=type_hints["router_id"])
            check_type(argname="argument auth_key", value=auth_key, expected_type=type_hints["auth_key"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument is_fake_asn", value=is_fake_asn, expected_type=type_hints["is_fake_asn"])
            check_type(argname="argument local_asn", value=local_asn, expected_type=type_hints["local_asn"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "peer_asn": peer_asn,
            "router_id": router_id,
        }
        if auth_key is not None:
            self._values["auth_key"] = auth_key
        if description is not None:
            self._values["description"] = description
        if is_fake_asn is not None:
            self._values["is_fake_asn"] = is_fake_asn
        if local_asn is not None:
            self._values["local_asn"] = local_asn
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def peer_asn(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property peerAsn: The AS number of the BGP peer.'''
        result = self._values.get("peer_asn")
        assert result is not None, "Required property 'peer_asn' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routerId: The ID of the VBR.'''
        result = self._values.get("router_id")
        assert result is not None, "Required property 'router_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auth_key(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property authKey: The authentication key of the BGP group.'''
        result = self._values.get("auth_key")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the BGP group.

        The description must be 2 to 256 characters in length.
        It must start with a letter but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def is_fake_asn(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property isFakeAsn: A router that runs BGP typically belongs to only one AS.

        In some cases, for example,
        the AS needs to be migrated or is merged with another AS, a new AS number replaces
        the original one.
        '''
        result = self._values.get("is_fake_asn")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def local_asn(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property localAsn: The AS number on the Alibaba Cloud side.'''
        result = self._values.get("local_asn")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the BGP group.

        The name must be 2 to 128 characters in length and can
        contain digits, periods (.), underscores (_), and hyphens (-). The name must start
        with a letter but cannot start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BgpGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BgpNetwork(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.BgpNetwork",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::BgpNetwork``, which is used to advertise a Border Gateway Protocol (BGP) network.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosBgpNetwork``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgpnetwork
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["BgpNetworkProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d93d9060bce31d48f154cb25b831762ce354e45fee644b12493de5511bb7fe24)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrDstCidrBlock")
    def attr_dst_cidr_block(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute DstCidrBlock: The CIDR block of the virtual private cloud (VPC) or vSwitch that you want to connect to a data center.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDstCidrBlock"))

    @builtins.property
    @jsii.member(jsii_name="attrRouterId")
    def attr_router_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouterId: The ID of the vRouter associated with the router interface.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouterId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.BgpNetworkProps",
    jsii_struct_bases=[],
    name_mapping={"dst_cidr_block": "dstCidrBlock", "router_id": "routerId"},
)
class BgpNetworkProps:
    def __init__(
        self,
        *,
        dst_cidr_block: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``BgpNetwork``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgpnetwork

        :param dst_cidr_block: Property dstCidrBlock: The CIDR block of the virtual private cloud (VPC) or vSwitch that you want to connect to a data center.
        :param router_id: Property routerId: The ID of the vRouter associated with the router interface.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9b17e12d4078b2a84cff6a437840a6e7fc42b45b4c138e3435957b88f25212f)
            check_type(argname="argument dst_cidr_block", value=dst_cidr_block, expected_type=type_hints["dst_cidr_block"])
            check_type(argname="argument router_id", value=router_id, expected_type=type_hints["router_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dst_cidr_block": dst_cidr_block,
            "router_id": router_id,
        }

    @builtins.property
    def dst_cidr_block(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property dstCidrBlock: The CIDR block of the virtual private cloud (VPC) or vSwitch that you want to connect to a data center.'''
        result = self._values.get("dst_cidr_block")
        assert result is not None, "Required property 'dst_cidr_block' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routerId: The ID of the vRouter associated with the router interface.'''
        result = self._values.get("router_id")
        assert result is not None, "Required property 'router_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BgpNetworkProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BgpPeer(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.BgpPeer",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::BgpPeer``, which is used to add a Border Gateway Protocol (BGP) peer to a specific BGP group.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosBgpPeer``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgppeer
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["BgpPeerProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fbc510bfb9f7304a6cd946099e681dff901cc0a9c8eb555294b32f7193328529)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrBgpPeerId")
    def attr_bgp_peer_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute BgpPeerId: The ID of the BGP peer.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBgpPeerId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.BgpPeerProps",
    jsii_struct_bases=[],
    name_mapping={
        "bgp_group_id": "bgpGroupId",
        "enable_bfd": "enableBfd",
        "peer_ip_address": "peerIpAddress",
    },
)
class BgpPeerProps:
    def __init__(
        self,
        *,
        bgp_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        enable_bfd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        peer_ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``BgpPeer``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgppeer

        :param bgp_group_id: Property bgpGroupId: The ID of the BGP group.
        :param enable_bfd: Property enableBfd: Specifies whether to enable the Bidirectional Forwarding Detection (BFD) feature. Valid values: true: enables BFD. false: disables BFD.
        :param peer_ip_address: Property peerIpAddress: The IP address of the BGP peer.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__002714eae07c08393e65aa00198c0ea2ad2acfdd721d36c2022e66dd0859e2a3)
            check_type(argname="argument bgp_group_id", value=bgp_group_id, expected_type=type_hints["bgp_group_id"])
            check_type(argname="argument enable_bfd", value=enable_bfd, expected_type=type_hints["enable_bfd"])
            check_type(argname="argument peer_ip_address", value=peer_ip_address, expected_type=type_hints["peer_ip_address"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bgp_group_id": bgp_group_id,
        }
        if enable_bfd is not None:
            self._values["enable_bfd"] = enable_bfd
        if peer_ip_address is not None:
            self._values["peer_ip_address"] = peer_ip_address

    @builtins.property
    def bgp_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property bgpGroupId: The ID of the BGP group.'''
        result = self._values.get("bgp_group_id")
        assert result is not None, "Required property 'bgp_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def enable_bfd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enableBfd: Specifies whether to enable the Bidirectional Forwarding Detection (BFD) feature.

        Valid values:
        true: enables BFD.
        false: disables BFD.
        '''
        result = self._values.get("enable_bfd")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def peer_ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property peerIpAddress: The IP address of the BGP peer.'''
        result = self._values.get("peer_ip_address")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BgpPeerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CommonBandwidthPackage(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.CommonBandwidthPackage",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::CommonBandwidthPackage``, which is used to create an elastic IP address (EIP) bandwidth plan.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosCommonBandwidthPackage``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-commonbandwidthpackage
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["CommonBandwidthPackageProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1efb5932ed1c8c005cd3aaa948b8b7e9ab4f0c0792292ef64bbd83f05f55b336)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrBandwidthPackageId")
    def attr_bandwidth_package_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute BandwidthPackageId: The ID of the Internet Shared Bandwidth instance.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBandwidthPackageId"))


class CommonBandwidthPackageIp(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.CommonBandwidthPackageIp",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::CommonBandwidthPackageIp``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosCommonBandwidthPackageIp``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-commonbandwidthpackageip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["CommonBandwidthPackageIpProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__010e9e8d1c443621fc5461fdfbf4a443e7f7c53d9fc1b9377e9fcf32e9adb4b2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrAllocationIds")
    def attr_allocation_ids(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute AllocationIds: All eip allocation ids of common bandwidth package.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAllocationIds"))

    @builtins.property
    @jsii.member(jsii_name="attrIpAddresses")
    def attr_ip_addresses(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute IpAddresses: All eip addresses of common bandwidth package.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpAddresses"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.CommonBandwidthPackageIpProps",
    jsii_struct_bases=[],
    name_mapping={"bandwidth_package_id": "bandwidthPackageId", "eips": "eips"},
)
class CommonBandwidthPackageIpProps:
    def __init__(
        self,
        *,
        bandwidth_package_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        eips: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosCommonBandwidthPackageIp.EipsProperty", typing.Dict[builtins.str, typing.Any]]]]],
    ) -> None:
        '''Properties for defining a ``CommonBandwidthPackageIp``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-commonbandwidthpackageip

        :param bandwidth_package_id: Property bandwidthPackageId: The ID of the Internet Shared Bandwidth instance.
        :param eips: Property eips: List of eip associated with the Internet Shared Bandwidth instance.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c7a74b040f275773c5fc172c0d4566f200b2f1fe789ac13165ec870298116be)
            check_type(argname="argument bandwidth_package_id", value=bandwidth_package_id, expected_type=type_hints["bandwidth_package_id"])
            check_type(argname="argument eips", value=eips, expected_type=type_hints["eips"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bandwidth_package_id": bandwidth_package_id,
            "eips": eips,
        }

    @builtins.property
    def bandwidth_package_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property bandwidthPackageId: The ID of the Internet Shared Bandwidth instance.'''
        result = self._values.get("bandwidth_package_id")
        assert result is not None, "Required property 'bandwidth_package_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def eips(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosCommonBandwidthPackageIp.EipsProperty"]]]:
        '''Property eips: List of eip associated with the Internet Shared Bandwidth instance.'''
        result = self._values.get("eips")
        assert result is not None, "Required property 'eips' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosCommonBandwidthPackageIp.EipsProperty"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommonBandwidthPackageIpProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.CommonBandwidthPackageProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "description": "description",
        "internet_charge_type": "internetChargeType",
        "isp": "isp",
        "name": "name",
        "ratio": "ratio",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
        "zone": "zone",
    },
)
class CommonBandwidthPackageProps:
    def __init__(
        self,
        *,
        bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ratio: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["RosCommonBandwidthPackage.TagsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        zone: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``CommonBandwidthPackage``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-commonbandwidthpackage

        :param bandwidth: Property bandwidth: The peak bandwidth of the Internet Shared Bandwidth instance. Unit: Mbit/s.
        :param description: Property description: The description of the Internet Shared Bandwidth instance. The description must be 2 to 256 characters in length. It must start with a letter, and cannot start with http:// or https://.
        :param internet_charge_type: Property internetChargeType: The billing model of the Internet Shared Bandwidth instance. Allowed values: PayByBandwidth (default): Billed by bandwidth. PayBy95: Charged at Enhanced 95.
        :param isp: Property isp: Line type of EIP, value: BGP (multi-line).
        :param name: Property name: The name of the Internet Shared Bandwidth instance. The name must be 2 to 128 characters in length and can contain letters, numbers, periods (.), underscores (_), and hyphens (-). The name must start with a letter, and cannot start with http:// or https://.
        :param ratio: Property ratio: The minimum consumption ratio of the Internet Shared Bandwidth instance. Default to 100. Note This parameter is only supported on the China site.
        :param resource_group_id: Property resourceGroupId: The ID of the resource group.
        :param tags: Property tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        :param zone: Property zone: Zone Id.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1d20e57e8c4991e1ffad4b2e93604389444a6336dd687b379eb874a4391cc63)
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument isp", value=isp, expected_type=type_hints["isp"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument ratio", value=ratio, expected_type=type_hints["ratio"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument zone", value=zone, expected_type=type_hints["zone"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bandwidth": bandwidth,
        }
        if description is not None:
            self._values["description"] = description
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if isp is not None:
            self._values["isp"] = isp
        if name is not None:
            self._values["name"] = name
        if ratio is not None:
            self._values["ratio"] = ratio
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags
        if zone is not None:
            self._values["zone"] = zone

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property bandwidth: The peak bandwidth of the Internet Shared Bandwidth instance.

        Unit: Mbit/s.
        '''
        result = self._values.get("bandwidth")
        assert result is not None, "Required property 'bandwidth' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the Internet Shared Bandwidth instance.

        The description must be 2 to 256 characters in length. It must start with a letter,
        and cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetChargeType: The billing model of the Internet Shared Bandwidth instance.

        Allowed values:
        PayByBandwidth (default): Billed by bandwidth.
        PayBy95: Charged at Enhanced 95.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property isp: Line type of EIP, value: BGP (multi-line).'''
        result = self._values.get("isp")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the Internet Shared Bandwidth instance.

        The name must be 2 to 128 characters in length and can contain letters, numbers, periods
        (.), underscores (_), and hyphens (-). The name must start with a letter, and cannot
        start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ratio(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ratio: The minimum consumption ratio of the Internet Shared Bandwidth instance.

        Default to 100.
        Note This parameter is only supported on the China site.
        '''
        result = self._values.get("ratio")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: The ID of the resource group.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List["RosCommonBandwidthPackage.TagsProperty"]]:
        '''Property tags: Tags to attach to instance.

        Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["RosCommonBandwidthPackage.TagsProperty"]], result)

    @builtins.property
    def zone(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property zone: Zone Id.'''
        result = self._values.get("zone")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommonBandwidthPackageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CustomerGateway(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.CustomerGateway",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::CustomerGateway``, which is used to create a customer gateway.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosCustomerGateway``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-customergateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["CustomerGatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ed4ffc9df7dd6b386e55f6da0010e7b907d330d5cab6a6bcc2bb2f9a689ce28)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrCustomerGatewayId")
    def attr_customer_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute CustomerGatewayId: The ID of the user gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrCustomerGatewayId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.CustomerGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "ip_address": "ipAddress",
        "asn": "asn",
        "description": "description",
        "name": "name",
    },
)
class CustomerGatewayProps:
    def __init__(
        self,
        *,
        ip_address: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``CustomerGateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-customergateway

        :param ip_address: Property ipAddress: The IP address of the user gateway.
        :param asn: Property asn: The autonomous system number of the local data center gateway device.
        :param description: Property description: Description of the user gateway. The length is 2-256 characters and must start with a letter or Chinese, but cannot start with http:// or https://.
        :param name: Property name: The name of the user gateway. The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41836b525b4fdd47f169ca23f6289092939a978e3c8deae33ff00e62c4c16167)
            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
            check_type(argname="argument asn", value=asn, expected_type=type_hints["asn"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ip_address": ip_address,
        }
        if asn is not None:
            self._values["asn"] = asn
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def ip_address(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property ipAddress: The IP address of the user gateway.'''
        result = self._values.get("ip_address")
        assert result is not None, "Required property 'ip_address' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def asn(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property asn: The autonomous system number of the local data center gateway device.'''
        result = self._values.get("asn")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Description of the user gateway.

        The length is 2-256 characters and must start with a letter or Chinese, but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the user gateway.

        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomerGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DhcpOptionsSet(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.DhcpOptionsSet",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::DhcpOptionsSet``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosDhcpOptionsSet``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-dhcpoptionsset
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Optional[typing.Union["DhcpOptionsSetProps", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53b04f72ddc06c3fc7bc3e630015f7f42f6f276b44b1d010ec39d609f6ff8fa5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrDhcpOptionsSetId")
    def attr_dhcp_options_set_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute DhcpOptionsSetId: The ID of the DHCP options set that is created.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDhcpOptionsSetId"))


class DhcpOptionsSetAttachment(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.DhcpOptionsSetAttachment",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::DhcpOptionsSetAttachment``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosDhcpOptionsSetAttachment``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-dhcpoptionssetattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["DhcpOptionsSetAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c44c7ec07ab13b70f2a311a5aadc56c32aff50fd6ce61480cdcaea987a25901b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrDhcpOptionsSetId")
    def attr_dhcp_options_set_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute DhcpOptionsSetId: The ID of the DHCP options set.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDhcpOptionsSetId"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpcId: The ID of the VPC network.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpcId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.DhcpOptionsSetAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={"dhcp_options_set_id": "dhcpOptionsSetId", "vpc_id": "vpcId"},
)
class DhcpOptionsSetAttachmentProps:
    def __init__(
        self,
        *,
        dhcp_options_set_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``DhcpOptionsSetAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-dhcpoptionssetattachment

        :param dhcp_options_set_id: Property dhcpOptionsSetId: The ID of the DHCP options set.
        :param vpc_id: Property vpcId: The ID of the VPC network that is to be associated with the DHCP options set.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__322b72dba85d332a969fdccfd7b4c65dc1353274fcc1f514a661d672046fc26a)
            check_type(argname="argument dhcp_options_set_id", value=dhcp_options_set_id, expected_type=type_hints["dhcp_options_set_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dhcp_options_set_id": dhcp_options_set_id,
            "vpc_id": vpc_id,
        }

    @builtins.property
    def dhcp_options_set_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property dhcpOptionsSetId: The ID of the DHCP options set.'''
        result = self._values.get("dhcp_options_set_id")
        assert result is not None, "Required property 'dhcp_options_set_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpcId: The ID of the VPC network that is to be associated with the DHCP options set.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DhcpOptionsSetAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.DhcpOptionsSetProps",
    jsii_struct_bases=[],
    name_mapping={
        "dhcp_options_set_description": "dhcpOptionsSetDescription",
        "dhcp_options_set_name": "dhcpOptionsSetName",
        "domain_name": "domainName",
        "domain_name_servers": "domainNameServers",
    },
)
class DhcpOptionsSetProps:
    def __init__(
        self,
        *,
        dhcp_options_set_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        dhcp_options_set_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        domain_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        domain_name_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ) -> None:
        '''Properties for defining a ``DhcpOptionsSet``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-dhcpoptionsset

        :param dhcp_options_set_description: Property dhcpOptionsSetDescription: The description of the DHCP options set. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        :param dhcp_options_set_name: Property dhcpOptionsSetName: The name of the DHCP options set. The name must be 2 to 128 characters in length and can contain letters, Chinese characters, digits, underscores (_), and hyphens (-). It must start with a letter or a Chinese character.
        :param domain_name: Property domainName: The root domain, for example, example.com. After a DHCP options set is associated with a Virtual Private Cloud (VPC) network, the root domain in the DHCP options set is automatically synchronized to the ECS instances in the VPC network.
        :param domain_name_servers: Property domainNameServers: The DNS server IP addresses. Note Before you specify any DNS server IP address, all ECS instances in the associated VPC network use the IP addresses of the Alibaba Cloud DNS servers, which are 100.100.2.136 and 100.100.2.138.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7962140a2ee0fdef8dae5b50a34006cbb74e7f0b4600cc680dd035cf6504d535)
            check_type(argname="argument dhcp_options_set_description", value=dhcp_options_set_description, expected_type=type_hints["dhcp_options_set_description"])
            check_type(argname="argument dhcp_options_set_name", value=dhcp_options_set_name, expected_type=type_hints["dhcp_options_set_name"])
            check_type(argname="argument domain_name", value=domain_name, expected_type=type_hints["domain_name"])
            check_type(argname="argument domain_name_servers", value=domain_name_servers, expected_type=type_hints["domain_name_servers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dhcp_options_set_description is not None:
            self._values["dhcp_options_set_description"] = dhcp_options_set_description
        if dhcp_options_set_name is not None:
            self._values["dhcp_options_set_name"] = dhcp_options_set_name
        if domain_name is not None:
            self._values["domain_name"] = domain_name
        if domain_name_servers is not None:
            self._values["domain_name_servers"] = domain_name_servers

    @builtins.property
    def dhcp_options_set_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property dhcpOptionsSetDescription: The description of the DHCP options set.

        The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("dhcp_options_set_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def dhcp_options_set_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property dhcpOptionsSetName: The name of the DHCP options set.

        The name must be 2 to 128 characters in length and can contain letters, Chinese characters, digits, underscores (_), and hyphens (-). It must start with a letter or a Chinese character.
        '''
        result = self._values.get("dhcp_options_set_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def domain_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property domainName: The root domain, for example, example.com. After a DHCP options set is associated with a Virtual Private Cloud (VPC) network, the root domain in the DHCP options set is automatically synchronized to the ECS instances in the VPC network.'''
        result = self._values.get("domain_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def domain_name_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property domainNameServers: The DNS server IP addresses.

        Note Before you specify any DNS server IP address, all ECS instances in the associated VPC network use the IP addresses of the Alibaba Cloud DNS servers, which are 100.100.2.136 and 100.100.2.138.
        '''
        result = self._values.get("domain_name_servers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DhcpOptionsSetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EIPAssociation(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.EIPAssociation",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::EIPAssociation``, which is used to associate an elastic IP address (EIP) with a cloud service instance.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosEIPAssociation``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eipassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["EIPAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ff19e43abb149fd4389bed00b60f25bdfa8290449d9a8c42fe5d1a87066c7d9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrAllocationId")
    def attr_allocation_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute AllocationId: ID that Aliyun assigns to represent the allocation of the address for use with VPC.

        Returned only for VPC elastic IP addresses.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAllocationId"))

    @builtins.property
    @jsii.member(jsii_name="attrEipAddress")
    def attr_eip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute EipAddress: IP address of created EIP.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipAddress"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.EIPAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocation_id": "allocationId",
        "instance_id": "instanceId",
        "mode": "mode",
        "private_ip_address": "privateIpAddress",
    },
)
class EIPAssociationProps:
    def __init__(
        self,
        *,
        allocation_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        private_ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``EIPAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eipassociation

        :param allocation_id: Property allocationId: EIP instance id to bind.
        :param instance_id: Property instanceId: ECS/SLB/NAT/HaVip/ENI instance id to bid the EIP.
        :param mode: Property mode: The mode of association. Valid values: NAT(Default): NAT mode. BINDED: Cut-through mode. MULTI_BINDED: Multi-EIP to ENI mode. This is required only when the value of InstanceType is NetworkInterface.
        :param private_ip_address: Property privateIpAddress: An IP address in the CIDR block of the VSwitch. If you leave the option empty, the system allocates a private IP address according to the VPC ID and VSwitch ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aabfd773e7116ba656f39786fa81e728a7da3332e9380861c0d64d68b4f066c3)
            check_type(argname="argument allocation_id", value=allocation_id, expected_type=type_hints["allocation_id"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "allocation_id": allocation_id,
            "instance_id": instance_id,
        }
        if mode is not None:
            self._values["mode"] = mode
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address

    @builtins.property
    def allocation_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property allocationId: EIP instance id to bind.'''
        result = self._values.get("allocation_id")
        assert result is not None, "Required property 'allocation_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property instanceId: ECS/SLB/NAT/HaVip/ENI instance id to bid the EIP.'''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property mode: The mode of association.

        Valid values:
        NAT(Default): NAT mode.
        BINDED: Cut-through mode.
        MULTI_BINDED: Multi-EIP to ENI mode.
        This is required only when the value of InstanceType is NetworkInterface.
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def private_ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property privateIpAddress: An IP address in the CIDR block of the VSwitch.

        If you leave the option empty, the system allocates a private IP address according to the VPC ID and VSwitch ID.
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EIPAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EIPPro(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.EIPPro",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::EIPPro``, which is used to create an elastic IP address (EIP).

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosEIPPro``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eippro
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Optional[typing.Union["EIPProProps", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7923bc4ab772f0fb4b32fb0a0a746fd3be7573009d21b327a5fbb2e153e4e55)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrAllocationId")
    def attr_allocation_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute AllocationId: ID that Aliyun assigns to represent the allocation of the address for use with VPC.

        Returned only for VPC elastic IP addresses.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAllocationId"))

    @builtins.property
    @jsii.member(jsii_name="attrEipAddress")
    def attr_eip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute EipAddress: IP address of created EIP.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipAddress"))

    @builtins.property
    @jsii.member(jsii_name="attrIsp")
    def attr_isp(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ISP: The line type.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIsp"))

    @builtins.property
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute OrderId: Order ID of prepaid EIP instance.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOrderId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.EIPProProps",
    jsii_struct_bases=[],
    name_mapping={
        "auto_pay": "autoPay",
        "bandwidth": "bandwidth",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "instance_charge_type": "instanceChargeType",
        "instance_id": "instanceId",
        "internet_charge_type": "internetChargeType",
        "ip_address": "ipAddress",
        "isp": "isp",
        "name": "name",
        "netmode": "netmode",
        "period": "period",
        "pricing_cycle": "pricingCycle",
        "public_ip_address_pool_id": "publicIpAddressPoolId",
        "resource_group_id": "resourceGroupId",
        "security_protection_types": "securityProtectionTypes",
        "tags": "tags",
    },
)
class EIPProProps:
    def __init__(
        self,
        *,
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        public_ip_address_pool_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_protection_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["RosEIPPro.TagsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``EIPPro``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eippro

        :param auto_pay: Property autoPay: Automatic Payment. Default is true.
        :param bandwidth: Property bandwidth: Bandwidth for the output network. Default is 5MB.
        :param deletion_protection: Property deletionProtection: Whether to enable deletion protection. Default to False.
        :param description: Property description: Optional. The description of the EIP. The description must be 2 to 256 characters in length. It must start with a letter. It cannot start with http:// or https://.
        :param instance_charge_type: Property instanceChargeType: The resource charge type. Default value is Postpaid
        :param instance_id: Property instanceId: The ID of the requested EIP.
        :param internet_charge_type: Property internetChargeType: The network charge type. Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByBandwidth. PayByTraffic will charge by hour, PayByBandwidth will charge by day.
        :param ip_address: Property ipAddress: The IP address of the requested EIP.
        :param isp: Property isp: The line type. You can set this parameter only when you create a pay-as-you-go EIP. Valid values: BGP: BGP (Multi-ISP) lines. Up to 89 high-quality BGP lines are available worldwide. Direct connections with multiple Internet Service Providers (ISPs), including Telecom, Unicom, Mobile, Railcom, Netcom, CERNET, China Broadcast Network, Dr. Peng, and Founder, can be established in all regions in mainland China. BGP_PRO: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines optimize data transmission to China and improve connection quality for international services. Compared with traditional BGP (Multi-ISP) lines, BGP (Multi-ISP) Pro lines can be used to establish direct connections without using international ISP services. Therefore, BGP (Multi-ISP) Pro lines reduce network latency.
        :param name: Property name: The name of the EIP. The name must be 2 to 128 characters in length. It must start with a letter. It can contain numbers, periods (.), underscores (_), and hyphens (-). It cannot start with http:// or https://
        :param netmode: Property netmode: The network type. Valid value: public (public network).
        :param period: Property period: Prepaid time period. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36. While choose pay by year, it could be from 1 to 3.
        :param pricing_cycle: Property pricingCycle: Price cycle of the resource. This property has no default value. If ChargeType is specified as Postpaid, this value will be ignore.
        :param public_ip_address_pool_id: Property publicIpAddressPoolId: The ID of the IP address pool. The EIP is allocated from the IP address pool.
        :param resource_group_id: Property resourceGroupId: Resource group id.
        :param security_protection_types: Property securityProtectionTypes: The edition of Anti-DDoS. If you do not set this parameter, Anti-DDoS Origin Basic is used. If you set the value to AntiDDoS_Enhanced, Anti-DDoS Pro/Premium is used.
        :param tags: Property tags: Tags to attach to eip. Max support 20 tags to add during create eip. Each tag with two properties Key and Value, and Key is required.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba6a5ea1d7d7e5f0fd21fe504caf9408170fc3bb362c048a9f5c8c5407c082fe)
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
            check_type(argname="argument isp", value=isp, expected_type=type_hints["isp"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument netmode", value=netmode, expected_type=type_hints["netmode"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument pricing_cycle", value=pricing_cycle, expected_type=type_hints["pricing_cycle"])
            check_type(argname="argument public_ip_address_pool_id", value=public_ip_address_pool_id, expected_type=type_hints["public_ip_address_pool_id"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument security_protection_types", value=security_protection_types, expected_type=type_hints["security_protection_types"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if bandwidth is not None:
            self._values["bandwidth"] = bandwidth
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if ip_address is not None:
            self._values["ip_address"] = ip_address
        if isp is not None:
            self._values["isp"] = isp
        if name is not None:
            self._values["name"] = name
        if netmode is not None:
            self._values["netmode"] = netmode
        if period is not None:
            self._values["period"] = period
        if pricing_cycle is not None:
            self._values["pricing_cycle"] = pricing_cycle
        if public_ip_address_pool_id is not None:
            self._values["public_ip_address_pool_id"] = public_ip_address_pool_id
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_protection_types is not None:
            self._values["security_protection_types"] = security_protection_types
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoPay: Automatic Payment.

        Default is true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property bandwidth: Bandwidth for the output network.

        Default is 5MB.
        '''
        result = self._values.get("bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property deletionProtection: Whether to enable deletion protection.

        Default to False.
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Optional.

        The description of the EIP. The description must be 2 to 256 characters in length. It must start with a letter. It cannot start with http://  or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceChargeType: The resource charge type.

        Default value is Postpaid
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceId: The ID of the requested EIP.'''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetChargeType: The network charge type.

        Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByBandwidth. PayByTraffic will charge by hour, PayByBandwidth will charge by day.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ipAddress: The IP address of the requested EIP.'''
        result = self._values.get("ip_address")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property isp: The line type.

        You can set this parameter only when you create a pay-as-you-go EIP. Valid values:
        BGP: BGP (Multi-ISP) lines. Up to 89 high-quality BGP lines are available worldwide. Direct connections with multiple Internet Service Providers (ISPs), including Telecom, Unicom, Mobile, Railcom, Netcom, CERNET, China Broadcast Network, Dr. Peng, and Founder, can be established in all regions in mainland China.
        BGP_PRO: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines optimize data transmission to China and improve connection quality for international services. Compared with traditional BGP (Multi-ISP) lines, BGP (Multi-ISP) Pro lines can be used to establish direct connections without using international ISP services. Therefore, BGP (Multi-ISP) Pro lines reduce network latency.
        '''
        result = self._values.get("isp")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the EIP.

        The name must be 2 to 128 characters in length. It must start with a letter. It can contain numbers, periods (.), underscores (_), and hyphens (-). It cannot start with http://  or https://
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property netmode: The network type.

        Valid value: public (public network).
        '''
        result = self._values.get("netmode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property period: Prepaid time period.

        While choose by pay by month, it could be from 1 to 9 or 12, 24, 36.
        While choose pay by year, it could be from 1 to 3.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property pricingCycle: Price cycle of the resource.

        This property has no default value. If ChargeType is specified as Postpaid, this value will be ignore.
        '''
        result = self._values.get("pricing_cycle")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def public_ip_address_pool_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property publicIpAddressPoolId: The ID of the IP address pool.

        The EIP is allocated from the IP address pool.
        '''
        result = self._values.get("public_ip_address_pool_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: Resource group id.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_protection_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property securityProtectionTypes: The edition of Anti-DDoS.

        If you do not set this parameter, Anti-DDoS Origin Basic is used.
        If you set the value to AntiDDoS_Enhanced, Anti-DDoS Pro/Premium is used.
        '''
        result = self._values.get("security_protection_types")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["RosEIPPro.TagsProperty"]]:
        '''Property tags: Tags to attach to eip.

        Max support 20 tags to add during create eip. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["RosEIPPro.TagsProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EIPProProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.EIPProps",
    jsii_struct_bases=[],
    name_mapping={
        "auto_pay": "autoPay",
        "bandwidth": "bandwidth",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "instance_charge_type": "instanceChargeType",
        "internet_charge_type": "internetChargeType",
        "isp": "isp",
        "name": "name",
        "netmode": "netmode",
        "period": "period",
        "pricing_cycle": "pricingCycle",
        "public_ip_address_pool_id": "publicIpAddressPoolId",
        "resource_group_id": "resourceGroupId",
        "security_protection_types": "securityProtectionTypes",
        "tags": "tags",
        "zone": "zone",
    },
)
class EIPProps:
    def __init__(
        self,
        *,
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        public_ip_address_pool_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_protection_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["RosEIP.TagsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        zone: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``EIP``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eip

        :param auto_pay: Property autoPay: Automatic Payment. Default is true.
        :param bandwidth: Property bandwidth: Bandwidth for the output network. Default is 5MB.
        :param deletion_protection: Property deletionProtection: Whether to enable deletion protection. Default to False.
        :param description: Property description: Optional. The description of the EIP. The description must be 2 to 256 characters in length. It must start with a letter. It cannot start with http:// or https://.
        :param instance_charge_type: Property instanceChargeType: The resource charge type. Default value is Postpaid
        :param internet_charge_type: Property internetChargeType: The network charge type. Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByBandwidth. PayByTraffic will charge by hour, PayByBandwidth will charge by day.
        :param isp: Property isp: The line type. You can set this parameter only when you create a pay-as-you-go EIP. Valid values: BGP: BGP (Multi-ISP) lines. Up to 89 high-quality BGP lines are available worldwide. Direct connections with multiple Internet Service Providers (ISPs), including Telecom, Unicom, Mobile, Railcom, Netcom, CERNET, China Broadcast Network, Dr. Peng, and Founder, can be established in all regions in mainland China. BGP_PRO: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines optimize data transmission to China and improve connection quality for international services. Compared with traditional BGP (Multi-ISP) lines, BGP (Multi-ISP) Pro lines can be used to establish direct connections without using international ISP services. Therefore, BGP (Multi-ISP) Pro lines reduce network latency.
        :param name: Property name: The name of the EIP. The name must be 2 to 128 characters in length. It must start with a letter. It can contain numbers, periods (.), underscores (_), and hyphens (-). It cannot start with http:// or https://
        :param netmode: Property netmode: The network type. Valid value: public (public network).
        :param period: Property period: Prepaid time period. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36. While choose pay by year, it could be from 1 to 3.
        :param pricing_cycle: Property pricingCycle: Price cycle of the resource. This property has no default value. If ChargeType is specified as Postpaid, this value will be ignore.
        :param public_ip_address_pool_id: Property publicIpAddressPoolId: The ID of the IP address pool. The EIP is allocated from the IP address pool.
        :param resource_group_id: Property resourceGroupId: Resource group id.
        :param security_protection_types: Property securityProtectionTypes: The edition of Anti-DDoS. If you do not set this parameter, Anti-DDoS Origin Basic is used. If you set the value to AntiDDoS_Enhanced, Anti-DDoS Pro/Premium is used.
        :param tags: Property tags: Tags to attach to eip. Max support 20 tags to add during create eip. Each tag with two properties Key and Value, and Key is required.
        :param zone: Property zone: Availability zone of the elastic public network IP.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4d77b9c71cbc7b5efb39b7fae516e2ceb62f7036c7275728309fb06adfb6cc7)
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument isp", value=isp, expected_type=type_hints["isp"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument netmode", value=netmode, expected_type=type_hints["netmode"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument pricing_cycle", value=pricing_cycle, expected_type=type_hints["pricing_cycle"])
            check_type(argname="argument public_ip_address_pool_id", value=public_ip_address_pool_id, expected_type=type_hints["public_ip_address_pool_id"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument security_protection_types", value=security_protection_types, expected_type=type_hints["security_protection_types"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument zone", value=zone, expected_type=type_hints["zone"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if bandwidth is not None:
            self._values["bandwidth"] = bandwidth
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if isp is not None:
            self._values["isp"] = isp
        if name is not None:
            self._values["name"] = name
        if netmode is not None:
            self._values["netmode"] = netmode
        if period is not None:
            self._values["period"] = period
        if pricing_cycle is not None:
            self._values["pricing_cycle"] = pricing_cycle
        if public_ip_address_pool_id is not None:
            self._values["public_ip_address_pool_id"] = public_ip_address_pool_id
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_protection_types is not None:
            self._values["security_protection_types"] = security_protection_types
        if tags is not None:
            self._values["tags"] = tags
        if zone is not None:
            self._values["zone"] = zone

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoPay: Automatic Payment.

        Default is true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property bandwidth: Bandwidth for the output network.

        Default is 5MB.
        '''
        result = self._values.get("bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property deletionProtection: Whether to enable deletion protection.

        Default to False.
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Optional.

        The description of the EIP. The description must be 2 to 256 characters in length. It must start with a letter. It cannot start with http://  or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceChargeType: The resource charge type.

        Default value is Postpaid
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetChargeType: The network charge type.

        Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByBandwidth. PayByTraffic will charge by hour, PayByBandwidth will charge by day.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property isp: The line type.

        You can set this parameter only when you create a pay-as-you-go EIP. Valid values:
        BGP: BGP (Multi-ISP) lines. Up to 89 high-quality BGP lines are available worldwide. Direct connections with multiple Internet Service Providers (ISPs), including Telecom, Unicom, Mobile, Railcom, Netcom, CERNET, China Broadcast Network, Dr. Peng, and Founder, can be established in all regions in mainland China.
        BGP_PRO: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines optimize data transmission to China and improve connection quality for international services. Compared with traditional BGP (Multi-ISP) lines, BGP (Multi-ISP) Pro lines can be used to establish direct connections without using international ISP services. Therefore, BGP (Multi-ISP) Pro lines reduce network latency.
        '''
        result = self._values.get("isp")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the EIP.

        The name must be 2 to 128 characters in length. It must start with a letter. It can contain numbers, periods (.), underscores (_), and hyphens (-). It cannot start with http://  or https://
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property netmode: The network type.

        Valid value: public (public network).
        '''
        result = self._values.get("netmode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property period: Prepaid time period.

        While choose by pay by month, it could be from 1 to 9 or 12, 24, 36.
        While choose pay by year, it could be from 1 to 3.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property pricingCycle: Price cycle of the resource.

        This property has no default value. If ChargeType is specified as Postpaid, this value will be ignore.
        '''
        result = self._values.get("pricing_cycle")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def public_ip_address_pool_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property publicIpAddressPoolId: The ID of the IP address pool.

        The EIP is allocated from the IP address pool.
        '''
        result = self._values.get("public_ip_address_pool_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: Resource group id.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_protection_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property securityProtectionTypes: The edition of Anti-DDoS.

        If you do not set this parameter, Anti-DDoS Origin Basic is used.
        If you set the value to AntiDDoS_Enhanced, Anti-DDoS Pro/Premium is used.
        '''
        result = self._values.get("security_protection_types")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["RosEIP.TagsProperty"]]:
        '''Property tags: Tags to attach to eip.

        Max support 20 tags to add during create eip. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["RosEIP.TagsProperty"]], result)

    @builtins.property
    def zone(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property zone: Availability zone of the elastic public network IP.'''
        result = self._values.get("zone")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EIPProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EIPSegment(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.EIPSegment",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::EIPSegment``, which is used to apply for contiguous elastic IP addresses (EIPs).

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosEIPSegment``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eipsegment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["EIPSegmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70f003c08ca4cff726622aa246d069641f3beb6170922d8da0544ab17c429663)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrEipAddresses")
    def attr_eip_addresses(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute EipAddresses: List of EIP addresses.

        like [{"AllocationId": "eip-xxx", "IpAddress": "xx.xx.xx.xx"}]
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipAddresses"))

    @builtins.property
    @jsii.member(jsii_name="attrEipSegmentInstanceId")
    def attr_eip_segment_instance_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute EipSegmentInstanceId: The ID of the contiguous EIP group.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipSegmentInstanceId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.EIPSegmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "eip_mask": "eipMask",
        "bandwidth": "bandwidth",
        "internet_charge_type": "internetChargeType",
        "netmode": "netmode",
        "resource_group_id": "resourceGroupId",
    },
)
class EIPSegmentProps:
    def __init__(
        self,
        *,
        eip_mask: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``EIPSegment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eipsegment

        :param eip_mask: Property eipMask: The mask of the contiguous EIP group. Valid values: 28: 16 contiguous EIPs are allocated for one call. 27: 32 contiguous EIPs are allocated for one call. 26: 64 contiguous EIPs are allocated for one call. 25: 128 contiguous EIPs are allocated for one call. 24: 256 contiguous EIPs are allocated for one call. Note The actual number of assigned EIPs may be less than the expected number because one, three, or four EIPs may be reserved.
        :param bandwidth: Property bandwidth: The maximum bandwidth of the contiguous EIPs. Unit: Mbit/s. Default value: 5.
        :param internet_charge_type: Property internetChargeType: The metering method of the contiguous EIPs. Valid values: PayByBandwidth: Fees are charged based on bandwidth usage. This is the default value. PayByTraffic: Fees are charged based on data transfer. Note If the Netmode parameter is set to hybrid, InternetChargeType is set to PayByBandwidth.
        :param netmode: Property netmode: The network type. Valid values: public: the Internet. This is the default value. After contiguous EIPs are associated with cloud resources, the cloud resources can access the Internet by using the EIPs. hybrid: the hybrid cloud. After contiguous EIPs are associated with cloud resources, the cloud resources can access the hybrid cloud by using the EIPs. Note This network type is available only to users who are added to the whitelist. To use this network type, contact your customer manager.
        :param resource_group_id: Property resourceGroupId: The ID of the resource group to which the EIPs belong.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2739e9535eff5d4634fe9317a1c003a93ca87d1a854a0be98c3eab690f401c44)
            check_type(argname="argument eip_mask", value=eip_mask, expected_type=type_hints["eip_mask"])
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument netmode", value=netmode, expected_type=type_hints["netmode"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "eip_mask": eip_mask,
        }
        if bandwidth is not None:
            self._values["bandwidth"] = bandwidth
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if netmode is not None:
            self._values["netmode"] = netmode
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def eip_mask(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property eipMask: The mask of the contiguous EIP group.

        Valid values:
        28: 16 contiguous EIPs are allocated for one call.
        27: 32 contiguous EIPs are allocated for one call.
        26: 64 contiguous EIPs are allocated for one call.
        25: 128 contiguous EIPs are allocated for one call.
        24: 256 contiguous EIPs are allocated for one call.
        Note The actual number of assigned EIPs may be less than the expected number because one,
        three, or four EIPs may be reserved.
        '''
        result = self._values.get("eip_mask")
        assert result is not None, "Required property 'eip_mask' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property bandwidth: The maximum bandwidth of the contiguous EIPs.

        Unit: Mbit/s. Default value: 5.
        '''
        result = self._values.get("bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetChargeType: The metering method of the contiguous EIPs.

        Valid values:
        PayByBandwidth: Fees are charged based on bandwidth usage. This is the default value.
        PayByTraffic: Fees are charged based on data transfer.
        Note If the Netmode parameter is set to hybrid, InternetChargeType is set to PayByBandwidth.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property netmode: The network type.

        Valid values:
        public: the Internet. This is the default value. After contiguous EIPs are associated with
        cloud resources, the cloud resources can access the Internet by using the EIPs.
        hybrid: the hybrid cloud. After contiguous EIPs are associated with cloud resources, the
        cloud resources can access the hybrid cloud by using the EIPs.
        Note This network type is available only to users who are added to the whitelist. To use
        this network type, contact your customer manager.
        '''
        result = self._values.get("netmode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: The ID of the resource group to which the EIPs belong.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EIPSegmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Eip(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.Eip",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::EIP``, which is used to apply for an elastic IP address (EIP).

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosEIP``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Optional[typing.Union[EIPProps, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa7d2f345cdb99d227c417d82a7a529fade4fec6dbd5e111cab299c66ca0cb2f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrAllocationId")
    def attr_allocation_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute AllocationId: ID that Aliyun assigns to represent the allocation of the address for use with VPC.

        Returned only for VPC elastic IP addresses.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAllocationId"))

    @builtins.property
    @jsii.member(jsii_name="attrEipAddress")
    def attr_eip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute EipAddress: IP address of created EIP.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipAddress"))

    @builtins.property
    @jsii.member(jsii_name="attrIsp")
    def attr_isp(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Isp: The line type.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIsp"))

    @builtins.property
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute OrderId: Order ID of prepaid EIP instance.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOrderId"))


class FlowLog(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.FlowLog",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::FlowLog``, which is used to create a flow log.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosFlowLog``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-flowlog
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["FlowLogProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e1787aef508bbdd6294a74f7728a89def0149ed70b7f17a6d61f5661a2b699e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrDescription")
    def attr_description(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Description: The Description of flow log.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDescription"))

    @builtins.property
    @jsii.member(jsii_name="attrFlowLogId")
    def attr_flow_log_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute FlowLogId: The flow log ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrFlowLogId"))

    @builtins.property
    @jsii.member(jsii_name="attrFlowLogName")
    def attr_flow_log_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute FlowLogName: The flow log name.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrFlowLogName"))

    @builtins.property
    @jsii.member(jsii_name="attrLogStoreName")
    def attr_log_store_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute LogStoreName: The log store name.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrLogStoreName"))

    @builtins.property
    @jsii.member(jsii_name="attrProjectName")
    def attr_project_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ProjectName: The project name.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrProjectName"))

    @builtins.property
    @jsii.member(jsii_name="attrResourceId")
    def attr_resource_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ResourceId: The resource id.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrResourceId"))

    @builtins.property
    @jsii.member(jsii_name="attrResourceType")
    def attr_resource_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ResourceType: The resource type.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrResourceType"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficType")
    def attr_traffic_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute TrafficType: The traffic type.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficType"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.FlowLogProps",
    jsii_struct_bases=[],
    name_mapping={
        "log_store_name": "logStoreName",
        "project_name": "projectName",
        "resource_id": "resourceId",
        "resource_type": "resourceType",
        "traffic_type": "trafficType",
        "description": "description",
        "flow_log_name": "flowLogName",
    },
)
class FlowLogProps:
    def __init__(
        self,
        *,
        log_store_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        project_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        resource_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        resource_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        flow_log_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``FlowLog``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-flowlog

        :param log_store_name: Property logStoreName: The log store name.
        :param project_name: Property projectName: The project name.
        :param resource_id: Property resourceId: The resource id.
        :param resource_type: Property resourceType: The resource type.
        :param traffic_type: Property trafficType: The traffic type.
        :param description: Property description: The Description of flow log.
        :param flow_log_name: Property flowLogName: The flow log name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d3805c55ee76adfcee5757a20ac08217577430cd26f67e7ca852ae01fde8bd7)
            check_type(argname="argument log_store_name", value=log_store_name, expected_type=type_hints["log_store_name"])
            check_type(argname="argument project_name", value=project_name, expected_type=type_hints["project_name"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument traffic_type", value=traffic_type, expected_type=type_hints["traffic_type"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument flow_log_name", value=flow_log_name, expected_type=type_hints["flow_log_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "log_store_name": log_store_name,
            "project_name": project_name,
            "resource_id": resource_id,
            "resource_type": resource_type,
            "traffic_type": traffic_type,
        }
        if description is not None:
            self._values["description"] = description
        if flow_log_name is not None:
            self._values["flow_log_name"] = flow_log_name

    @builtins.property
    def log_store_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property logStoreName: The log store name.'''
        result = self._values.get("log_store_name")
        assert result is not None, "Required property 'log_store_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def project_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property projectName: The project name.'''
        result = self._values.get("project_name")
        assert result is not None, "Required property 'project_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def resource_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property resourceId: The resource id.'''
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def resource_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property resourceType: The resource type.'''
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property trafficType: The traffic type.'''
        result = self._values.get("traffic_type")
        assert result is not None, "Required property 'traffic_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The Description of flow log.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def flow_log_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property flowLogName: The flow log name.'''
        result = self._values.get("flow_log_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FlowLogProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ForwardEntry(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.ForwardEntry",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::ForwardEntry``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosForwardEntry``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-forwardentry
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["ForwardEntryProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0095dffd7d9a17a468e1da35040d2f06d15c6cbcd30f7cf5479d5dea3ea3ee5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrForwardEntryId")
    def attr_forward_entry_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ForwardEntryId: The id of created forward entry.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrForwardEntryId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.ForwardEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "external_ip": "externalIp",
        "external_port": "externalPort",
        "forward_table_id": "forwardTableId",
        "internal_ip": "internalIp",
        "internal_port": "internalPort",
        "ip_protocol": "ipProtocol",
        "forward_entry_name": "forwardEntryName",
        "port_break": "portBreak",
    },
)
class ForwardEntryProps:
    def __init__(
        self,
        *,
        external_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        external_port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        forward_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        internal_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        internal_port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ip_protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        forward_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        port_break: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``ForwardEntry``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-forwardentry

        :param external_ip: Property externalIp: Source IP, must belongs to bandwidth package internet IP.
        :param external_port: Property externalPort: Source port, now support [1-65535]|Any|x/y.
        :param forward_table_id: Property forwardTableId: Create forward entry in specified forward table.
        :param internal_ip: Property internalIp: Destination IP, must belong to VPC private IP.
        :param internal_port: Property internalPort: Destination port, now support [1-65535]|Any|x/y.
        :param ip_protocol: Property ipProtocol: Supported protocol, Now support 'TCP|UDP|Any'.
        :param forward_entry_name: Property forwardEntryName: the name of the DNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        :param port_break: Property portBreak: Specifies whether to remove limits on the port range.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dee1a22df8e08251409ef20b5a0b059a3b61ca46cb4c1a501df39204259b4284)
            check_type(argname="argument external_ip", value=external_ip, expected_type=type_hints["external_ip"])
            check_type(argname="argument external_port", value=external_port, expected_type=type_hints["external_port"])
            check_type(argname="argument forward_table_id", value=forward_table_id, expected_type=type_hints["forward_table_id"])
            check_type(argname="argument internal_ip", value=internal_ip, expected_type=type_hints["internal_ip"])
            check_type(argname="argument internal_port", value=internal_port, expected_type=type_hints["internal_port"])
            check_type(argname="argument ip_protocol", value=ip_protocol, expected_type=type_hints["ip_protocol"])
            check_type(argname="argument forward_entry_name", value=forward_entry_name, expected_type=type_hints["forward_entry_name"])
            check_type(argname="argument port_break", value=port_break, expected_type=type_hints["port_break"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "external_ip": external_ip,
            "external_port": external_port,
            "forward_table_id": forward_table_id,
            "internal_ip": internal_ip,
            "internal_port": internal_port,
            "ip_protocol": ip_protocol,
        }
        if forward_entry_name is not None:
            self._values["forward_entry_name"] = forward_entry_name
        if port_break is not None:
            self._values["port_break"] = port_break

    @builtins.property
    def external_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property externalIp: Source IP, must belongs to bandwidth package internet IP.'''
        result = self._values.get("external_ip")
        assert result is not None, "Required property 'external_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def external_port(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property externalPort: Source port, now support [1-65535]|Any|x/y.'''
        result = self._values.get("external_port")
        assert result is not None, "Required property 'external_port' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def forward_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property forwardTableId: Create forward entry in specified forward table.'''
        result = self._values.get("forward_table_id")
        assert result is not None, "Required property 'forward_table_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def internal_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property internalIp: Destination IP, must belong to VPC private IP.'''
        result = self._values.get("internal_ip")
        assert result is not None, "Required property 'internal_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def internal_port(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property internalPort: Destination port, now support [1-65535]|Any|x/y.'''
        result = self._values.get("internal_port")
        assert result is not None, "Required property 'internal_port' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def ip_protocol(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property ipProtocol: Supported protocol, Now support 'TCP|UDP|Any'.'''
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def forward_entry_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property forwardEntryName: the name of the DNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.'''
        result = self._values.get("forward_entry_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def port_break(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property portBreak: Specifies whether to remove limits on the port range.'''
        result = self._values.get("port_break")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ForwardEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class GrantInstanceToCen(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.GrantInstanceToCen",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::GrantInstanceToCen``, which is used to authorize a CEN instance.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosGrantInstanceToCen``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-grantinstancetocen
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["GrantInstanceToCenProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc5e7acf7e103f23314415ce58a42501bbda356be466306caab8346a51cd9149)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrCenId")
    def attr_cen_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute CenId: The ID of the CEN instance to be authorized.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrCenId"))

    @builtins.property
    @jsii.member(jsii_name="attrInstanceId")
    def attr_instance_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute InstanceId: The ID of the network instance.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInstanceId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.GrantInstanceToCenProps",
    jsii_struct_bases=[],
    name_mapping={
        "cen_id": "cenId",
        "cen_owner_id": "cenOwnerId",
        "instance_id": "instanceId",
        "instance_type": "instanceType",
    },
)
class GrantInstanceToCenProps:
    def __init__(
        self,
        *,
        cen_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        cen_owner_id: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        instance_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``GrantInstanceToCen``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-grantinstancetocen

        :param cen_id: Property cenId: The ID of the CEN instance to be authorized.
        :param cen_owner_id: Property cenOwnerId: The UID of the account to which the target CEN instance belongs.
        :param instance_id: Property instanceId: The ID of the network instance.
        :param instance_type: Property instanceType: The type of the network instance. Valid values: VPC: Virtual Private Cloud (VPC). VBR: Virtual Border Router (VBR). CCN: Cloud Connect Network (CCN).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2c894425053f8fcac01d8b3762db1b7b215d3008aea3e65a715149540181b48)
            check_type(argname="argument cen_id", value=cen_id, expected_type=type_hints["cen_id"])
            check_type(argname="argument cen_owner_id", value=cen_owner_id, expected_type=type_hints["cen_owner_id"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cen_id": cen_id,
            "cen_owner_id": cen_owner_id,
            "instance_id": instance_id,
            "instance_type": instance_type,
        }

    @builtins.property
    def cen_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property cenId: The ID of the CEN instance to be authorized.'''
        result = self._values.get("cen_id")
        assert result is not None, "Required property 'cen_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def cen_owner_id(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property cenOwnerId: The UID of the account to which the target CEN instance belongs.'''
        result = self._values.get("cen_owner_id")
        assert result is not None, "Required property 'cen_owner_id' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property instanceId: The ID of the network instance.'''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property instanceType: The type of the network instance.

        Valid values:
        VPC: Virtual Private Cloud (VPC).
        VBR: Virtual Border Router (VBR).
        CCN: Cloud Connect Network (CCN).
        '''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GrantInstanceToCenProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class HaVip(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.HaVip",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::HaVip``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosHaVip``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-havip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["HaVipProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f067ddbdf40550b104ce04c23631c97abab19652eb14a46e018b167a26a3515)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrHaVipId")
    def attr_ha_vip_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute HaVipId: Assigned HaVip ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrHaVipId"))

    @builtins.property
    @jsii.member(jsii_name="attrIpAddress")
    def attr_ip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute IpAddress: The IP address of the HAVIP.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpAddress"))


class HaVipAssociation(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.HaVipAssociation",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::HaVipAssociation``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosHaVipAssociation``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-havipassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["HaVipAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__226cc2a10bd9c44c3bdc87d37e69289c68f3eed71bca2980d315dcb6791192d4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.HaVipAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "ha_vip_id": "haVipId",
        "instance_id": "instanceId",
        "instance_type": "instanceType",
    },
)
class HaVipAssociationProps:
    def __init__(
        self,
        *,
        ha_vip_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``HaVipAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-havipassociation

        :param ha_vip_id: Property haVipId: The ID of the HAVIP.
        :param instance_id: Property instanceId: The ID of the ECS instance to be associated with the HAVIP.
        :param instance_type: Property instanceType: The type of the instance to be associated with the HAVIP. Valid values: EcsInstance: an ECS instance NetworkInterface: an ENI. If you want to associate the HAVIP with an ENI, this parameter is required.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d71b71099e9ab593d87a57afbc242b7c514531f64f6eba029bbd2087bd14fe21)
            check_type(argname="argument ha_vip_id", value=ha_vip_id, expected_type=type_hints["ha_vip_id"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ha_vip_id": ha_vip_id,
            "instance_id": instance_id,
        }
        if instance_type is not None:
            self._values["instance_type"] = instance_type

    @builtins.property
    def ha_vip_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property haVipId: The ID of the HAVIP.'''
        result = self._values.get("ha_vip_id")
        assert result is not None, "Required property 'ha_vip_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property instanceId: The ID of the ECS instance to be associated with the HAVIP.'''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceType: The type of the instance to be associated with the HAVIP.

        Valid values:
        EcsInstance: an ECS instance
        NetworkInterface: an ENI. If you want to associate the HAVIP with an ENI, this parameter is required.
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HaVipAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.HaVipProps",
    jsii_struct_bases=[],
    name_mapping={
        "v_switch_id": "vSwitchId",
        "description": "description",
        "ip_address": "ipAddress",
        "name": "name",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
    },
)
class HaVipProps:
    def __init__(
        self,
        *,
        v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["RosHaVip.TagsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``HaVip``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-havip

        :param v_switch_id: Property vSwitchId: The ID of the vSwitch to which the HAVIP belongs.
        :param description: Property description: The description of the HAVIP. The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        :param ip_address: Property ipAddress: The IP address of the HAVIP. The specified IP address must be an idle IP address that falls within the CIDR block of the vSwitch. If this parameter is not set, an idle IP address from the CIDR block of the vSwitch is randomly assigned to the HAVIP.
        :param name: Property name: The name of the HAVIP. The name must be 1 to 128 characters in length, and cannot start with http:// or https://.
        :param resource_group_id: Property resourceGroupId: The ID of the resource group to which the HAVIP belongs.
        :param tags: Property tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fe52a830e20ad17ebe20b98d123be8d8a51929d1dc4f101881ac1e5d32a0cc7)
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "v_switch_id": v_switch_id,
        }
        if description is not None:
            self._values["description"] = description
        if ip_address is not None:
            self._values["ip_address"] = ip_address
        if name is not None:
            self._values["name"] = name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vSwitchId: The ID of the vSwitch to which the HAVIP belongs.'''
        result = self._values.get("v_switch_id")
        assert result is not None, "Required property 'v_switch_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the HAVIP.

        The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ipAddress: The IP address of the HAVIP.

        The specified IP address must be an idle IP address that falls within the CIDR block of the vSwitch. If this parameter is not set, an idle IP address from the CIDR block of the vSwitch is randomly assigned to the HAVIP.
        '''
        result = self._values.get("ip_address")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the HAVIP.

        The name must be 1 to 128 characters in length, and cannot start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: The ID of the resource group to which the HAVIP belongs.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["RosHaVip.TagsProperty"]]:
        '''Property tags: Tags to attach to instance.

        Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["RosHaVip.TagsProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HaVipProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IpsecServer(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.IpsecServer",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::IpsecServer``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosIpsecServer``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipsecserver
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["IpsecServerProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__784943ddd818b6ff22967b40755677e85b1e6b74b0c21e3d62d6a7ad7c5e44c5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrIpsecServerId")
    def attr_ipsec_server_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute IpsecServerId: IPsec server ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpsecServerId"))

    @builtins.property
    @jsii.member(jsii_name="attrIpsecServerName")
    def attr_ipsec_server_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute IpsecServerName: IPsec server name.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpsecServerName"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.IpsecServerProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_ip_pool": "clientIpPool",
        "local_subnet": "localSubnet",
        "vpn_gateway_id": "vpnGatewayId",
        "effect_immediately": "effectImmediately",
        "ike_config": "ikeConfig",
        "ipsec_config": "ipsecConfig",
        "ipsec_server_name": "ipsecServerName",
        "psk": "psk",
        "psk_enabled": "pskEnabled",
    },
)
class IpsecServerProps:
    def __init__(
        self,
        *,
        client_ip_pool: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosIpsecServer.IkeConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosIpsecServer.IpsecConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_server_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        psk_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``IpsecServer``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipsecserver

        :param client_ip_pool: Property clientIpPool: Client network segment refers to the address segment that assigns access addresses to the virtual network card of the client. Note: The client network segment cannot conflict with the VPC side network segment.
        :param local_subnet: Property localSubnet: The local network segment refers to the network segment on the VPC side that needs to be interconnected with the client network segment. Use half-width commas (,) to separate multiple network segments, for example: 192.168.1.0/24,192.168.2.0/24.
        :param vpn_gateway_id: Property vpnGatewayId: VPN gateway instance ID.
        :param effect_immediately: Property effectImmediately: true: Apply the new configuration and trigger a reconnection immediately. false: Trigger a reconnection only when network traffic occurs. (The reconnection may cause the network to be unavailable for a brief moment)
        :param ike_config: Property ikeConfig: Negotiation parameter configuration in the first phase.
        :param ipsec_config: Property ipsecConfig: Negotiation parameter configuration in the second phase.
        :param ipsec_server_name: Property ipsecServerName: The value must be 2 to 128 characters in length and start with a letter or Chinese character. It can contain digits, underscores (_), and hyphens (-).
        :param psk: Property psk: Pre-Shared key. Used for identity authentication between the VPN gateway and the client. A 16-bit random string is randomly generated by default, or you can manually specify the key. The length is limited to 100 characters.
        :param psk_enabled: Property pskEnabled: Whether to enable the pre-shared key authentication method. Only the value is true, which means that the pre-shared key authentication mode is enabled.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c77a8f7b76571c102512e977171a1e0a6ffd0d63dbb93c4bd02a07580487b5f)
            check_type(argname="argument client_ip_pool", value=client_ip_pool, expected_type=type_hints["client_ip_pool"])
            check_type(argname="argument local_subnet", value=local_subnet, expected_type=type_hints["local_subnet"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument effect_immediately", value=effect_immediately, expected_type=type_hints["effect_immediately"])
            check_type(argname="argument ike_config", value=ike_config, expected_type=type_hints["ike_config"])
            check_type(argname="argument ipsec_config", value=ipsec_config, expected_type=type_hints["ipsec_config"])
            check_type(argname="argument ipsec_server_name", value=ipsec_server_name, expected_type=type_hints["ipsec_server_name"])
            check_type(argname="argument psk", value=psk, expected_type=type_hints["psk"])
            check_type(argname="argument psk_enabled", value=psk_enabled, expected_type=type_hints["psk_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_ip_pool": client_ip_pool,
            "local_subnet": local_subnet,
            "vpn_gateway_id": vpn_gateway_id,
        }
        if effect_immediately is not None:
            self._values["effect_immediately"] = effect_immediately
        if ike_config is not None:
            self._values["ike_config"] = ike_config
        if ipsec_config is not None:
            self._values["ipsec_config"] = ipsec_config
        if ipsec_server_name is not None:
            self._values["ipsec_server_name"] = ipsec_server_name
        if psk is not None:
            self._values["psk"] = psk
        if psk_enabled is not None:
            self._values["psk_enabled"] = psk_enabled

    @builtins.property
    def client_ip_pool(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property clientIpPool: Client network segment refers to the address segment that assigns access addresses to the virtual network card of the client.

        Note: The client network segment cannot conflict with the VPC side network segment.
        '''
        result = self._values.get("client_ip_pool")
        assert result is not None, "Required property 'client_ip_pool' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property localSubnet: The local network segment refers to the network segment on the VPC side that needs to be interconnected with the client network segment.

        Use half-width commas (,) to separate multiple network segments, for example: 192.168.1.0/24,192.168.2.0/24.
        '''
        result = self._values.get("local_subnet")
        assert result is not None, "Required property 'local_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpnGatewayId: VPN gateway instance ID.'''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property effectImmediately: true: Apply the new configuration and trigger a reconnection immediately.

        false: Trigger a reconnection only when network traffic occurs. (The reconnection may cause the network to be unavailable for a brief moment)
        '''
        result = self._values.get("effect_immediately")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IkeConfigProperty"]]:
        '''Property ikeConfig: Negotiation parameter configuration in the first phase.'''
        result = self._values.get("ike_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IkeConfigProperty"]], result)

    @builtins.property
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IpsecConfigProperty"]]:
        '''Property ipsecConfig: Negotiation parameter configuration in the second phase.'''
        result = self._values.get("ipsec_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IpsecConfigProperty"]], result)

    @builtins.property
    def ipsec_server_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ipsecServerName: The value must be 2 to 128 characters in length and start with a letter or Chinese character.

        It can contain digits, underscores (_), and hyphens (-).
        '''
        result = self._values.get("ipsec_server_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def psk(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property psk: Pre-Shared key.

        Used for identity authentication between the VPN gateway and the client. A 16-bit random string is randomly generated by default, or you can manually specify the key. The length is limited to 100 characters.
        '''
        result = self._values.get("psk")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def psk_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property pskEnabled: Whether to enable the pre-shared key authentication method.

        Only the value is true, which means that the pre-shared key authentication mode is enabled.
        '''
        result = self._values.get("psk_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IpsecServerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Ipv4Gateway(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.Ipv4Gateway",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::Ipv4Gateway``, which is used to create an IPv4 gateway.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosIpv4Gateway``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv4gateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["Ipv4GatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6969532d5e4aaa33652669e87413a9917b78e334836d4d474863a8a552161c4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrCreateTime")
    def attr_create_time(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute CreateTime: The creation time of the resource.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrCreateTime"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv4GatewayDescription")
    def attr_ipv4_gateway_description(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Ipv4GatewayDescription: Description information.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv4GatewayDescription"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv4GatewayId")
    def attr_ipv4_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Ipv4GatewayId: The resource attribute field that represents the resource level 1 ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv4GatewayId"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv4GatewayName")
    def attr_ipv4_gateway_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Ipv4GatewayName: Resource name.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv4GatewayName"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv4GatewayRouteTableId")
    def attr_ipv4_gateway_route_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Ipv4GatewayRouteTableId: ID of the route table associated with IPv4 Gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv4GatewayRouteTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpcId: The ID of the VPC associated with the IPv4 Gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpcId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.Ipv4GatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "ipv4_gateway_description": "ipv4GatewayDescription",
        "ipv4_gateway_name": "ipv4GatewayName",
    },
)
class Ipv4GatewayProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ipv4_gateway_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ipv4_gateway_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``Ipv4Gateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv4gateway

        :param vpc_id: Property vpcId: The ID of the VPC associated with the IPv4 Gateway.
        :param ipv4_gateway_description: Property ipv4GatewayDescription: Description information.
        :param ipv4_gateway_name: Property ipv4GatewayName: Resource name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81e8bb8e67a67ad7db5c144acba062ca394e729813d58742c41b437ad670e960)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument ipv4_gateway_description", value=ipv4_gateway_description, expected_type=type_hints["ipv4_gateway_description"])
            check_type(argname="argument ipv4_gateway_name", value=ipv4_gateway_name, expected_type=type_hints["ipv4_gateway_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if ipv4_gateway_description is not None:
            self._values["ipv4_gateway_description"] = ipv4_gateway_description
        if ipv4_gateway_name is not None:
            self._values["ipv4_gateway_name"] = ipv4_gateway_name

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpcId: The ID of the VPC associated with the IPv4 Gateway.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def ipv4_gateway_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ipv4GatewayDescription: Description information.'''
        result = self._values.get("ipv4_gateway_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ipv4_gateway_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ipv4GatewayName: Resource name.'''
        result = self._values.get("ipv4_gateway_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ipv4GatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Ipv6Gateway(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.Ipv6Gateway",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::Ipv6Gateway``, which is used to create an IPv6 gateway.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosIpv6Gateway``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv6gateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["Ipv6GatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fcc2ff41d68d240159e2304d424be09d585a2a77ce772871480ff2384fab8c2a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrIpv6GatewayId")
    def attr_ipv6_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Ipv6GatewayId: ID IPv6 gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv6GatewayId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.Ipv6GatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "description": "description",
        "name": "name",
        "spec": "spec",
        "tags": "tags",
    },
)
class Ipv6GatewayProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spec: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["RosIpv6Gateway.TagsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``Ipv6Gateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv6gateway

        :param vpc_id: Property vpcId: To open VPC ID IPv6 gateway.
        :param description: Property description: Description of IPv6 gateway. Length of 2 to 256 characters, must begin with a letter or Chinese, may contain numbers, numbers, underscore (_) and dot dash (-), but not at the http (.): // or https: // at the beginning .
        :param name: Property name: Name of the IPv6 gateway. Length of 2 to 128 characters, beginning with a letter or Chinese, can contain numbers, dot, underscore (_) and dash (-), but not at http (.): // or with https: // .
        :param spec: Property spec: Specifications IPv6 gateway, the value: Small (default): Free. Medium: Enterprise Edition. Large: Enterprise Enhanced Edition. Different specifications of the IPv6 forwarding capability of the gateway is different. For more information, see IPv6 gateway specification.
        :param tags: Property tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ce9c9c815de869188337cb28779ca7b2474464fa025844ce54c0e4376ea6a50)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name
        if spec is not None:
            self._values["spec"] = spec
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpcId: To open VPC ID IPv6 gateway.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Description of IPv6 gateway.

        Length of 2 to 256 characters, must begin with a letter or Chinese, may contain numbers, numbers, underscore (_) and dot dash (-), but not at the http (.): // or https: // at the beginning .
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: Name of the IPv6 gateway.

        Length of 2 to 128 characters, beginning with a letter or Chinese, can contain numbers, dot, underscore (_) and dash (-), but not at http (.): // or with https: // .
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spec(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spec: Specifications IPv6 gateway, the value: Small (default): Free.

        Medium: Enterprise Edition.
        Large: Enterprise Enhanced Edition.
        Different specifications of the IPv6 forwarding capability of the gateway is different. For more information, see IPv6 gateway specification.
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["RosIpv6Gateway.TagsProperty"]]:
        '''Property tags: Tags to attach to instance.

        Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["RosIpv6Gateway.TagsProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ipv6GatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Ipv6InternetBandwidth(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.Ipv6InternetBandwidth",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::Ipv6InternetBandwidth``, which is used to purchase Internet bandwidth for an IPv6 address.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosIpv6InternetBandwidth``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv6internetbandwidth
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["Ipv6InternetBandwidthProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__990da0029ad1776984a5893753ea3892584958427c1a4ae0c80f566a44ff6cad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrInternetBandwidthId")
    def attr_internet_bandwidth_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute InternetBandwidthId: Purchase of public network bandwidth.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInternetBandwidthId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.Ipv6InternetBandwidthProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "ipv6_address_id": "ipv6AddressId",
        "ipv6_gateway_id": "ipv6GatewayId",
        "internet_charge_type": "internetChargeType",
    },
)
class Ipv6InternetBandwidthProps:
    def __init__(
        self,
        *,
        bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        ipv6_address_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ipv6_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``Ipv6InternetBandwidth``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv6internetbandwidth

        :param bandwidth: Property bandwidth: Public IPv6 address of bandwidth, unit: Mbps, range: 1-5000. When InternetChargeType is PayByBandwidth, the bandwidth of the public network is the IPv6 address 1-5000. When InternetChargeType is PayByTraffic, public network bandwidth IPv6 addresses while IPv6 gateway restricted specifications. Small (default free version), the public network bandwidth range 1-500. Medium (Enterprise Edition), the public network bandwidth range from 1 to 1000. Large (Enterprise Edition), the public network bandwidth range 1-2000.
        :param ipv6_address_id: Property ipv6AddressId: ID of IPv6 address.
        :param ipv6_gateway_id: Property ipv6GatewayId: ID of IPv6 gateway.
        :param internet_charge_type: Property internetChargeType: IPv6 public network bandwidth billing, value: - **PayByTraffic**: by using the traffic accounting. - **PayByBandwidth** (default): Bandwidth billing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b27eaba2447125f7450e2662e51fff76a2df79d154a7da787023c11b454e0ef6)
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument ipv6_address_id", value=ipv6_address_id, expected_type=type_hints["ipv6_address_id"])
            check_type(argname="argument ipv6_gateway_id", value=ipv6_gateway_id, expected_type=type_hints["ipv6_gateway_id"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bandwidth": bandwidth,
            "ipv6_address_id": ipv6_address_id,
            "ipv6_gateway_id": ipv6_gateway_id,
        }
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property bandwidth: Public IPv6 address of bandwidth, unit: Mbps, range: 1-5000.

        When InternetChargeType is PayByBandwidth, the bandwidth of the public network is the IPv6 address 1-5000.
        When InternetChargeType is PayByTraffic, public network bandwidth IPv6 addresses while IPv6 gateway restricted specifications.
        Small (default free version), the public network bandwidth range 1-500.
        Medium (Enterprise Edition), the public network bandwidth range from 1 to 1000.
        Large (Enterprise Edition), the public network bandwidth range 1-2000.
        '''
        result = self._values.get("bandwidth")
        assert result is not None, "Required property 'bandwidth' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def ipv6_address_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property ipv6AddressId: ID of IPv6 address.'''
        result = self._values.get("ipv6_address_id")
        assert result is not None, "Required property 'ipv6_address_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def ipv6_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property ipv6GatewayId: ID of IPv6 gateway.'''
        result = self._values.get("ipv6_gateway_id")
        assert result is not None, "Required property 'ipv6_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetChargeType: IPv6 public network bandwidth billing, value: - **PayByTraffic**: by using the traffic accounting.

        - **PayByBandwidth** (default): Bandwidth billing.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ipv6InternetBandwidthProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NatGateway(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.NatGateway",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::NatGateway``, which is used to create a NAT gateway.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosNatGateway``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-natgateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["NatGatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c3321e6c02274d96c82db07f0ad8ce218e5ac02ac6ee04b1e0b94c9d348b68e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrForwardTableId")
    def attr_forward_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ForwardTableId: The forward table id.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrForwardTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrNatGatewayId")
    def attr_nat_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute NatGatewayId: The Id of created NAT gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNatGatewayId"))

    @builtins.property
    @jsii.member(jsii_name="attrSNatTableId")
    def attr_s_nat_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute SNatTableId: The SNAT table id.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSNatTableId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.NatGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "v_switch_id": "vSwitchId",
        "auto_pay": "autoPay",
        "deletion_force": "deletionForce",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "duration": "duration",
        "eip_bind_mode": "eipBindMode",
        "icmp_reply_enabled": "icmpReplyEnabled",
        "instance_charge_type": "instanceChargeType",
        "internet_charge_type": "internetChargeType",
        "nat_gateway_name": "natGatewayName",
        "nat_type": "natType",
        "network_type": "networkType",
        "pricing_cycle": "pricingCycle",
        "security_protection_enabled": "securityProtectionEnabled",
        "tags": "tags",
    },
)
class NatGatewayProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_force: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        duration: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        eip_bind_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        icmp_reply_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        nat_gateway_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        nat_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_protection_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["RosNatGateway.TagsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``NatGateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-natgateway

        :param vpc_id: Property vpcId: The VPC id to create NAT gateway.
        :param v_switch_id: Property vSwitchId: The VSwitch id to create NAT gateway.
        :param auto_pay: Property autoPay: Specifies whether to enable automatic payment. Default is true.
        :param deletion_force: Property deletionForce: Whether force delete the relative snat and dnat entries in the net gateway and unbind eips. Default value is false.
        :param deletion_protection: Property deletionProtection: Whether to enable deletion protection. Default to False.
        :param description: Property description: Description of the NAT gateway, [2, 256] characters. Do not fill or empty, the default is empty.
        :param duration: Property duration: The subscription duration. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36. While choose pay by year, it could be from 1 to 3.
        :param eip_bind_mode: Property eipBindMode: The mode in which the EIP is associated with the NAT gateway. Valid values:MULTI_BINDED (default): the multi-EIP-to-ENI mode. NAT: NAT mode. IPv4 gateways are supported. Note If the EIP is associated with the NAT gateway in NAT mode, the EIP occupies a private IP address of the vSwitch to which the NAT gateway belongs. Make sure that the vSwitch has sufficient private IP addresses. Otherwise, the EIP cannot be associated with the NAT gateway. In NAT mode, a maximum number of 50 EIPs can be associated with each NAT gateway.
        :param icmp_reply_enabled: Property icmpReplyEnabled: Specifies whether to enable the ICMP non-retrieval feature. Default: True
        :param instance_charge_type: Property instanceChargeType: The billing method. The default value is PostPaid (which means pay-as-you-go).
        :param internet_charge_type: Property internetChargeType: The billing method for the NAT gateway. Valid values: PayBySpec: billed on a pay-by-specification basis.
        :param nat_gateway_name: Property natGatewayName: Display name of the NAT gateway, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
        :param nat_type: Property natType: The type of the NAT gateway. Valid values: - Enhanced: enhanced NAT gateway.
        :param network_type: Property networkType: The type of the created NAT gateway. Internet: public network NAT gateway. Intranet: VPC NAT gateway.
        :param pricing_cycle: Property pricingCycle: Price cycle of the resource. This property has no default value.
        :param security_protection_enabled: Property securityProtectionEnabled: Specifies whether to enable the firewall feature. Default: False
        :param tags: Property tags: Tags to attach to natgateway. Max support 20 tags to add during create natgateway. Each tag with two properties Key and Value, and Key is required.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__611d710e8cb59c4e6d950c4738dea7757a2a928aed21c8f2755baafd59025d8a)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument deletion_force", value=deletion_force, expected_type=type_hints["deletion_force"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument duration", value=duration, expected_type=type_hints["duration"])
            check_type(argname="argument eip_bind_mode", value=eip_bind_mode, expected_type=type_hints["eip_bind_mode"])
            check_type(argname="argument icmp_reply_enabled", value=icmp_reply_enabled, expected_type=type_hints["icmp_reply_enabled"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument nat_gateway_name", value=nat_gateway_name, expected_type=type_hints["nat_gateway_name"])
            check_type(argname="argument nat_type", value=nat_type, expected_type=type_hints["nat_type"])
            check_type(argname="argument network_type", value=network_type, expected_type=type_hints["network_type"])
            check_type(argname="argument pricing_cycle", value=pricing_cycle, expected_type=type_hints["pricing_cycle"])
            check_type(argname="argument security_protection_enabled", value=security_protection_enabled, expected_type=type_hints["security_protection_enabled"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
            "v_switch_id": v_switch_id,
        }
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if deletion_force is not None:
            self._values["deletion_force"] = deletion_force
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if duration is not None:
            self._values["duration"] = duration
        if eip_bind_mode is not None:
            self._values["eip_bind_mode"] = eip_bind_mode
        if icmp_reply_enabled is not None:
            self._values["icmp_reply_enabled"] = icmp_reply_enabled
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if nat_gateway_name is not None:
            self._values["nat_gateway_name"] = nat_gateway_name
        if nat_type is not None:
            self._values["nat_type"] = nat_type
        if network_type is not None:
            self._values["network_type"] = network_type
        if pricing_cycle is not None:
            self._values["pricing_cycle"] = pricing_cycle
        if security_protection_enabled is not None:
            self._values["security_protection_enabled"] = security_protection_enabled
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpcId: The VPC id to create NAT gateway.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vSwitchId: The VSwitch id to create NAT gateway.'''
        result = self._values.get("v_switch_id")
        assert result is not None, "Required property 'v_switch_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoPay: Specifies whether to enable automatic payment.

        Default is true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_force(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property deletionForce: Whether force delete the relative snat and dnat entries in the net gateway and unbind eips.

        Default value is false.
        '''
        result = self._values.get("deletion_force")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property deletionProtection: Whether to enable deletion protection.

        Default to False.
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Description of the NAT gateway, [2, 256] characters.

        Do not fill or empty, the default is empty.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def duration(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property duration: The subscription duration.

        While choose by pay by month, it could be from 1 to 9 or 12, 24, 36. While choose pay by year, it could be from 1 to 3.
        '''
        result = self._values.get("duration")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def eip_bind_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property eipBindMode: The mode in which the EIP is associated with the NAT gateway.

        Valid values:MULTI_BINDED (default): the multi-EIP-to-ENI mode.
        NAT: NAT mode. IPv4 gateways are supported.
        Note If the EIP is associated with the NAT gateway in NAT mode,
        the EIP occupies a private IP address of the vSwitch to which the NAT gateway belongs.
        Make sure that the vSwitch has sufficient private IP addresses.
        Otherwise, the EIP cannot be associated with the NAT gateway.
        In NAT mode, a maximum number of 50 EIPs can be associated with each NAT gateway.
        '''
        result = self._values.get("eip_bind_mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def icmp_reply_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property icmpReplyEnabled: Specifies whether to enable the ICMP non-retrieval feature.

        Default: True
        '''
        result = self._values.get("icmp_reply_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceChargeType: The billing method.

        The default value is PostPaid (which means pay-as-you-go).
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property internetChargeType: The billing method for the NAT gateway.

        Valid values:
        PayBySpec: billed on a pay-by-specification basis.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def nat_gateway_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property natGatewayName: Display name of the NAT gateway, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.'''
        result = self._values.get("nat_gateway_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def nat_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property natType: The type of the NAT gateway.

        Valid values:

        - Enhanced: enhanced NAT gateway.
        '''
        result = self._values.get("nat_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property networkType: The type of the created NAT gateway.

        Internet: public network NAT gateway.
        Intranet: VPC NAT gateway.
        '''
        result = self._values.get("network_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property pricingCycle: Price cycle of the resource.

        This property has no default value.
        '''
        result = self._values.get("pricing_cycle")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_protection_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property securityProtectionEnabled: Specifies whether to enable the firewall feature.

        Default: False
        '''
        result = self._values.get("security_protection_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["RosNatGateway.TagsProperty"]]:
        '''Property tags: Tags to attach to natgateway.

        Max support 20 tags to add during create natgateway. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["RosNatGateway.TagsProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NatGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NatIp(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.NatIp",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::NatIp``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosNatIp``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-natip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["NatIpProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46efa3408ae5c979d075ab3eb1755b054450ce9624dcb86e778cf4a6e6c091b1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrNatIp")
    def attr_nat_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute NatIp: NAT IP address.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNatIp"))

    @builtins.property
    @jsii.member(jsii_name="attrNatIpId")
    def attr_nat_ip_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute NatIpId: The ID of the NAT IP address.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNatIpId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.NatIpProps",
    jsii_struct_bases=[],
    name_mapping={
        "nat_gateway_id": "natGatewayId",
        "nat_ip_cidr": "natIpCidr",
        "nat_ip_description": "natIpDescription",
        "nat_ip_name": "natIpName",
        "nat_ip": "natIp",
        "nat_ip_cidr_id": "natIpCidrId",
    },
)
class NatIpProps:
    def __init__(
        self,
        *,
        nat_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        nat_ip_cidr: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        nat_ip_description: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        nat_ip_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        nat_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        nat_ip_cidr_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``NatIp``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-natip

        :param nat_gateway_id: Property natGatewayId: The ID of the Virtual Private Cloud (VPC) NAT gateway for which you want to create the NAT IP address.
        :param nat_ip_cidr: Property natIpCidr: The CIDR block to which the NAT IP address belongs.
        :param nat_ip_description: Property natIpDescription: The description of the NAT IP address. The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        :param nat_ip_name: Property natIpName: The name of the NAT IP address. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). It must start with a letter. It cannot start with http:// or https://.
        :param nat_ip: Property natIp: The NAT IP address that you want to create. If you do not specify an IP address, the system selects a random IP address from the specified CIDR block.
        :param nat_ip_cidr_id: Property natIpCidrId: The ID of the CIDR block to which the NAT IP address belongs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed669c924d01cdad192101a1dcd5ec9c8843b7a84d875b0334f756f6575d85cf)
            check_type(argname="argument nat_gateway_id", value=nat_gateway_id, expected_type=type_hints["nat_gateway_id"])
            check_type(argname="argument nat_ip_cidr", value=nat_ip_cidr, expected_type=type_hints["nat_ip_cidr"])
            check_type(argname="argument nat_ip_description", value=nat_ip_description, expected_type=type_hints["nat_ip_description"])
            check_type(argname="argument nat_ip_name", value=nat_ip_name, expected_type=type_hints["nat_ip_name"])
            check_type(argname="argument nat_ip", value=nat_ip, expected_type=type_hints["nat_ip"])
            check_type(argname="argument nat_ip_cidr_id", value=nat_ip_cidr_id, expected_type=type_hints["nat_ip_cidr_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "nat_gateway_id": nat_gateway_id,
            "nat_ip_cidr": nat_ip_cidr,
            "nat_ip_description": nat_ip_description,
            "nat_ip_name": nat_ip_name,
        }
        if nat_ip is not None:
            self._values["nat_ip"] = nat_ip
        if nat_ip_cidr_id is not None:
            self._values["nat_ip_cidr_id"] = nat_ip_cidr_id

    @builtins.property
    def nat_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property natGatewayId: The ID of the Virtual Private Cloud (VPC) NAT gateway for which you want to create the NAT IP address.'''
        result = self._values.get("nat_gateway_id")
        assert result is not None, "Required property 'nat_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def nat_ip_cidr(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property natIpCidr: The CIDR block to which the NAT IP address belongs.'''
        result = self._values.get("nat_ip_cidr")
        assert result is not None, "Required property 'nat_ip_cidr' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def nat_ip_description(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property natIpDescription: The description of the NAT IP address.

        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        result = self._values.get("nat_ip_description")
        assert result is not None, "Required property 'nat_ip_description' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def nat_ip_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property natIpName: The name of the NAT IP address.

        The name must be 2 to 128 characters in length, and can contain letters, digits, periods
        (.), underscores (_), and hyphens (-). It must start with a letter. It cannot start
        with http:// or https://.
        '''
        result = self._values.get("nat_ip_name")
        assert result is not None, "Required property 'nat_ip_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def nat_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property natIp: The NAT IP address that you want to create.

        If you do not specify an IP address, the system selects a random IP address from the
        specified CIDR block.
        '''
        result = self._values.get("nat_ip")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def nat_ip_cidr_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property natIpCidrId: The ID of the CIDR block to which the NAT IP address belongs.'''
        result = self._values.get("nat_ip_cidr_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NatIpProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkAcl(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.NetworkAcl",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::NetworkAcl``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosNetworkAcl``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-networkacl
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["NetworkAclProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ff2dffe673ec52a0f618c924b41f51b2cfd06503bb4a611e56efc187ff3d912)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrNetworkAclEntryName")
    def attr_network_acl_entry_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute NetworkAclEntryName: The name of the inbound rule.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNetworkAclEntryName"))

    @builtins.property
    @jsii.member(jsii_name="attrNetworkAclId")
    def attr_network_acl_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute NetworkAclId: The ID of the network ACL.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNetworkAclId"))


class NetworkAclAssociation(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.NetworkAclAssociation",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::NetworkAclAssociation``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosNetworkAclAssociation``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-networkaclassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["NetworkAclAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1677ae8097256604efd36efad7299fcb3247ebab03f466908b392019134fc340)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrNetworkAclId")
    def attr_network_acl_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute NetworkAclId: The ID of the network ACL.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNetworkAclId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.NetworkAclAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"network_acl_id": "networkAclId", "resources": "resources"},
)
class NetworkAclAssociationProps:
    def __init__(
        self,
        *,
        network_acl_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        resources: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosNetworkAclAssociation.ResourcesProperty", typing.Dict[builtins.str, typing.Any]]]]],
    ) -> None:
        '''Properties for defining a ``NetworkAclAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-networkaclassociation

        :param network_acl_id: Property networkAclId: The ID of the network ACL.
        :param resources: Property resources: The list of resources that need to be associated with network ACL.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10735784a22c3bb11df8d25529deb11e276b4dc17b5b1056f447c956db59167b)
            check_type(argname="argument network_acl_id", value=network_acl_id, expected_type=type_hints["network_acl_id"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_acl_id": network_acl_id,
            "resources": resources,
        }

    @builtins.property
    def network_acl_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property networkAclId: The ID of the network ACL.'''
        result = self._values.get("network_acl_id")
        assert result is not None, "Required property 'network_acl_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAclAssociation.ResourcesProperty"]]]:
        '''Property resources: The list of resources that need to be associated with network ACL.'''
        result = self._values.get("resources")
        assert result is not None, "Required property 'resources' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAclAssociation.ResourcesProperty"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkAclAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.NetworkAclProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "description": "description",
        "egress_acl_entries": "egressAclEntries",
        "ingress_acl_entries": "ingressAclEntries",
        "network_acl_name": "networkAclName",
    },
)
class NetworkAclProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        egress_acl_entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosNetworkAcl.EgressAclEntriesProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ingress_acl_entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosNetworkAcl.IngressAclEntriesProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        network_acl_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``NetworkAcl``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-networkacl

        :param vpc_id: Property vpcId: The ID of the virtual private cloud (VPC) to which the network ACL belongs.
        :param description: Property description: The description of the network ACL. The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with http:// or https://.
        :param egress_acl_entries: Property egressAclEntries: The list of egress network ACL entries.
        :param ingress_acl_entries: Property ingressAclEntries: The list of ingress network ACL entries.
        :param network_acl_name: Property networkAclName: The name of the network ACL. The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter and cannot start with http:// or https://.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c9b342f018e6c6c886ffda4b4084149e391fe891cc9c790d8c77efa54ef49ca)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument egress_acl_entries", value=egress_acl_entries, expected_type=type_hints["egress_acl_entries"])
            check_type(argname="argument ingress_acl_entries", value=ingress_acl_entries, expected_type=type_hints["ingress_acl_entries"])
            check_type(argname="argument network_acl_name", value=network_acl_name, expected_type=type_hints["network_acl_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if description is not None:
            self._values["description"] = description
        if egress_acl_entries is not None:
            self._values["egress_acl_entries"] = egress_acl_entries
        if ingress_acl_entries is not None:
            self._values["ingress_acl_entries"] = ingress_acl_entries
        if network_acl_name is not None:
            self._values["network_acl_name"] = network_acl_name

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpcId: The ID of the virtual private cloud (VPC) to which the network ACL belongs.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the network ACL.

        The description must be 2 to 256 characters in length. The description must start
        with a letter but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def egress_acl_entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.EgressAclEntriesProperty"]]]]:
        '''Property egressAclEntries: The list of egress network ACL entries.'''
        result = self._values.get("egress_acl_entries")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.EgressAclEntriesProperty"]]]], result)

    @builtins.property
    def ingress_acl_entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.IngressAclEntriesProperty"]]]]:
        '''Property ingressAclEntries: The list of ingress network ACL entries.'''
        result = self._values.get("ingress_acl_entries")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.IngressAclEntriesProperty"]]]], result)

    @builtins.property
    def network_acl_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property networkAclName: The name of the network ACL.

        The name must be 2 to 128 characters in length and can contain letters, digits, periods
        (.), underscores (_), and hyphens (-). The name must start with a letter and cannot
        start with http:// or https://.
        '''
        result = self._values.get("network_acl_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkAclProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PeeringRouterInterfaceBinding(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.PeeringRouterInterfaceBinding",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::PeeringRouterInterfaceBinding``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosPeeringRouterInterfaceBinding``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-peeringrouterinterfacebinding
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["PeeringRouterInterfaceBindingProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ded9e2786f79139c5e108fbcd4ffc395e4c759c85451bb2a1d8cffcfbbdb3d2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrRouterInterfaceId")
    def attr_router_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouterInterfaceId: The RouterInterface ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouterInterfaceId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.PeeringRouterInterfaceBindingProps",
    jsii_struct_bases=[],
    name_mapping={
        "opposite_interface_id": "oppositeInterfaceId",
        "router_interface_id": "routerInterfaceId",
        "opposite_interface_owner_id": "oppositeInterfaceOwnerId",
        "opposite_router_id": "oppositeRouterId",
    },
)
class PeeringRouterInterfaceBindingProps:
    def __init__(
        self,
        *,
        opposite_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        router_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        opposite_interface_owner_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_router_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``PeeringRouterInterfaceBinding``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-peeringrouterinterfacebinding

        :param opposite_interface_id: Property oppositeInterfaceId: The connection peer RouterInterface ID.
        :param router_interface_id: Property routerInterfaceId: The RouterInterface is set the parameters of the connection peer RouterInterface.
        :param opposite_interface_owner_id: Property oppositeInterfaceOwnerId: Owner account ID of the connection peer RouterInterface.
        :param opposite_router_id: Property oppositeRouterId: Router ID of the connection peer RouterInterface.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f41cee50c699285a2e37ba23c8a455d0589fea1f9220e3306dc8ab39ebf5191)
            check_type(argname="argument opposite_interface_id", value=opposite_interface_id, expected_type=type_hints["opposite_interface_id"])
            check_type(argname="argument router_interface_id", value=router_interface_id, expected_type=type_hints["router_interface_id"])
            check_type(argname="argument opposite_interface_owner_id", value=opposite_interface_owner_id, expected_type=type_hints["opposite_interface_owner_id"])
            check_type(argname="argument opposite_router_id", value=opposite_router_id, expected_type=type_hints["opposite_router_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "opposite_interface_id": opposite_interface_id,
            "router_interface_id": router_interface_id,
        }
        if opposite_interface_owner_id is not None:
            self._values["opposite_interface_owner_id"] = opposite_interface_owner_id
        if opposite_router_id is not None:
            self._values["opposite_router_id"] = opposite_router_id

    @builtins.property
    def opposite_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property oppositeInterfaceId: The connection peer RouterInterface ID.'''
        result = self._values.get("opposite_interface_id")
        assert result is not None, "Required property 'opposite_interface_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routerInterfaceId: The RouterInterface is set the parameters of the connection peer RouterInterface.'''
        result = self._values.get("router_interface_id")
        assert result is not None, "Required property 'router_interface_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def opposite_interface_owner_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property oppositeInterfaceOwnerId: Owner account ID of the connection peer RouterInterface.'''
        result = self._values.get("opposite_interface_owner_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_router_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property oppositeRouterId: Router ID of the connection peer RouterInterface.'''
        result = self._values.get("opposite_router_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PeeringRouterInterfaceBindingProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PeeringRouterInterfaceConnection(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.PeeringRouterInterfaceConnection",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::PeeringRouterInterfaceConnection``, which is used to initiate a router interface connection.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosPeeringRouterInterfaceConnection``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-peeringrouterinterfaceconnection
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["PeeringRouterInterfaceConnectionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__222e301b5335df247c7e55e452903e8bcd826e8557e0f5d91fca401d777a01a3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrOppositeInterfaceId")
    def attr_opposite_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute OppositeInterfaceId: The receiver RouterInterface ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOppositeInterfaceId"))

    @builtins.property
    @jsii.member(jsii_name="attrRouterInterfaceId")
    def attr_router_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouterInterfaceId: The initiator RouterInterface ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouterInterfaceId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.PeeringRouterInterfaceConnectionProps",
    jsii_struct_bases=[],
    name_mapping={
        "opposite_interface_id": "oppositeInterfaceId",
        "router_interface_id": "routerInterfaceId",
    },
)
class PeeringRouterInterfaceConnectionProps:
    def __init__(
        self,
        *,
        opposite_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        router_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``PeeringRouterInterfaceConnection``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-peeringrouterinterfaceconnection

        :param opposite_interface_id: Property oppositeInterfaceId: The Receiver RouterInterface ID to accept peer RouterInterface.
        :param router_interface_id: Property routerInterfaceId: The Initiator RouterInterface ID to connect peer RouterInterface.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9afea2e9a428a89f7f7fb51b223669c6c402140a9fc52b0ee89fb52a31afed6)
            check_type(argname="argument opposite_interface_id", value=opposite_interface_id, expected_type=type_hints["opposite_interface_id"])
            check_type(argname="argument router_interface_id", value=router_interface_id, expected_type=type_hints["router_interface_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "opposite_interface_id": opposite_interface_id,
            "router_interface_id": router_interface_id,
        }

    @builtins.property
    def opposite_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property oppositeInterfaceId: The Receiver RouterInterface ID to accept peer RouterInterface.'''
        result = self._values.get("opposite_interface_id")
        assert result is not None, "Required property 'opposite_interface_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routerInterfaceId: The Initiator RouterInterface ID to connect peer RouterInterface.'''
        result = self._values.get("router_interface_id")
        assert result is not None, "Required property 'router_interface_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PeeringRouterInterfaceConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PrefixList(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.PrefixList",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::PrefixList``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosPrefixList``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-prefixlist
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Optional[typing.Union["PrefixListProps", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd25808369c91541b81f30bc9946232c767db94b53f8ad4b053eee2d868e4b88)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrCreateTime")
    def attr_create_time(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute CreateTime: The time when the prefix list was created.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrCreateTime"))

    @builtins.property
    @jsii.member(jsii_name="attrEntries")
    def attr_entries(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Entries: The CIDR address block list of the prefix list.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEntries"))

    @builtins.property
    @jsii.member(jsii_name="attrIpVersion")
    def attr_ip_version(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute IpVersion: The IP version of the prefix list.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpVersion"))

    @builtins.property
    @jsii.member(jsii_name="attrMaxEntries")
    def attr_max_entries(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute MaxEntries: The maximum number of entries for CIDR address blocks in the prefix list.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrMaxEntries"))

    @builtins.property
    @jsii.member(jsii_name="attrOwnerId")
    def attr_owner_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute OwnerId: The Alibaba Cloud account (primary account) to which the prefix list belongs.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOwnerId"))

    @builtins.property
    @jsii.member(jsii_name="attrPrefixListDescription")
    def attr_prefix_list_description(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute PrefixListDescription: The description of the prefix list.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPrefixListDescription"))

    @builtins.property
    @jsii.member(jsii_name="attrPrefixListId")
    def attr_prefix_list_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute PrefixListId: The ID of the query Prefix List.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPrefixListId"))

    @builtins.property
    @jsii.member(jsii_name="attrPrefixListName")
    def attr_prefix_list_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute PrefixListName: The name of the prefix list.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPrefixListName"))

    @builtins.property
    @jsii.member(jsii_name="attrResourceGroupId")
    def attr_resource_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ResourceGroupId: The ID of the resource group to which the VPC belongs.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrResourceGroupId"))

    @builtins.property
    @jsii.member(jsii_name="attrShareType")
    def attr_share_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute ShareType: The share type of the prefix list.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrShareType"))

    @builtins.property
    @jsii.member(jsii_name="attrTags")
    def attr_tags(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Tags: The tags of PrefixList.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTags"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.PrefixListProps",
    jsii_struct_bases=[],
    name_mapping={
        "entries": "entries",
        "ip_version": "ipVersion",
        "max_entries": "maxEntries",
        "prefix_list_description": "prefixListDescription",
        "prefix_list_name": "prefixListName",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
    },
)
class PrefixListProps:
    def __init__(
        self,
        *,
        entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosPrefixList.EntriesProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ip_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        max_entries: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        prefix_list_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        prefix_list_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["RosPrefixList.TagsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``PrefixList``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-prefixlist

        :param entries: Property entries: The CIDR address block list of the prefix list.
        :param ip_version: Property ipVersion: The IP version of the prefix list. Value: - **IPvv4**:IPv4 version. - **IPv6**:IPv6.
        :param max_entries: Property maxEntries: The maximum number of entries for CIDR address blocks in the prefix list.
        :param prefix_list_description: Property prefixListDescription: The description of the prefix list. It must be 2 to 256 characters in length and must start with a letter or Chinese, but cannot start with http:// or https.
        :param prefix_list_name: Property prefixListName: The name of the prefix list.
        :param resource_group_id: Property resourceGroupId: The ID of the resource group to which the VPC belongs.
        :param tags: Property tags: Tags of prefix list.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fc2b2c3de2465e32834774d01eb54c130d8e82b257f5d1d9cf20f9f5234b1b3)
            check_type(argname="argument entries", value=entries, expected_type=type_hints["entries"])
            check_type(argname="argument ip_version", value=ip_version, expected_type=type_hints["ip_version"])
            check_type(argname="argument max_entries", value=max_entries, expected_type=type_hints["max_entries"])
            check_type(argname="argument prefix_list_description", value=prefix_list_description, expected_type=type_hints["prefix_list_description"])
            check_type(argname="argument prefix_list_name", value=prefix_list_name, expected_type=type_hints["prefix_list_name"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if entries is not None:
            self._values["entries"] = entries
        if ip_version is not None:
            self._values["ip_version"] = ip_version
        if max_entries is not None:
            self._values["max_entries"] = max_entries
        if prefix_list_description is not None:
            self._values["prefix_list_description"] = prefix_list_description
        if prefix_list_name is not None:
            self._values["prefix_list_name"] = prefix_list_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosPrefixList.EntriesProperty"]]]]:
        '''Property entries: The CIDR address block list of the prefix list.'''
        result = self._values.get("entries")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosPrefixList.EntriesProperty"]]]], result)

    @builtins.property
    def ip_version(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property ipVersion: The IP version of the prefix list.

        Value:

        - **IPvv4**:IPv4 version.
        - **IPv6**:IPv6.
        '''
        result = self._values.get("ip_version")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def max_entries(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property maxEntries: The maximum number of entries for CIDR address blocks in the prefix list.'''
        result = self._values.get("max_entries")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def prefix_list_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property prefixListDescription: The description of the prefix list.

        It must be 2 to 256 characters in length and must start with a letter or Chinese, but cannot start with http:// or https.
        '''
        result = self._values.get("prefix_list_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def prefix_list_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property prefixListName: The name of the prefix list.'''
        result = self._values.get("prefix_list_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: The ID of the resource group to which the VPC belongs.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["RosPrefixList.TagsProperty"]]:
        '''Property tags: Tags of prefix list.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["RosPrefixList.TagsProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrefixListProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosAnycastEIP(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosAnycastEIP",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::AnycastEIP``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``AnycastEIP`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-anycasteip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosAnycastEIPProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d08a1ce0bc8d9915a4f353fa821360e53f63da8ff2ed642a9292ec43ace36bf)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc3309c82f54a81763cd0f2dd30917817947535f5ff173e05b30d9a4b8e6e09b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrAnycastId")
    def attr_anycast_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: AnycastId: Anycast EIP instance ID
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAnycastId"))

    @builtins.property
    @jsii.member(jsii_name="attrIpAddress")
    def attr_ip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: IpAddress: Anycase IP address
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpAddress"))

    @builtins.property
    @jsii.member(jsii_name="attrName")
    def attr_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Name: Anycast EIP instance name
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrName"))

    @builtins.property
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: OrderId: Order ID
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOrderId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30c65c3b5be8f01714d138317b69d08ec3f7ee4eecdc47e4b3b881fe0b61d936)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="bandwidth")
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: bandwidth: Anycast EIP instance bandwidth
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "bandwidth"))

    @bandwidth.setter
    def bandwidth(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63f6374f693bf08606ede72e31d10d5ec8c9c8b4886a3a8c6bd1449de8df2a7d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Anycast EIP instance description
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1872bff0b9b185e947ae4c6ec3ad6574caffb001b6b9b256a6f9f9664e42596d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: Anycast EIP instance charge type
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceChargeType"))

    @instance_charge_type.setter
    def instance_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6154f7b0aff03ca1dcc387376c6467b293dfc81170af208afffe5bd1b6ba270c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetChargeType: Anycast EIP instance access public network billing method
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetChargeType"))

    @internet_charge_type.setter
    def internet_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a5bd814b64ff1423dc5ad262e7af15efcdd23c116e114261478f2edbcd7d697)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: Anycast EIP instance name
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51e19475720fc6d067d0a038869ebff6f6ce713e22382ecebb702d5140907573)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="serviceLocation")
    def service_location(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: serviceLocation: Anycast EIP instance access area
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "serviceLocation"))

    @service_location.setter
    def service_location(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d7024ad96d2d46f637d79bc1c07080c1ae903d60fa54ef0f163cc3a8c0a8ab5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serviceLocation", value)


class RosAnycastEIPAssociation(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosAnycastEIPAssociation",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::AnycastEIPAssociation``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``AnycastEIPAssociation`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-anycasteipassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosAnycastEIPAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d69ba89af7850f3b31f32d4967b7dd83bf2da597bc310b2f560b252cfea273f0)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10516f8f1b6d2b65f05991c1c480e0b9112791e02f10eca63c55e06672e4fb3d)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrAnycastId")
    def attr_anycast_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: AnycastId: Anycast EIP instance ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAnycastId"))

    @builtins.property
    @jsii.member(jsii_name="attrBindInstanceId")
    def attr_bind_instance_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: BindInstanceId: The ID of the cloud resource instance to be bound.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBindInstanceId"))

    @builtins.property
    @jsii.member(jsii_name="attrBindInstanceRegionId")
    def attr_bind_instance_region_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: BindInstanceRegionId: The region ID of the cloud resource instance to be bound.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBindInstanceRegionId"))

    @builtins.property
    @jsii.member(jsii_name="attrBindInstanceType")
    def attr_bind_instance_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: BindInstanceType: The cloud resource instance type to be bound.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBindInstanceType"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="anycastId")
    def anycast_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: anycastId: Anycast EIP instance ID.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "anycastId"))

    @anycast_id.setter
    def anycast_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23fad66ca5f22ab5e4ff84632387162d33cf639023079813ebd62de8be08ee3b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "anycastId", value)

    @builtins.property
    @jsii.member(jsii_name="bindInstanceId")
    def bind_instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bindInstanceId: The ID of the cloud resource instance to be bound.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "bindInstanceId"))

    @bind_instance_id.setter
    def bind_instance_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e2decd09dd25f2bfb40d8066746caa25cb8441a481d2b0064ee24c774182d49)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bindInstanceId", value)

    @builtins.property
    @jsii.member(jsii_name="bindInstanceRegionId")
    def bind_instance_region_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bindInstanceRegionId: The region ID of the cloud resource instance to be bound.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "bindInstanceRegionId"))

    @bind_instance_region_id.setter
    def bind_instance_region_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c6e2dc4e0c59398b5f3192ac32110221e7c7378bdfbd646a01c1f88f85342eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bindInstanceRegionId", value)

    @builtins.property
    @jsii.member(jsii_name="bindInstanceType")
    def bind_instance_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bindInstanceType: The cloud resource instance type to be bound. Valid value: SlbInstance, SLB instance of private network type.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "bindInstanceType"))

    @bind_instance_type.setter
    def bind_instance_type(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b8c603a96a753f9597f21173359cb0828c2bba4928e2dc5824076fca8a1bbae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bindInstanceType", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4bebe51f73a3863688cd6318104e3204449b0b0cc1c862a143758e9382f1bc3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosAnycastEIPAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "anycast_id": "anycastId",
        "bind_instance_id": "bindInstanceId",
        "bind_instance_region_id": "bindInstanceRegionId",
        "bind_instance_type": "bindInstanceType",
    },
)
class RosAnycastEIPAssociationProps:
    def __init__(
        self,
        *,
        anycast_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        bind_instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        bind_instance_region_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        bind_instance_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``RosAnycastEIPAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-anycasteipassociation

        :param anycast_id: 
        :param bind_instance_id: 
        :param bind_instance_region_id: 
        :param bind_instance_type: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__052b060713c24b645d460ce8c1aa984556946e89bf1e377db26237fcd46ceeb5)
            check_type(argname="argument anycast_id", value=anycast_id, expected_type=type_hints["anycast_id"])
            check_type(argname="argument bind_instance_id", value=bind_instance_id, expected_type=type_hints["bind_instance_id"])
            check_type(argname="argument bind_instance_region_id", value=bind_instance_region_id, expected_type=type_hints["bind_instance_region_id"])
            check_type(argname="argument bind_instance_type", value=bind_instance_type, expected_type=type_hints["bind_instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "anycast_id": anycast_id,
            "bind_instance_id": bind_instance_id,
            "bind_instance_region_id": bind_instance_region_id,
            "bind_instance_type": bind_instance_type,
        }

    @builtins.property
    def anycast_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: anycastId: Anycast EIP instance ID.
        '''
        result = self._values.get("anycast_id")
        assert result is not None, "Required property 'anycast_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def bind_instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bindInstanceId: The ID of the cloud resource instance to be bound.
        '''
        result = self._values.get("bind_instance_id")
        assert result is not None, "Required property 'bind_instance_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def bind_instance_region_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bindInstanceRegionId: The region ID of the cloud resource instance to be bound.
        '''
        result = self._values.get("bind_instance_region_id")
        assert result is not None, "Required property 'bind_instance_region_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def bind_instance_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bindInstanceType: The cloud resource instance type to be bound. Valid value: SlbInstance, SLB instance of private network type.
        '''
        result = self._values.get("bind_instance_type")
        assert result is not None, "Required property 'bind_instance_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosAnycastEIPAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosAnycastEIPProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "description": "description",
        "instance_charge_type": "instanceChargeType",
        "internet_charge_type": "internetChargeType",
        "name": "name",
        "service_location": "serviceLocation",
    },
)
class RosAnycastEIPProps:
    def __init__(
        self,
        *,
        bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        service_location: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosAnycastEIP``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-anycasteip

        :param bandwidth: 
        :param description: 
        :param instance_charge_type: 
        :param internet_charge_type: 
        :param name: 
        :param service_location: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d145b65a6aa8ffb04d0d42eaca064e5368cae48dcf7cededba70a0cd407004f)
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument service_location", value=service_location, expected_type=type_hints["service_location"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bandwidth is not None:
            self._values["bandwidth"] = bandwidth
        if description is not None:
            self._values["description"] = description
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if name is not None:
            self._values["name"] = name
        if service_location is not None:
            self._values["service_location"] = service_location

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: bandwidth: Anycast EIP instance bandwidth
        '''
        result = self._values.get("bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Anycast EIP instance description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: Anycast EIP instance charge type
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetChargeType: Anycast EIP instance access public network billing method
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: Anycast EIP instance name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def service_location(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: serviceLocation: Anycast EIP instance access area
        '''
        result = self._values.get("service_location")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosAnycastEIPProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosBgpGroup(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosBgpGroup",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::BgpGroup``, which is used to create a Border Gateway Protocol (BGP) (Multi-ISP) group for a specified virtual border router (VBR).

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``BgpGroup`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgpgroup
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosBgpGroupProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__380cd4543899872e591b3a38d6ca0731e26072bfb342bc4a8ee089a994b9ae06)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0d59124a0f9bb84c5ef622c01eb3c4fa2831d6962b0d7ee9b1dd7c5b24a2ad5)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrBgpGroupId")
    def attr_bgp_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: BgpGroupId: The ID of the BGP group.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBgpGroupId"))

    @builtins.property
    @jsii.member(jsii_name="attrName")
    def attr_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Name: The name of the BGP group.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrName"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb05aecad36ea57d3ebc62472f9e8d901691e09f4953b1e0517556a77b467b72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="peerAsn")
    def peer_asn(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: peerAsn: The AS number of the BGP peer.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "peerAsn"))

    @peer_asn.setter
    def peer_asn(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7a723d5d1f37c8f7fe92432f10c2d2011f039326cea14a9e908dd190e08a187)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "peerAsn", value)

    @builtins.property
    @jsii.member(jsii_name="routerId")
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerId: The ID of the VBR.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routerId"))

    @router_id.setter
    def router_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b661d51401c65a91649ec815e57f614caa932770df7cdf9f9fe7e0d85db8f7a9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routerId", value)

    @builtins.property
    @jsii.member(jsii_name="authKey")
    def auth_key(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: authKey: The authentication key of the BGP group.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "authKey"))

    @auth_key.setter
    def auth_key(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__603aa06a93cd58416ca04016abce714070090a2b238c139205cde30ec4a75c41)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "authKey", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the BGP group. The description must be 2 to 256 characters in length.
        It must start with a letter but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b584b125d59da0908bb55009a836dca31d5984a3eb3cc4f666a1f24486274afc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="isFakeAsn")
    def is_fake_asn(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        isFakeAsn: A router that runs BGP typically belongs to only one AS. In some cases, for example,
        the AS needs to be migrated or is merged with another AS, a new AS number replaces
        the original one.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "isFakeAsn"))

    @is_fake_asn.setter
    def is_fake_asn(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cace10e9a26ba148d9d6adbbb7e28610ee0e9c06b7c3d6193e5108392f5f7ba0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "isFakeAsn", value)

    @builtins.property
    @jsii.member(jsii_name="localAsn")
    def local_asn(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: localAsn: The AS number on the Alibaba Cloud side.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "localAsn"))

    @local_asn.setter
    def local_asn(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__314d5152d02a2c0aa1fc0408aee7171f73868823ea92c74b2b77cf017b19198c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localAsn", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the BGP group. The name must be 2 to 128 characters in length and can
        contain digits, periods (.), underscores (_), and hyphens (-). The name must start
        with a letter but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8bd6d85fc3365cb281b9566eaecf34522d46042d6b1c7e8069b3d628ca6028d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosBgpGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "peer_asn": "peerAsn",
        "router_id": "routerId",
        "auth_key": "authKey",
        "description": "description",
        "is_fake_asn": "isFakeAsn",
        "local_asn": "localAsn",
        "name": "name",
    },
)
class RosBgpGroupProps:
    def __init__(
        self,
        *,
        peer_asn: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auth_key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        is_fake_asn: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosBgpGroup``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgpgroup

        :param peer_asn: 
        :param router_id: 
        :param auth_key: 
        :param description: 
        :param is_fake_asn: 
        :param local_asn: 
        :param name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be49551528d9ed589f6d1bfe8070a93effd3d4fb82e31b9c2d47aceec46b49fa)
            check_type(argname="argument peer_asn", value=peer_asn, expected_type=type_hints["peer_asn"])
            check_type(argname="argument router_id", value=router_id, expected_type=type_hints["router_id"])
            check_type(argname="argument auth_key", value=auth_key, expected_type=type_hints["auth_key"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument is_fake_asn", value=is_fake_asn, expected_type=type_hints["is_fake_asn"])
            check_type(argname="argument local_asn", value=local_asn, expected_type=type_hints["local_asn"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "peer_asn": peer_asn,
            "router_id": router_id,
        }
        if auth_key is not None:
            self._values["auth_key"] = auth_key
        if description is not None:
            self._values["description"] = description
        if is_fake_asn is not None:
            self._values["is_fake_asn"] = is_fake_asn
        if local_asn is not None:
            self._values["local_asn"] = local_asn
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def peer_asn(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: peerAsn: The AS number of the BGP peer.
        '''
        result = self._values.get("peer_asn")
        assert result is not None, "Required property 'peer_asn' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerId: The ID of the VBR.
        '''
        result = self._values.get("router_id")
        assert result is not None, "Required property 'router_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auth_key(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: authKey: The authentication key of the BGP group.
        '''
        result = self._values.get("auth_key")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the BGP group. The description must be 2 to 256 characters in length.
        It must start with a letter but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def is_fake_asn(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        isFakeAsn: A router that runs BGP typically belongs to only one AS. In some cases, for example,
        the AS needs to be migrated or is merged with another AS, a new AS number replaces
        the original one.
        '''
        result = self._values.get("is_fake_asn")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def local_asn(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: localAsn: The AS number on the Alibaba Cloud side.
        '''
        result = self._values.get("local_asn")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the BGP group. The name must be 2 to 128 characters in length and can
        contain digits, periods (.), underscores (_), and hyphens (-). The name must start
        with a letter but cannot start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosBgpGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosBgpNetwork(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosBgpNetwork",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::BgpNetwork``, which is used to advertise a Border Gateway Protocol (BGP) network.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``BgpNetwork`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgpnetwork
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosBgpNetworkProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49ea13a336bd014d68f8f4404e98989aea1038d71a05e682eab50fb35df02ca3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b55793fdab40a973318c7ee6523b96e377d2744558ddc4ea7d05fafb565ec47c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDstCidrBlock")
    def attr_dst_cidr_block(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute:

        DstCidrBlock: The CIDR block of the virtual private cloud (VPC) or vSwitch that you want to connect
        to a data center.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDstCidrBlock"))

    @builtins.property
    @jsii.member(jsii_name="attrRouterId")
    def attr_router_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouterId: The ID of the vRouter associated with the router interface.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouterId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="dstCidrBlock")
    def dst_cidr_block(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        dstCidrBlock: The CIDR block of the virtual private cloud (VPC) or vSwitch that you want to connect
        to a data center.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "dstCidrBlock"))

    @dst_cidr_block.setter
    def dst_cidr_block(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cfba966a38e0840c8aaad53021c5c9721b5b93dd20c2f269d8d005ae9cab134)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dstCidrBlock", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48302144f383329b68a3c9c36d4c306ef1b514641ee959366b77c7af584c8d3a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="routerId")
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerId: The ID of the vRouter associated with the router interface.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routerId"))

    @router_id.setter
    def router_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c953470e07307c1eae897808180cc1820d489282ed6f3c6b267b4f9d2d7b817b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routerId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosBgpNetworkProps",
    jsii_struct_bases=[],
    name_mapping={"dst_cidr_block": "dstCidrBlock", "router_id": "routerId"},
)
class RosBgpNetworkProps:
    def __init__(
        self,
        *,
        dst_cidr_block: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``RosBgpNetwork``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgpnetwork

        :param dst_cidr_block: 
        :param router_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b66f4ed59b4fec1c6f8286937a6d825d1b8c0ad5043db87bd49afb779ab7ed61)
            check_type(argname="argument dst_cidr_block", value=dst_cidr_block, expected_type=type_hints["dst_cidr_block"])
            check_type(argname="argument router_id", value=router_id, expected_type=type_hints["router_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dst_cidr_block": dst_cidr_block,
            "router_id": router_id,
        }

    @builtins.property
    def dst_cidr_block(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        dstCidrBlock: The CIDR block of the virtual private cloud (VPC) or vSwitch that you want to connect
        to a data center.
        '''
        result = self._values.get("dst_cidr_block")
        assert result is not None, "Required property 'dst_cidr_block' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerId: The ID of the vRouter associated with the router interface.
        '''
        result = self._values.get("router_id")
        assert result is not None, "Required property 'router_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosBgpNetworkProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosBgpPeer(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosBgpPeer",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::BgpPeer``, which is used to add a Border Gateway Protocol (BGP) peer to a specific BGP group.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``BgpPeer`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgppeer
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosBgpPeerProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__349abe559b0b13bae8e4a05a2a1606dfe5d90c546e4d8d69310172e48386e62d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a05b0ac91e5bba33c2723483286bf45ebe5f20d1f55f9416fc99fcfd862e432)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrBgpPeerId")
    def attr_bgp_peer_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: BgpPeerId: The ID of the BGP peer.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBgpPeerId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="bgpGroupId")
    def bgp_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bgpGroupId: The ID of the BGP group.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "bgpGroupId"))

    @bgp_group_id.setter
    def bgp_group_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__babecfc3769d3adff531311b62b85922a5a5cf46d44efdcbb18712f1b3823422)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bgpGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__965a928397e4f307d8f97f93d280dd50394a45a7d1cb2ab8ccb70bf1ce61b291)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="enableBfd")
    def enable_bfd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableBfd: Specifies whether to enable the Bidirectional Forwarding Detection (BFD) feature.
        Valid values:
        true: enables BFD.
        false: disables BFD.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enableBfd"))

    @enable_bfd.setter
    def enable_bfd(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a062e146734f9e267a176a5261903fa665d533301a9bd600e6190a90a9806ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableBfd", value)

    @builtins.property
    @jsii.member(jsii_name="peerIpAddress")
    def peer_ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: peerIpAddress: The IP address of the BGP peer.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "peerIpAddress"))

    @peer_ip_address.setter
    def peer_ip_address(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94aaf9b962c297edb5828f074e2401c4cf11471d735c0f6b7c7cf3ca0de5a7ba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "peerIpAddress", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosBgpPeerProps",
    jsii_struct_bases=[],
    name_mapping={
        "bgp_group_id": "bgpGroupId",
        "enable_bfd": "enableBfd",
        "peer_ip_address": "peerIpAddress",
    },
)
class RosBgpPeerProps:
    def __init__(
        self,
        *,
        bgp_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        enable_bfd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        peer_ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosBgpPeer``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-bgppeer

        :param bgp_group_id: 
        :param enable_bfd: 
        :param peer_ip_address: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a64c8cb037f8481809bfd687722bee052c0f7ffa4e9fd8eb27e74df4face98db)
            check_type(argname="argument bgp_group_id", value=bgp_group_id, expected_type=type_hints["bgp_group_id"])
            check_type(argname="argument enable_bfd", value=enable_bfd, expected_type=type_hints["enable_bfd"])
            check_type(argname="argument peer_ip_address", value=peer_ip_address, expected_type=type_hints["peer_ip_address"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bgp_group_id": bgp_group_id,
        }
        if enable_bfd is not None:
            self._values["enable_bfd"] = enable_bfd
        if peer_ip_address is not None:
            self._values["peer_ip_address"] = peer_ip_address

    @builtins.property
    def bgp_group_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bgpGroupId: The ID of the BGP group.
        '''
        result = self._values.get("bgp_group_id")
        assert result is not None, "Required property 'bgp_group_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def enable_bfd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableBfd: Specifies whether to enable the Bidirectional Forwarding Detection (BFD) feature.
        Valid values:
        true: enables BFD.
        false: disables BFD.
        '''
        result = self._values.get("enable_bfd")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def peer_ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: peerIpAddress: The IP address of the BGP peer.
        '''
        result = self._values.get("peer_ip_address")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosBgpPeerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosCommonBandwidthPackage(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosCommonBandwidthPackage",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::CommonBandwidthPackage``, which is used to create an elastic IP address (EIP) bandwidth plan.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``CommonBandwidthPackage`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-commonbandwidthpackage
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosCommonBandwidthPackageProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d5a5009fbd66a282f7de95018bf086215f6219cf82c024c6a50d89bbec07ffb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88f42dd15c89843c35b17c86cc39c3708b93194b0099f0ef45bf959ad4c621b8)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrBandwidthPackageId")
    def attr_bandwidth_package_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: BandwidthPackageId: The ID of the Internet Shared Bandwidth instance.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrBandwidthPackageId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="bandwidth")
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bandwidth: The peak bandwidth of the Internet Shared Bandwidth instance. Unit: Mbit/s.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "bandwidth"))

    @bandwidth.setter
    def bandwidth(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e8a094f3d0ca62081b59c3d3921d62eea1a5b2700fe58f0fe3390b12bab8ae6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d07340c3f670d7b178b72fadfd9a2d2d67a558ff20c677ae0d99d535c27178ca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the Internet Shared Bandwidth instance.
        The description must be 2 to 256 characters in length. It must start with a letter,
        and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89bf2ea1bacd748b6ed7069b1ceb6bbf7e2ea0957f65d4c1f3643933fd8adfc9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetChargeType: The billing model of the Internet Shared Bandwidth instance. Allowed values:
        PayByBandwidth (default): Billed by bandwidth.
        PayBy95: Charged at Enhanced 95.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetChargeType"))

    @internet_charge_type.setter
    def internet_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__891e7946ab611fea2811f0378882e1c831b2847266ec3e1d2b4ab6ca921f1454)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="isp")
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: isp: Line type of EIP, value: BGP (multi-line).
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "isp"))

    @isp.setter
    def isp(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e99d7ba1a90a73635b42da752a033c85366cd79dd209bd0abadfed98e3c65287)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "isp", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the Internet Shared Bandwidth instance.
        The name must be 2 to 128 characters in length and can contain letters, numbers, periods
        (.), underscores (_), and hyphens (-). The name must start with a letter, and cannot
        start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e4ac322f53cf6c4387cc0808551ce4bf5aa63cd23917cb7ef6f9a2925e5e9c0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="ratio")
    def ratio(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        ratio: The minimum consumption ratio of the Internet Shared Bandwidth instance. Default to 100.
        Note This parameter is only supported on the China site.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ratio"))

    @ratio.setter
    def ratio(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5ce7baac34a185c17522bd27bfeb5f0ed664c3e2b838c71f92b321057ee0db9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ratio", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae80a41792dfb86f62b13443f7c8b279f8a4c65d3af3ca3d2901294cd6ab33d8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(
        self,
    ) -> typing.Optional[typing.List["RosCommonBandwidthPackage.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosCommonBandwidthPackage.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosCommonBandwidthPackage.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c131f221060b9dd1383d688942cc3d33818c27ba091a977f07c5f01f8b1402b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @builtins.property
    @jsii.member(jsii_name="zone")
    def zone(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: zone: Zone Id.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "zone"))

    @zone.setter
    def zone(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec690fc49ffb43a413e8787427c50c6e0ac561e079d505cf53042da2d4a3c553)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "zone", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosCommonBandwidthPackage.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__208c0b114862a6fbaf3cbe41a9de81e50d3cb55c85c847c376aa9d2831eb9a30)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosCommonBandwidthPackageIp(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosCommonBandwidthPackageIp",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::CommonBandwidthPackageIp``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``CommonBandwidthPackageIp`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-commonbandwidthpackageip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosCommonBandwidthPackageIpProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62b2503b13bb8def56e6b985d8f4b565aaac1c26f9a5d3ca3ffd0e8087426cc6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b90471c205846e7428f8dddac0aaff419352e30ead706b4ada486f6b9f413bfd)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrAllocationIds")
    def attr_allocation_ids(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: AllocationIds: All eip allocation ids of common bandwidth package.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAllocationIds"))

    @builtins.property
    @jsii.member(jsii_name="attrIpAddresses")
    def attr_ip_addresses(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: IpAddresses: All eip addresses of common bandwidth package.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpAddresses"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="bandwidthPackageId")
    def bandwidth_package_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bandwidthPackageId: The ID of the Internet Shared Bandwidth instance.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "bandwidthPackageId"))

    @bandwidth_package_id.setter
    def bandwidth_package_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__668409e0f7892f8f1eaf08709bf0bca0f29ca4772c85a343678ca6e652bd444c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bandwidthPackageId", value)

    @builtins.property
    @jsii.member(jsii_name="eips")
    def eips(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosCommonBandwidthPackageIp.EipsProperty"]]]:
        '''
        :Property: eips: List of eip associated with the Internet Shared Bandwidth instance.
        '''
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosCommonBandwidthPackageIp.EipsProperty"]]], jsii.get(self, "eips"))

    @eips.setter
    def eips(
        self,
        value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosCommonBandwidthPackageIp.EipsProperty"]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__476e03c4b42c25fbf0441523b830c0cdb999bd0b8c34ff8f1aed53dd32698d92)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "eips", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f002f268ec3810219479edf0dfa29b4a1e8a3873e1f17fb5e8f888c759a11ef8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosCommonBandwidthPackageIp.EipsProperty",
        jsii_struct_bases=[],
        name_mapping={"allocation_id": "allocationId", "bandwidth": "bandwidth"},
    )
    class EipsProperty:
        def __init__(
            self,
            *,
            allocation_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param allocation_id: 
            :param bandwidth: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__82f33c23d43e8d81df1eec3a55e3fcc6dff5be0a526a46233f9671539b1e4e3d)
                check_type(argname="argument allocation_id", value=allocation_id, expected_type=type_hints["allocation_id"])
                check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "allocation_id": allocation_id,
            }
            if bandwidth is not None:
                self._values["bandwidth"] = bandwidth

        @builtins.property
        def allocation_id(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: allocationId: The ID of the EIP instance.
            '''
            result = self._values.get("allocation_id")
            assert result is not None, "Required property 'allocation_id' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def bandwidth(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            bandwidth: The maximum allocatable bandwidth value in Mbps within the shared bandwidth.
            0 which means no limit.
            Default to no limit.
            '''
            result = self._values.get("bandwidth")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EipsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosCommonBandwidthPackageIpProps",
    jsii_struct_bases=[],
    name_mapping={"bandwidth_package_id": "bandwidthPackageId", "eips": "eips"},
)
class RosCommonBandwidthPackageIpProps:
    def __init__(
        self,
        *,
        bandwidth_package_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        eips: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosCommonBandwidthPackageIp.EipsProperty, typing.Dict[builtins.str, typing.Any]]]]],
    ) -> None:
        '''Properties for defining a ``RosCommonBandwidthPackageIp``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-commonbandwidthpackageip

        :param bandwidth_package_id: 
        :param eips: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc096a1feb50a3e420f35d13df6f394aee6571eb6bbe561425065981cfdd9a2b)
            check_type(argname="argument bandwidth_package_id", value=bandwidth_package_id, expected_type=type_hints["bandwidth_package_id"])
            check_type(argname="argument eips", value=eips, expected_type=type_hints["eips"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bandwidth_package_id": bandwidth_package_id,
            "eips": eips,
        }

    @builtins.property
    def bandwidth_package_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bandwidthPackageId: The ID of the Internet Shared Bandwidth instance.
        '''
        result = self._values.get("bandwidth_package_id")
        assert result is not None, "Required property 'bandwidth_package_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def eips(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosCommonBandwidthPackageIp.EipsProperty]]]:
        '''
        :Property: eips: List of eip associated with the Internet Shared Bandwidth instance.
        '''
        result = self._values.get("eips")
        assert result is not None, "Required property 'eips' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosCommonBandwidthPackageIp.EipsProperty]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosCommonBandwidthPackageIpProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosCommonBandwidthPackageProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "description": "description",
        "internet_charge_type": "internetChargeType",
        "isp": "isp",
        "name": "name",
        "ratio": "ratio",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
        "zone": "zone",
    },
)
class RosCommonBandwidthPackageProps:
    def __init__(
        self,
        *,
        bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ratio: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosCommonBandwidthPackage.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        zone: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosCommonBandwidthPackage``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-commonbandwidthpackage

        :param bandwidth: 
        :param description: 
        :param internet_charge_type: 
        :param isp: 
        :param name: 
        :param ratio: 
        :param resource_group_id: 
        :param tags: 
        :param zone: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__275aea8265a76d6dfd258393be48861cd9902f3f483455a3ddfea5289a1fe9db)
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument isp", value=isp, expected_type=type_hints["isp"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument ratio", value=ratio, expected_type=type_hints["ratio"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument zone", value=zone, expected_type=type_hints["zone"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bandwidth": bandwidth,
        }
        if description is not None:
            self._values["description"] = description
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if isp is not None:
            self._values["isp"] = isp
        if name is not None:
            self._values["name"] = name
        if ratio is not None:
            self._values["ratio"] = ratio
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags
        if zone is not None:
            self._values["zone"] = zone

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: bandwidth: The peak bandwidth of the Internet Shared Bandwidth instance. Unit: Mbit/s.
        '''
        result = self._values.get("bandwidth")
        assert result is not None, "Required property 'bandwidth' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the Internet Shared Bandwidth instance.
        The description must be 2 to 256 characters in length. It must start with a letter,
        and cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetChargeType: The billing model of the Internet Shared Bandwidth instance. Allowed values:
        PayByBandwidth (default): Billed by bandwidth.
        PayBy95: Charged at Enhanced 95.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: isp: Line type of EIP, value: BGP (multi-line).
        '''
        result = self._values.get("isp")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the Internet Shared Bandwidth instance.
        The name must be 2 to 128 characters in length and can contain letters, numbers, periods
        (.), underscores (_), and hyphens (-). The name must start with a letter, and cannot
        start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ratio(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        ratio: The minimum consumption ratio of the Internet Shared Bandwidth instance. Default to 100.
        Note This parameter is only supported on the China site.
        '''
        result = self._values.get("ratio")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[RosCommonBandwidthPackage.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosCommonBandwidthPackage.TagsProperty]], result)

    @builtins.property
    def zone(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: zone: Zone Id.
        '''
        result = self._values.get("zone")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosCommonBandwidthPackageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosCustomerGateway(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosCustomerGateway",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::CustomerGateway``, which is used to create a customer gateway.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``CustomerGateway`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-customergateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosCustomerGatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8268b9e7356d8c9408540220bb8bedddd2378d18c20fb65d36a05079624d7302)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b668ddaab5a86a9cc3221c6bd00c00f2bd8037c1fecedc7e4e50b7be32efb1bb)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrCustomerGatewayId")
    def attr_customer_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: CustomerGatewayId: The ID of the user gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrCustomerGatewayId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54f88e8cd7308e622e24ec83d2491e4879017ef1485675f279995d27cfa13fbf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="ipAddress")
    def ip_address(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: ipAddress: The IP address of the user gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "ipAddress"))

    @ip_address.setter
    def ip_address(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__510e805cbf7e812a851a7d9974bb50595b05c4bef4537e211c4646451bee69d4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipAddress", value)

    @builtins.property
    @jsii.member(jsii_name="asn")
    def asn(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: asn: The autonomous system number of the local data center gateway device.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "asn"))

    @asn.setter
    def asn(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c842fb5eabb72d167b3b871bd19486be89e2f6b6a5d4c13bdb6be52af3ef005e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "asn", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: Description of the user gateway.
        The length is 2-256 characters and must start with a letter or Chinese, but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c698380adbebc16dd65d7392479f693468346e82a95fde111c743fa484bf0fdb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the user gateway.
        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82db61b4d610d1371260ac51bc479a0edc81c4cf87209b2bc8c1178ca63607ba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosCustomerGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "ip_address": "ipAddress",
        "asn": "asn",
        "description": "description",
        "name": "name",
    },
)
class RosCustomerGatewayProps:
    def __init__(
        self,
        *,
        ip_address: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosCustomerGateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-customergateway

        :param ip_address: 
        :param asn: 
        :param description: 
        :param name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8fde3d2076cd33ee116bb069fdbca464e8ff4008db728d032f9d64dddc0e54d)
            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
            check_type(argname="argument asn", value=asn, expected_type=type_hints["asn"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ip_address": ip_address,
        }
        if asn is not None:
            self._values["asn"] = asn
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def ip_address(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: ipAddress: The IP address of the user gateway.
        '''
        result = self._values.get("ip_address")
        assert result is not None, "Required property 'ip_address' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def asn(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: asn: The autonomous system number of the local data center gateway device.
        '''
        result = self._values.get("asn")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: Description of the user gateway.
        The length is 2-256 characters and must start with a letter or Chinese, but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the user gateway.
        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosCustomerGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosDhcpOptionsSet(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosDhcpOptionsSet",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::DhcpOptionsSet``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``DhcpOptionsSet`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-dhcpoptionsset
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosDhcpOptionsSetProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98cb1ba8c8d84ce745184102c810adf30848432929fc557cd7cffc60ed0ae2ff)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eca59fda4381b8c3b4ee507de3551dea449a56ddbd44ddda686402eae04c6b5b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDhcpOptionsSetId")
    def attr_dhcp_options_set_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: DhcpOptionsSetId: The ID of the DHCP options set that is created.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDhcpOptionsSetId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b6d3cf07b766d3019d41c25dbce73031cb30c88cc46d24573f4aa2754c0fc78)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="dhcpOptionsSetDescription")
    def dhcp_options_set_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dhcpOptionsSetDescription: The description of the DHCP options set.
        The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "dhcpOptionsSetDescription"))

    @dhcp_options_set_description.setter
    def dhcp_options_set_description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10b5ecab82c5142fd3b2fbd225820d15280fd159142af1b5540efe9bac643050)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dhcpOptionsSetDescription", value)

    @builtins.property
    @jsii.member(jsii_name="dhcpOptionsSetName")
    def dhcp_options_set_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dhcpOptionsSetName: The name of the DHCP options set.
        The name must be 2 to 128 characters in length and can contain letters, Chinese characters, digits, underscores (_), and hyphens (-). It must start with a letter or a Chinese character.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "dhcpOptionsSetName"))

    @dhcp_options_set_name.setter
    def dhcp_options_set_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0b403140a3daa60a16b9a3073b902b063f5e823d31c10e42cb85eae0682be93)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dhcpOptionsSetName", value)

    @builtins.property
    @jsii.member(jsii_name="domainName")
    def domain_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        domainName: The root domain, for example, example.com.
        After a DHCP options set is associated with a Virtual Private Cloud (VPC) network, the root domain in the DHCP options set is automatically synchronized to the ECS instances in the VPC network.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "domainName"))

    @domain_name.setter
    def domain_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52104aec5c1e59e003dfa1ab9cc3bc29ad0eba0917e76e8261ccc555f1b51424)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "domainName", value)

    @builtins.property
    @jsii.member(jsii_name="domainNameServers")
    def domain_name_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: domainNameServers: The DNS server IP addresses. Note Before you specify any DNS server IP address, all ECS instances in the associated VPC network use the IP addresses of the Alibaba Cloud DNS servers, which are 100.100.2.136 and 100.100.2.138.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "domainNameServers"))

    @domain_name_servers.setter
    def domain_name_servers(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c640c5d0a8edc9290e9f544e81fbfc8f6849e9a1fbdec0ef547ca65c02c399e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "domainNameServers", value)


class RosDhcpOptionsSetAttachment(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosDhcpOptionsSetAttachment",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::DhcpOptionsSetAttachment``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``DhcpOptionsSetAttachment`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-dhcpoptionssetattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosDhcpOptionsSetAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8837389209c4c49521ce072349a63e1c66946f0718a56f5ea14c38881d2cedfe)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71550331e8827380c1b2c07157ab70549a996603a0a6b2e3a781c6d8c220f1a7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDhcpOptionsSetId")
    def attr_dhcp_options_set_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: DhcpOptionsSetId: The ID of the DHCP options set.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDhcpOptionsSetId"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpcId: The ID of the VPC network.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpcId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="dhcpOptionsSetId")
    def dhcp_options_set_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: dhcpOptionsSetId: The ID of the DHCP options set.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "dhcpOptionsSetId"))

    @dhcp_options_set_id.setter
    def dhcp_options_set_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__648a31797ec43153511c70af07363184ad989a4cadf48758052a704079a89645)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dhcpOptionsSetId", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b794c962c649430be6dd8dff309578faa1b1a90ac229c860218a45d750ad76a2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the VPC network that is to be associated with the DHCP options set.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b81267450d1139aa6a24a605e35988b71cd538f96799a953dfe94e559bda164b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosDhcpOptionsSetAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={"dhcp_options_set_id": "dhcpOptionsSetId", "vpc_id": "vpcId"},
)
class RosDhcpOptionsSetAttachmentProps:
    def __init__(
        self,
        *,
        dhcp_options_set_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``RosDhcpOptionsSetAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-dhcpoptionssetattachment

        :param dhcp_options_set_id: 
        :param vpc_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c48841f40457da5d2918a63bbcaa5539be0ab63bf0c1b4fba8791e2306ab766)
            check_type(argname="argument dhcp_options_set_id", value=dhcp_options_set_id, expected_type=type_hints["dhcp_options_set_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dhcp_options_set_id": dhcp_options_set_id,
            "vpc_id": vpc_id,
        }

    @builtins.property
    def dhcp_options_set_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: dhcpOptionsSetId: The ID of the DHCP options set.
        '''
        result = self._values.get("dhcp_options_set_id")
        assert result is not None, "Required property 'dhcp_options_set_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the VPC network that is to be associated with the DHCP options set.
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosDhcpOptionsSetAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosDhcpOptionsSetProps",
    jsii_struct_bases=[],
    name_mapping={
        "dhcp_options_set_description": "dhcpOptionsSetDescription",
        "dhcp_options_set_name": "dhcpOptionsSetName",
        "domain_name": "domainName",
        "domain_name_servers": "domainNameServers",
    },
)
class RosDhcpOptionsSetProps:
    def __init__(
        self,
        *,
        dhcp_options_set_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        dhcp_options_set_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        domain_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        domain_name_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosDhcpOptionsSet``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-dhcpoptionsset

        :param dhcp_options_set_description: 
        :param dhcp_options_set_name: 
        :param domain_name: 
        :param domain_name_servers: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ca0e0d617f4cd5c237b1487d927d8fc536201617f675172d903fb143a9a0859)
            check_type(argname="argument dhcp_options_set_description", value=dhcp_options_set_description, expected_type=type_hints["dhcp_options_set_description"])
            check_type(argname="argument dhcp_options_set_name", value=dhcp_options_set_name, expected_type=type_hints["dhcp_options_set_name"])
            check_type(argname="argument domain_name", value=domain_name, expected_type=type_hints["domain_name"])
            check_type(argname="argument domain_name_servers", value=domain_name_servers, expected_type=type_hints["domain_name_servers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dhcp_options_set_description is not None:
            self._values["dhcp_options_set_description"] = dhcp_options_set_description
        if dhcp_options_set_name is not None:
            self._values["dhcp_options_set_name"] = dhcp_options_set_name
        if domain_name is not None:
            self._values["domain_name"] = domain_name
        if domain_name_servers is not None:
            self._values["domain_name_servers"] = domain_name_servers

    @builtins.property
    def dhcp_options_set_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dhcpOptionsSetDescription: The description of the DHCP options set.
        The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("dhcp_options_set_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def dhcp_options_set_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        dhcpOptionsSetName: The name of the DHCP options set.
        The name must be 2 to 128 characters in length and can contain letters, Chinese characters, digits, underscores (_), and hyphens (-). It must start with a letter or a Chinese character.
        '''
        result = self._values.get("dhcp_options_set_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def domain_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        domainName: The root domain, for example, example.com.
        After a DHCP options set is associated with a Virtual Private Cloud (VPC) network, the root domain in the DHCP options set is automatically synchronized to the ECS instances in the VPC network.
        '''
        result = self._values.get("domain_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def domain_name_servers(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: domainNameServers: The DNS server IP addresses. Note Before you specify any DNS server IP address, all ECS instances in the associated VPC network use the IP addresses of the Alibaba Cloud DNS servers, which are 100.100.2.136 and 100.100.2.138.
        '''
        result = self._values.get("domain_name_servers")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosDhcpOptionsSetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosEIP(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosEIP",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::EIP``, which is used to apply for an elastic IP address (EIP).

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``EIP`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosEIPProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73554efd336df81fe30f360e9eb32ea89eaf9a33a08abcb211dbf31ef438cf55)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0916bcf6a253ac784088ebe48b9f83cf498d58325b77072be57fcf6414b485ae)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrAllocationId")
    def attr_allocation_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: AllocationId: ID that Aliyun assigns to represent the allocation of the address for use with VPC. Returned only for VPC elastic IP addresses.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAllocationId"))

    @builtins.property
    @jsii.member(jsii_name="attrEipAddress")
    def attr_eip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: EipAddress: IP address of created EIP.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipAddress"))

    @builtins.property
    @jsii.member(jsii_name="attrIsp")
    def attr_isp(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Isp: The line type.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIsp"))

    @builtins.property
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: OrderId: Order ID of prepaid EIP instance.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOrderId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba76fb724e06e1f9f2a33109c662605365fa0ecc3edee9fd1cea68af0857a91f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="autoPay")
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: autoPay: Automatic Payment. Default is true.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoPay"))

    @auto_pay.setter
    def auto_pay(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50611862e1658198486a1dab18b3e128c694c5b70f2be8596a91489a98902c2c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoPay", value)

    @builtins.property
    @jsii.member(jsii_name="bandwidth")
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: bandwidth: Bandwidth for the output network. Default is 5MB.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "bandwidth"))

    @bandwidth.setter
    def bandwidth(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e11a6893d039091ebe30ce1dee3de52a11fb05a8b9df8ce6760774289f9d1e2f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        deletionProtection: Whether to enable deletion protection.
        Default to False.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "deletionProtection"))

    @deletion_protection.setter
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ebdd9e233a01d1d331721298637c3308a0eb00737c4b91b855202da912af3d44)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionProtection", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Optional. The description of the EIP. The description must be 2 to 256 characters in length. It must start with a letter. It cannot start with http://  or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b8c4d77f32a8f762320762d0bb288712d8d5e678bc224f488640f7a805ed9ac)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: The resource charge type. Default value is Postpaid
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceChargeType"))

    @instance_charge_type.setter
    def instance_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef5925f854a29169bec9ab8780b74632217befb163fbee385a03aaea99eac2cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetChargeType: The network charge type. Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByBandwidth. PayByTraffic will charge by hour, PayByBandwidth will charge by day.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetChargeType"))

    @internet_charge_type.setter
    def internet_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f5235cbb48f82e07dd412f3e8abcbcfd0da4f31f758689e4f69ec1e2e2416d9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="isp")
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        isp: The line type. You can set this parameter only when you create a pay-as-you-go EIP. Valid values:
        BGP: BGP (Multi-ISP) lines. Up to 89 high-quality BGP lines are available worldwide. Direct connections with multiple Internet Service Providers (ISPs), including Telecom, Unicom, Mobile, Railcom, Netcom, CERNET, China Broadcast Network, Dr. Peng, and Founder, can be established in all regions in mainland China.
        BGP_PRO: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines optimize data transmission to China and improve connection quality for international services. Compared with traditional BGP (Multi-ISP) lines, BGP (Multi-ISP) Pro lines can be used to establish direct connections without using international ISP services. Therefore, BGP (Multi-ISP) Pro lines reduce network latency.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "isp"))

    @isp.setter
    def isp(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ceb5774530605ccb36ffb70d90b6826732bdd7b801c668e562f80513c239bec0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "isp", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: The name of the EIP. The name must be 2 to 128 characters in length. It must start with a letter. It can contain numbers, periods (.), underscores (_), and hyphens (-). It cannot start with http://  or https://
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff5b9e5a9f88e3975f2ba37c301b8fc459fd93b5de2ff0446493695639ac6132)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="netmode")
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: netmode: The network type. Valid value: public (public network).
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "netmode"))

    @netmode.setter
    def netmode(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a612682f27886afe1529ddc14626586b1f1e5c227a0e3068d27251df23db4141)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "netmode", value)

    @builtins.property
    @jsii.member(jsii_name="period")
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        period: Prepaid time period. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36.
        While choose pay by year, it could be from 1 to 3.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "period"))

    @period.setter
    def period(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__612be7c7ebf30a6af8aef71caa8537ce3435898c8998b156dfef9ec4866c95ec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "period", value)

    @builtins.property
    @jsii.member(jsii_name="pricingCycle")
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pricingCycle: Price cycle of the resource. This property has no default value. If ChargeType is specified as Postpaid, this value will be ignore.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "pricingCycle"))

    @pricing_cycle.setter
    def pricing_cycle(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__caf6d48739ffb5e0d66f9c6fb5681d982e35decccdc38f3cfde60c0321e5b89d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pricingCycle", value)

    @builtins.property
    @jsii.member(jsii_name="publicIpAddressPoolId")
    def public_ip_address_pool_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: publicIpAddressPoolId: The ID of the IP address pool. The EIP is allocated from the IP address pool.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "publicIpAddressPoolId"))

    @public_ip_address_pool_id.setter
    def public_ip_address_pool_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9df613e30b742e437a4d7ab955573c2fb52fb26a985e245efb76ff6757a24d8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "publicIpAddressPoolId", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: Resource group id.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcc73044c0199cc0af81c603bf671320dc2396b61bef0cb6e6150fefa2b04e6d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="securityProtectionTypes")
    def security_protection_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        securityProtectionTypes: The edition of Anti-DDoS.
        If you do not set this parameter, Anti-DDoS Origin Basic is used.
        If you set the value to AntiDDoS_Enhanced, Anti-DDoS Pro/Premium is used.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "securityProtectionTypes"))

    @security_protection_types.setter
    def security_protection_types(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8ad95f93bf288c1cd09889bcade82b02f03d3b9d431220aa0088c42ebf3e1e6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityProtectionTypes", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosEIP.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to eip. Max support 20 tags to add during create eip. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosEIP.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.Optional[typing.List["RosEIP.TagsProperty"]]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55768bb7ff7c0beeb068deb027ca497a08df3bba9f8d245d917612143fdd632f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @builtins.property
    @jsii.member(jsii_name="zone")
    def zone(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: zone: Availability zone of the elastic public network IP.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "zone"))

    @zone.setter
    def zone(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb2407c5aad15e4a42094e80a054c968ab3ee419658e334649b72c572aaa64cf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "zone", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosEIP.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__50105bff3f675e146417edf48a524a985a1345020c4cb45c143dd39a38d3ab28)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosEIPAssociation(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosEIPAssociation",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::EIPAssociation``, which is used to associate an elastic IP address (EIP) with a cloud service instance.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``EIPAssociation`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eipassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosEIPAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1be6a254c615f55980c7f48cb68c4f86318b3d3f5f8637d84eb4de20db6aa904)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a25c13e81df886185f9d66955c954335dcc25f8eb8e199d597ddfb9bb8356f4)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrAllocationId")
    def attr_allocation_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: AllocationId: ID that Aliyun assigns to represent the allocation of the address for use with VPC. Returned only for VPC elastic IP addresses.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAllocationId"))

    @builtins.property
    @jsii.member(jsii_name="attrEipAddress")
    def attr_eip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: EipAddress: IP address of created EIP.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipAddress"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="allocationId")
    def allocation_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: allocationId: EIP instance id to bind.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "allocationId"))

    @allocation_id.setter
    def allocation_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98d9722761b6c17bc7c7729b91960fac5a65f938166cd2326d6573a8e204ed32)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allocationId", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee8d3a8d9bc3b71101add1b9e760815c1c490a80af98627db25449a3880b67c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="instanceId")
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: instanceId: ECS/SLB/NAT/HaVip/ENI instance id to bid the EIP.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b40232268ea887183cc2ca61527d88a21162a7cfef2b33388888cbc435b12dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceId", value)

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        mode: The mode of association. Valid values:
        NAT(Default): NAT mode.
        BINDED: Cut-through mode.
        MULTI_BINDED: Multi-EIP to ENI mode.
        This is required only when the value of InstanceType is NetworkInterface.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "mode"))

    @mode.setter
    def mode(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23cc7a104446e33769d9896eafc3c82b40db4e3eaaf24c7afd10e3b95c678968)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value)

    @builtins.property
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        privateIpAddress: An IP address in the CIDR block of the VSwitch.
        If you leave the option empty, the system allocates a private IP address according to the VPC ID and VSwitch ID.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "privateIpAddress"))

    @private_ip_address.setter
    def private_ip_address(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__001630a7d890294ca8e0917c7eba716f0c325344075b60cd965d2285fcffd1b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "privateIpAddress", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosEIPAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocation_id": "allocationId",
        "instance_id": "instanceId",
        "mode": "mode",
        "private_ip_address": "privateIpAddress",
    },
)
class RosEIPAssociationProps:
    def __init__(
        self,
        *,
        allocation_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        private_ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosEIPAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eipassociation

        :param allocation_id: 
        :param instance_id: 
        :param mode: 
        :param private_ip_address: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e21ab0704007b4250e615b2437f387c77b965fbdb320efb6647fb34fe9d68588)
            check_type(argname="argument allocation_id", value=allocation_id, expected_type=type_hints["allocation_id"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "allocation_id": allocation_id,
            "instance_id": instance_id,
        }
        if mode is not None:
            self._values["mode"] = mode
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address

    @builtins.property
    def allocation_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: allocationId: EIP instance id to bind.
        '''
        result = self._values.get("allocation_id")
        assert result is not None, "Required property 'allocation_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: instanceId: ECS/SLB/NAT/HaVip/ENI instance id to bid the EIP.
        '''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        mode: The mode of association. Valid values:
        NAT(Default): NAT mode.
        BINDED: Cut-through mode.
        MULTI_BINDED: Multi-EIP to ENI mode.
        This is required only when the value of InstanceType is NetworkInterface.
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def private_ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        privateIpAddress: An IP address in the CIDR block of the VSwitch.
        If you leave the option empty, the system allocates a private IP address according to the VPC ID and VSwitch ID.
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosEIPAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosEIPPro(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosEIPPro",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::EIPPro``, which is used to create an elastic IP address (EIP).

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``EIPPro`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eippro
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosEIPProProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b480723483b4d73e163e9812314dfe333c979553af3e5dbb381c1eb4df606e2a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0949957fbf19683fc0e3363d14f9d69e3cef248c791a04e995909195faae9b3a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrAllocationId")
    def attr_allocation_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: AllocationId: ID that Aliyun assigns to represent the allocation of the address for use with VPC. Returned only for VPC elastic IP addresses.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrAllocationId"))

    @builtins.property
    @jsii.member(jsii_name="attrEipAddress")
    def attr_eip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: EipAddress: IP address of created EIP.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipAddress"))

    @builtins.property
    @jsii.member(jsii_name="attrIsp")
    def attr_isp(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ISP: The line type.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIsp"))

    @builtins.property
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: OrderId: Order ID of prepaid EIP instance.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOrderId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__624a11fc3c328f1f06e66a6e95565232087dfb9962184aab48f1e5c1c59cf06a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="autoPay")
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: autoPay: Automatic Payment. Default is true.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoPay"))

    @auto_pay.setter
    def auto_pay(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5662b906bf59b2ff905053d19f8f7f556c0e4e4cf3814c6c4ec5682d3a13e79c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoPay", value)

    @builtins.property
    @jsii.member(jsii_name="bandwidth")
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: bandwidth: Bandwidth for the output network. Default is 5MB.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "bandwidth"))

    @bandwidth.setter
    def bandwidth(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba272802c47e0ace034d04b90c4384fed6b11ccbdd00c0a1ce14d2dbc7b78c88)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        deletionProtection: Whether to enable deletion protection.
        Default to False.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "deletionProtection"))

    @deletion_protection.setter
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8362ac7698204404dbc5eaa1baae789176b5d289192feb556f4c8c905090b59a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionProtection", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Optional. The description of the EIP. The description must be 2 to 256 characters in length. It must start with a letter. It cannot start with http://  or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14efc38f7668594723a8e58b7ca210cd7aaba7a918dc8fcc731ac2cb02eacd3e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: The resource charge type. Default value is Postpaid
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceChargeType"))

    @instance_charge_type.setter
    def instance_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__744e37697cfb1df820d3d2a760fb6c53080d50b718495d984495df06a7fb8633)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="instanceId")
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceId: The ID of the requested EIP.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35d9a18603f554517ab26e6a7c32e55383c37c614428efc6b47883a36a2f9b64)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceId", value)

    @builtins.property
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetChargeType: The network charge type. Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByBandwidth. PayByTraffic will charge by hour, PayByBandwidth will charge by day.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetChargeType"))

    @internet_charge_type.setter
    def internet_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93c442ef8eed0f94f830e6b4fe26e68568cdf34148d9ca558d16ea3d1349a291)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="ipAddress")
    def ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipAddress: The IP address of the requested EIP.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ipAddress"))

    @ip_address.setter
    def ip_address(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad36afc7c779dbd7efd7cf27f40ed3e056194f37e56b7419a9cb4d203545d31c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipAddress", value)

    @builtins.property
    @jsii.member(jsii_name="isp")
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        isp: The line type. You can set this parameter only when you create a pay-as-you-go EIP. Valid values:
        BGP: BGP (Multi-ISP) lines. Up to 89 high-quality BGP lines are available worldwide. Direct connections with multiple Internet Service Providers (ISPs), including Telecom, Unicom, Mobile, Railcom, Netcom, CERNET, China Broadcast Network, Dr. Peng, and Founder, can be established in all regions in mainland China.
        BGP_PRO: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines optimize data transmission to China and improve connection quality for international services. Compared with traditional BGP (Multi-ISP) lines, BGP (Multi-ISP) Pro lines can be used to establish direct connections without using international ISP services. Therefore, BGP (Multi-ISP) Pro lines reduce network latency.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "isp"))

    @isp.setter
    def isp(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1744a049437a885c46b62af7b5010cfa86e09784cdc63982e3510f4f089dd133)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "isp", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: The name of the EIP. The name must be 2 to 128 characters in length. It must start with a letter. It can contain numbers, periods (.), underscores (_), and hyphens (-). It cannot start with http://  or https://
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b95694b1fc396cdf85ba761b1bb820ef6aa22139cafc542944e166af577339f7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="netmode")
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: netmode: The network type. Valid value: public (public network).
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "netmode"))

    @netmode.setter
    def netmode(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__852c774544c5d362aca9260f432635ae15abb60de428fd45375aeccf90b742eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "netmode", value)

    @builtins.property
    @jsii.member(jsii_name="period")
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        period: Prepaid time period. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36.
        While choose pay by year, it could be from 1 to 3.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "period"))

    @period.setter
    def period(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec25ef82a121d7b039c2614af8a906ecd92e0e081f8384af8018c55497a2edba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "period", value)

    @builtins.property
    @jsii.member(jsii_name="pricingCycle")
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pricingCycle: Price cycle of the resource. This property has no default value. If ChargeType is specified as Postpaid, this value will be ignore.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "pricingCycle"))

    @pricing_cycle.setter
    def pricing_cycle(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5dbc3fdb1809c25e7e0bf120e64bffb2e5505e823d9240a2fbfbedab585f56c6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pricingCycle", value)

    @builtins.property
    @jsii.member(jsii_name="publicIpAddressPoolId")
    def public_ip_address_pool_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: publicIpAddressPoolId: The ID of the IP address pool. The EIP is allocated from the IP address pool.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "publicIpAddressPoolId"))

    @public_ip_address_pool_id.setter
    def public_ip_address_pool_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cdf4c5a47d251407cc814ff5c485a7d23a8c33a6f92c5a79ec2970c4fa3421b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "publicIpAddressPoolId", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: Resource group id.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d508d2ebe015f82104b92ad4fa9d72f2b6af16c13de19c7b5077071fa53c6c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="securityProtectionTypes")
    def security_protection_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        securityProtectionTypes: The edition of Anti-DDoS.
        If you do not set this parameter, Anti-DDoS Origin Basic is used.
        If you set the value to AntiDDoS_Enhanced, Anti-DDoS Pro/Premium is used.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "securityProtectionTypes"))

    @security_protection_types.setter
    def security_protection_types(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b27234e65644caeb77d36bc9ccd25a392f3bccc189eb48a0ea4c0b7de7bce9a7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityProtectionTypes", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosEIPPro.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to eip. Max support 20 tags to add during create eip. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosEIPPro.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosEIPPro.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__178a4b2247bea18d002ec950129cff45b0af71bbd2caf075b1b3aca00a7fea33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosEIPPro.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__008c9a4e893f1708a936f6808d11f024f0f60c37e2dd3f5f87168b7aa4fbdbdc)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosEIPProProps",
    jsii_struct_bases=[],
    name_mapping={
        "auto_pay": "autoPay",
        "bandwidth": "bandwidth",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "instance_charge_type": "instanceChargeType",
        "instance_id": "instanceId",
        "internet_charge_type": "internetChargeType",
        "ip_address": "ipAddress",
        "isp": "isp",
        "name": "name",
        "netmode": "netmode",
        "period": "period",
        "pricing_cycle": "pricingCycle",
        "public_ip_address_pool_id": "publicIpAddressPoolId",
        "resource_group_id": "resourceGroupId",
        "security_protection_types": "securityProtectionTypes",
        "tags": "tags",
    },
)
class RosEIPProProps:
    def __init__(
        self,
        *,
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        public_ip_address_pool_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_protection_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosEIPPro.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosEIPPro``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eippro

        :param auto_pay: 
        :param bandwidth: 
        :param deletion_protection: 
        :param description: 
        :param instance_charge_type: 
        :param instance_id: 
        :param internet_charge_type: 
        :param ip_address: 
        :param isp: 
        :param name: 
        :param netmode: 
        :param period: 
        :param pricing_cycle: 
        :param public_ip_address_pool_id: 
        :param resource_group_id: 
        :param security_protection_types: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11c1a47fb3541189bdbef40dad102f398e6072dc8864b9d5330b6136762ac36f)
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
            check_type(argname="argument isp", value=isp, expected_type=type_hints["isp"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument netmode", value=netmode, expected_type=type_hints["netmode"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument pricing_cycle", value=pricing_cycle, expected_type=type_hints["pricing_cycle"])
            check_type(argname="argument public_ip_address_pool_id", value=public_ip_address_pool_id, expected_type=type_hints["public_ip_address_pool_id"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument security_protection_types", value=security_protection_types, expected_type=type_hints["security_protection_types"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if bandwidth is not None:
            self._values["bandwidth"] = bandwidth
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if ip_address is not None:
            self._values["ip_address"] = ip_address
        if isp is not None:
            self._values["isp"] = isp
        if name is not None:
            self._values["name"] = name
        if netmode is not None:
            self._values["netmode"] = netmode
        if period is not None:
            self._values["period"] = period
        if pricing_cycle is not None:
            self._values["pricing_cycle"] = pricing_cycle
        if public_ip_address_pool_id is not None:
            self._values["public_ip_address_pool_id"] = public_ip_address_pool_id
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_protection_types is not None:
            self._values["security_protection_types"] = security_protection_types
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: autoPay: Automatic Payment. Default is true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: bandwidth: Bandwidth for the output network. Default is 5MB.
        '''
        result = self._values.get("bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        deletionProtection: Whether to enable deletion protection.
        Default to False.
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Optional. The description of the EIP. The description must be 2 to 256 characters in length. It must start with a letter. It cannot start with http://  or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: The resource charge type. Default value is Postpaid
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceId: The ID of the requested EIP.
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetChargeType: The network charge type. Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByBandwidth. PayByTraffic will charge by hour, PayByBandwidth will charge by day.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipAddress: The IP address of the requested EIP.
        '''
        result = self._values.get("ip_address")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        isp: The line type. You can set this parameter only when you create a pay-as-you-go EIP. Valid values:
        BGP: BGP (Multi-ISP) lines. Up to 89 high-quality BGP lines are available worldwide. Direct connections with multiple Internet Service Providers (ISPs), including Telecom, Unicom, Mobile, Railcom, Netcom, CERNET, China Broadcast Network, Dr. Peng, and Founder, can be established in all regions in mainland China.
        BGP_PRO: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines optimize data transmission to China and improve connection quality for international services. Compared with traditional BGP (Multi-ISP) lines, BGP (Multi-ISP) Pro lines can be used to establish direct connections without using international ISP services. Therefore, BGP (Multi-ISP) Pro lines reduce network latency.
        '''
        result = self._values.get("isp")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: The name of the EIP. The name must be 2 to 128 characters in length. It must start with a letter. It can contain numbers, periods (.), underscores (_), and hyphens (-). It cannot start with http://  or https://
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: netmode: The network type. Valid value: public (public network).
        '''
        result = self._values.get("netmode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        period: Prepaid time period. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36.
        While choose pay by year, it could be from 1 to 3.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pricingCycle: Price cycle of the resource. This property has no default value. If ChargeType is specified as Postpaid, this value will be ignore.
        '''
        result = self._values.get("pricing_cycle")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def public_ip_address_pool_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: publicIpAddressPoolId: The ID of the IP address pool. The EIP is allocated from the IP address pool.
        '''
        result = self._values.get("public_ip_address_pool_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: Resource group id.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_protection_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        securityProtectionTypes: The edition of Anti-DDoS.
        If you do not set this parameter, Anti-DDoS Origin Basic is used.
        If you set the value to AntiDDoS_Enhanced, Anti-DDoS Pro/Premium is used.
        '''
        result = self._values.get("security_protection_types")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosEIPPro.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to eip. Max support 20 tags to add during create eip. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosEIPPro.TagsProperty]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosEIPProProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosEIPProps",
    jsii_struct_bases=[],
    name_mapping={
        "auto_pay": "autoPay",
        "bandwidth": "bandwidth",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "instance_charge_type": "instanceChargeType",
        "internet_charge_type": "internetChargeType",
        "isp": "isp",
        "name": "name",
        "netmode": "netmode",
        "period": "period",
        "pricing_cycle": "pricingCycle",
        "public_ip_address_pool_id": "publicIpAddressPoolId",
        "resource_group_id": "resourceGroupId",
        "security_protection_types": "securityProtectionTypes",
        "tags": "tags",
        "zone": "zone",
    },
)
class RosEIPProps:
    def __init__(
        self,
        *,
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        public_ip_address_pool_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_protection_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosEIP.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        zone: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosEIP``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eip

        :param auto_pay: 
        :param bandwidth: 
        :param deletion_protection: 
        :param description: 
        :param instance_charge_type: 
        :param internet_charge_type: 
        :param isp: 
        :param name: 
        :param netmode: 
        :param period: 
        :param pricing_cycle: 
        :param public_ip_address_pool_id: 
        :param resource_group_id: 
        :param security_protection_types: 
        :param tags: 
        :param zone: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffb8d87828efcb0dd630cac4862d04dd7f6535acb098bddb303af4fe34663bb3)
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument isp", value=isp, expected_type=type_hints["isp"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument netmode", value=netmode, expected_type=type_hints["netmode"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument pricing_cycle", value=pricing_cycle, expected_type=type_hints["pricing_cycle"])
            check_type(argname="argument public_ip_address_pool_id", value=public_ip_address_pool_id, expected_type=type_hints["public_ip_address_pool_id"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument security_protection_types", value=security_protection_types, expected_type=type_hints["security_protection_types"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument zone", value=zone, expected_type=type_hints["zone"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if bandwidth is not None:
            self._values["bandwidth"] = bandwidth
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if isp is not None:
            self._values["isp"] = isp
        if name is not None:
            self._values["name"] = name
        if netmode is not None:
            self._values["netmode"] = netmode
        if period is not None:
            self._values["period"] = period
        if pricing_cycle is not None:
            self._values["pricing_cycle"] = pricing_cycle
        if public_ip_address_pool_id is not None:
            self._values["public_ip_address_pool_id"] = public_ip_address_pool_id
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_protection_types is not None:
            self._values["security_protection_types"] = security_protection_types
        if tags is not None:
            self._values["tags"] = tags
        if zone is not None:
            self._values["zone"] = zone

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: autoPay: Automatic Payment. Default is true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: bandwidth: Bandwidth for the output network. Default is 5MB.
        '''
        result = self._values.get("bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        deletionProtection: Whether to enable deletion protection.
        Default to False.
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Optional. The description of the EIP. The description must be 2 to 256 characters in length. It must start with a letter. It cannot start with http://  or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: The resource charge type. Default value is Postpaid
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: internetChargeType: The network charge type. Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByBandwidth. PayByTraffic will charge by hour, PayByBandwidth will charge by day.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def isp(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        isp: The line type. You can set this parameter only when you create a pay-as-you-go EIP. Valid values:
        BGP: BGP (Multi-ISP) lines. Up to 89 high-quality BGP lines are available worldwide. Direct connections with multiple Internet Service Providers (ISPs), including Telecom, Unicom, Mobile, Railcom, Netcom, CERNET, China Broadcast Network, Dr. Peng, and Founder, can be established in all regions in mainland China.
        BGP_PRO: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines optimize data transmission to China and improve connection quality for international services. Compared with traditional BGP (Multi-ISP) lines, BGP (Multi-ISP) Pro lines can be used to establish direct connections without using international ISP services. Therefore, BGP (Multi-ISP) Pro lines reduce network latency.
        '''
        result = self._values.get("isp")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: The name of the EIP. The name must be 2 to 128 characters in length. It must start with a letter. It can contain numbers, periods (.), underscores (_), and hyphens (-). It cannot start with http://  or https://
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: netmode: The network type. Valid value: public (public network).
        '''
        result = self._values.get("netmode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        period: Prepaid time period. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36.
        While choose pay by year, it could be from 1 to 3.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pricingCycle: Price cycle of the resource. This property has no default value. If ChargeType is specified as Postpaid, this value will be ignore.
        '''
        result = self._values.get("pricing_cycle")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def public_ip_address_pool_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: publicIpAddressPoolId: The ID of the IP address pool. The EIP is allocated from the IP address pool.
        '''
        result = self._values.get("public_ip_address_pool_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: Resource group id.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_protection_types(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property:

        securityProtectionTypes: The edition of Anti-DDoS.
        If you do not set this parameter, Anti-DDoS Origin Basic is used.
        If you set the value to AntiDDoS_Enhanced, Anti-DDoS Pro/Premium is used.
        '''
        result = self._values.get("security_protection_types")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosEIP.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to eip. Max support 20 tags to add during create eip. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosEIP.TagsProperty]], result)

    @builtins.property
    def zone(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: zone: Availability zone of the elastic public network IP.
        '''
        result = self._values.get("zone")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosEIPProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosEIPSegment(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosEIPSegment",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::EIPSegment``, which is used to apply for contiguous elastic IP addresses (EIPs).

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``EIPSegment`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eipsegment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosEIPSegmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f15dee7600cea13998fe273e86c5c21b93f34b1eeb1fb720c1ef2532499495e0)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46e821272f9c6a6c9731779951786d1eefb1e3b180f0ff56726ed3f4c403fa97)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrEipAddresses")
    def attr_eip_addresses(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: EipAddresses: List of EIP addresses. like [{"AllocationId": "eip-xxx", "IpAddress": "xx.xx.xx.xx"}]
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipAddresses"))

    @builtins.property
    @jsii.member(jsii_name="attrEipSegmentInstanceId")
    def attr_eip_segment_instance_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: EipSegmentInstanceId: The ID of the contiguous EIP group.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEipSegmentInstanceId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="eipMask")
    def eip_mask(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        eipMask: The mask of the contiguous EIP group. Valid values:
        28: 16 contiguous EIPs are allocated for one call.
        27: 32 contiguous EIPs are allocated for one call.
        26: 64 contiguous EIPs are allocated for one call.
        25: 128 contiguous EIPs are allocated for one call.
        24: 256 contiguous EIPs are allocated for one call.
        Note The actual number of assigned EIPs may be less than the expected number because one,
        three, or four EIPs may be reserved.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "eipMask"))

    @eip_mask.setter
    def eip_mask(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9c2c8378cc5b6c0d9c67e2020456984bd7dfca59f877cb21176bc35f335f10b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "eipMask", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a9a493be669aa8ef1d220d8224025196cefd3bd75ae37c03f11d077b552ef07)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="bandwidth")
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: bandwidth: The maximum bandwidth of the contiguous EIPs. Unit: Mbit/s. Default value: 5.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "bandwidth"))

    @bandwidth.setter
    def bandwidth(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6601acc105eb50ca4c0d92b4da39013efc7098cb757bc766bf152e09660ace3c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetChargeType: The metering method of the contiguous EIPs. Valid values:
        PayByBandwidth: Fees are charged based on bandwidth usage. This is the default value.
        PayByTraffic: Fees are charged based on data transfer.
        Note If the Netmode parameter is set to hybrid, InternetChargeType is set to PayByBandwidth.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetChargeType"))

    @internet_charge_type.setter
    def internet_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bd08dafeff0c89c846a5e648cd3f6a9185f49797c15d4e81067da8c9b38f2d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="netmode")
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        netmode: The network type. Valid values:
        public: the Internet. This is the default value. After contiguous EIPs are associated with
        cloud resources, the cloud resources can access the Internet by using the EIPs.
        hybrid: the hybrid cloud. After contiguous EIPs are associated with cloud resources, the
        cloud resources can access the hybrid cloud by using the EIPs.
        Note This network type is available only to users who are added to the whitelist. To use
        this network type, contact your customer manager.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "netmode"))

    @netmode.setter
    def netmode(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7828226c33ddc4d7d9c8258eb8a1a985de9ac5b601056b6b4bf7bd1f0e934587)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "netmode", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group to which the EIPs belong.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78f9e0e3954655b5978f8c3b2529d1259d4d6e9549c34cd3372ad8c19dc94bf9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosEIPSegmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "eip_mask": "eipMask",
        "bandwidth": "bandwidth",
        "internet_charge_type": "internetChargeType",
        "netmode": "netmode",
        "resource_group_id": "resourceGroupId",
    },
)
class RosEIPSegmentProps:
    def __init__(
        self,
        *,
        eip_mask: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosEIPSegment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-eipsegment

        :param eip_mask: 
        :param bandwidth: 
        :param internet_charge_type: 
        :param netmode: 
        :param resource_group_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d96b03ca91c39db58a7bdf39ea22e904dcb52c615da7ca794945df5ce5365a6)
            check_type(argname="argument eip_mask", value=eip_mask, expected_type=type_hints["eip_mask"])
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument netmode", value=netmode, expected_type=type_hints["netmode"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "eip_mask": eip_mask,
        }
        if bandwidth is not None:
            self._values["bandwidth"] = bandwidth
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if netmode is not None:
            self._values["netmode"] = netmode
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def eip_mask(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        eipMask: The mask of the contiguous EIP group. Valid values:
        28: 16 contiguous EIPs are allocated for one call.
        27: 32 contiguous EIPs are allocated for one call.
        26: 64 contiguous EIPs are allocated for one call.
        25: 128 contiguous EIPs are allocated for one call.
        24: 256 contiguous EIPs are allocated for one call.
        Note The actual number of assigned EIPs may be less than the expected number because one,
        three, or four EIPs may be reserved.
        '''
        result = self._values.get("eip_mask")
        assert result is not None, "Required property 'eip_mask' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: bandwidth: The maximum bandwidth of the contiguous EIPs. Unit: Mbit/s. Default value: 5.
        '''
        result = self._values.get("bandwidth")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetChargeType: The metering method of the contiguous EIPs. Valid values:
        PayByBandwidth: Fees are charged based on bandwidth usage. This is the default value.
        PayByTraffic: Fees are charged based on data transfer.
        Note If the Netmode parameter is set to hybrid, InternetChargeType is set to PayByBandwidth.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def netmode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        netmode: The network type. Valid values:
        public: the Internet. This is the default value. After contiguous EIPs are associated with
        cloud resources, the cloud resources can access the Internet by using the EIPs.
        hybrid: the hybrid cloud. After contiguous EIPs are associated with cloud resources, the
        cloud resources can access the hybrid cloud by using the EIPs.
        Note This network type is available only to users who are added to the whitelist. To use
        this network type, contact your customer manager.
        '''
        result = self._values.get("netmode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group to which the EIPs belong.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosEIPSegmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosFlowLog(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosFlowLog",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::FlowLog``, which is used to create a flow log.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``FlowLog`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-flowlog
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosFlowLogProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c211363d9d94f4817f513f0941eb8256c9042621ca4e101a5b157f90dc847cb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0e52388f590ca79865c87917826aa78faac1045b550ba4146e42ad7849ee3d8)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDescription")
    def attr_description(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Description: The Description of flow log.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDescription"))

    @builtins.property
    @jsii.member(jsii_name="attrFlowLogId")
    def attr_flow_log_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: FlowLogId: The flow log ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrFlowLogId"))

    @builtins.property
    @jsii.member(jsii_name="attrFlowLogName")
    def attr_flow_log_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: FlowLogName: The flow log name.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrFlowLogName"))

    @builtins.property
    @jsii.member(jsii_name="attrLogStoreName")
    def attr_log_store_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: LogStoreName: The log store name.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrLogStoreName"))

    @builtins.property
    @jsii.member(jsii_name="attrProjectName")
    def attr_project_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ProjectName: The project name.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrProjectName"))

    @builtins.property
    @jsii.member(jsii_name="attrResourceId")
    def attr_resource_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ResourceId: The resource id.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrResourceId"))

    @builtins.property
    @jsii.member(jsii_name="attrResourceType")
    def attr_resource_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ResourceType: The resource type.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrResourceType"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficType")
    def attr_traffic_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: TrafficType: The traffic type.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficType"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8dea9bf287af08c136dc97f59e7ece94b88f88d4ffa530d54174f2006bb4537)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="logStoreName")
    def log_store_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: logStoreName: The log store name.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "logStoreName"))

    @log_store_name.setter
    def log_store_name(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41344808d49d0204b75a4577f0f54ea5de86709a86ab5795f87446732c390a05)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "logStoreName", value)

    @builtins.property
    @jsii.member(jsii_name="projectName")
    def project_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: projectName: The project name.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "projectName"))

    @project_name.setter
    def project_name(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ca41f46bd4c201a0f508f2d85216aadeec11fe69cdf628eb4370e69b0aeb6d5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "projectName", value)

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: resourceId: The resource id.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "resourceId"))

    @resource_id.setter
    def resource_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb77dfb0cdf25164b49d221ff0109dd10fa3216cba18ff0f6194cf41a0604f40)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceId", value)

    @builtins.property
    @jsii.member(jsii_name="resourceType")
    def resource_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: resourceType: The resource type.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "resourceType"))

    @resource_type.setter
    def resource_type(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe3bfe9fb5ed68e492bb600da09d987a1a8ec6fff67890c34f22a16d04fd800a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceType", value)

    @builtins.property
    @jsii.member(jsii_name="trafficType")
    def traffic_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: trafficType: The traffic type.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "trafficType"))

    @traffic_type.setter
    def traffic_type(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1072fd3b0a2b669e590c600810f9c61340766d93887bf46224e5b9c266bfb13)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficType", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: The Description of flow log.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf1f50d750b781cd42dc37d81b2884ada11bbb16decbe19d6a57cce745e73e08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="flowLogName")
    def flow_log_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: flowLogName: The flow log name.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "flowLogName"))

    @flow_log_name.setter
    def flow_log_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09f3049d5573f7d1ff89d33488a352fd023fb8a9b9b23f637936c95499edd48d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "flowLogName", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosFlowLogProps",
    jsii_struct_bases=[],
    name_mapping={
        "log_store_name": "logStoreName",
        "project_name": "projectName",
        "resource_id": "resourceId",
        "resource_type": "resourceType",
        "traffic_type": "trafficType",
        "description": "description",
        "flow_log_name": "flowLogName",
    },
)
class RosFlowLogProps:
    def __init__(
        self,
        *,
        log_store_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        project_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        resource_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        resource_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        flow_log_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosFlowLog``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-flowlog

        :param log_store_name: 
        :param project_name: 
        :param resource_id: 
        :param resource_type: 
        :param traffic_type: 
        :param description: 
        :param flow_log_name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e6cc77473c71302a63f1584ead5ec6a8ef182d24dc7a5cd421c66c705aa1a30)
            check_type(argname="argument log_store_name", value=log_store_name, expected_type=type_hints["log_store_name"])
            check_type(argname="argument project_name", value=project_name, expected_type=type_hints["project_name"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument traffic_type", value=traffic_type, expected_type=type_hints["traffic_type"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument flow_log_name", value=flow_log_name, expected_type=type_hints["flow_log_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "log_store_name": log_store_name,
            "project_name": project_name,
            "resource_id": resource_id,
            "resource_type": resource_type,
            "traffic_type": traffic_type,
        }
        if description is not None:
            self._values["description"] = description
        if flow_log_name is not None:
            self._values["flow_log_name"] = flow_log_name

    @builtins.property
    def log_store_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: logStoreName: The log store name.
        '''
        result = self._values.get("log_store_name")
        assert result is not None, "Required property 'log_store_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def project_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: projectName: The project name.
        '''
        result = self._values.get("project_name")
        assert result is not None, "Required property 'project_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def resource_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: resourceId: The resource id.
        '''
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def resource_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: resourceType: The resource type.
        '''
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: trafficType: The traffic type.
        '''
        result = self._values.get("traffic_type")
        assert result is not None, "Required property 'traffic_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: The Description of flow log.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def flow_log_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: flowLogName: The flow log name.
        '''
        result = self._values.get("flow_log_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosFlowLogProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosForwardEntry(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosForwardEntry",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::ForwardEntry``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``ForwardEntry`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-forwardentry
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosForwardEntryProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb1578cc9e01d28a2aa92f2ed8deb481cdb167daf1e046c494d2131db0cdec87)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3268f3bdcaf6695fd04a944b0fc7e643c25c8ffba3eceab4068c54f7221a093)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrForwardEntryId")
    def attr_forward_entry_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ForwardEntryId: The id of created forward entry.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrForwardEntryId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73bb1dacb8389871ee9f942182d54b41f62c310a8cecc04d30772a36a1cd2083)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="externalIp")
    def external_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: externalIp: Source IP, must belongs to bandwidth package internet IP
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "externalIp"))

    @external_ip.setter
    def external_ip(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a529b372354ec97bd9b898d7b4d48a27be87b1b2fedc9c90bef4b7de4afb092)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "externalIp", value)

    @builtins.property
    @jsii.member(jsii_name="externalPort")
    def external_port(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: externalPort: Source port, now support [1-65535]|Any|x/y
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "externalPort"))

    @external_port.setter
    def external_port(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80527b424eb543574db9ed4c09dca3d70d31ba431ca3ffdc5bbf54037243730e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "externalPort", value)

    @builtins.property
    @jsii.member(jsii_name="forwardTableId")
    def forward_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: forwardTableId: Create forward entry in specified forward table.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "forwardTableId"))

    @forward_table_id.setter
    def forward_table_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9be7d2f202fc75054c0037e0bc21f08470850b78b176cca39572e224ed1ca8c8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "forwardTableId", value)

    @builtins.property
    @jsii.member(jsii_name="internalIp")
    def internal_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: internalIp: Destination IP, must belong to VPC private IP
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "internalIp"))

    @internal_ip.setter
    def internal_ip(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be61f19befb833f81c24ac4bc3b085f2a93124193cdf49fffe9e28eb55cb9427)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalIp", value)

    @builtins.property
    @jsii.member(jsii_name="internalPort")
    def internal_port(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: internalPort: Destination port, now support [1-65535]|Any|x/y
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "internalPort"))

    @internal_port.setter
    def internal_port(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd13ce6a74fb22e6662fe708077ba1d73845e397f63fa6bcacf5fb39c8e3e5bb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalPort", value)

    @builtins.property
    @jsii.member(jsii_name="ipProtocol")
    def ip_protocol(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: ipProtocol: Supported protocol, Now support 'TCP|UDP|Any'
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "ipProtocol"))

    @ip_protocol.setter
    def ip_protocol(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fba41db38fad93d8aab24a1634d7f963ac26b043a2c7df85024e351e7a1b9b6e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipProtocol", value)

    @builtins.property
    @jsii.member(jsii_name="forwardEntryName")
    def forward_entry_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: forwardEntryName: the name of the DNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "forwardEntryName"))

    @forward_entry_name.setter
    def forward_entry_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5e28d8f95ebad30cad4e149413dd42f81520a80ff7bbdf563d09f761b384eab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "forwardEntryName", value)

    @builtins.property
    @jsii.member(jsii_name="portBreak")
    def port_break(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: portBreak: Specifies whether to remove limits on the port range.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "portBreak"))

    @port_break.setter
    def port_break(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13e82f28e23ca470610ebbbb61047baa280174c46b27ba05c0639bec42d9e868)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "portBreak", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosForwardEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "external_ip": "externalIp",
        "external_port": "externalPort",
        "forward_table_id": "forwardTableId",
        "internal_ip": "internalIp",
        "internal_port": "internalPort",
        "ip_protocol": "ipProtocol",
        "forward_entry_name": "forwardEntryName",
        "port_break": "portBreak",
    },
)
class RosForwardEntryProps:
    def __init__(
        self,
        *,
        external_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        external_port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        forward_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        internal_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        internal_port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ip_protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        forward_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        port_break: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosForwardEntry``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-forwardentry

        :param external_ip: 
        :param external_port: 
        :param forward_table_id: 
        :param internal_ip: 
        :param internal_port: 
        :param ip_protocol: 
        :param forward_entry_name: 
        :param port_break: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9b056877a641f807e08d771346821d8cc5905db404b92757e33f31d8fbba38b)
            check_type(argname="argument external_ip", value=external_ip, expected_type=type_hints["external_ip"])
            check_type(argname="argument external_port", value=external_port, expected_type=type_hints["external_port"])
            check_type(argname="argument forward_table_id", value=forward_table_id, expected_type=type_hints["forward_table_id"])
            check_type(argname="argument internal_ip", value=internal_ip, expected_type=type_hints["internal_ip"])
            check_type(argname="argument internal_port", value=internal_port, expected_type=type_hints["internal_port"])
            check_type(argname="argument ip_protocol", value=ip_protocol, expected_type=type_hints["ip_protocol"])
            check_type(argname="argument forward_entry_name", value=forward_entry_name, expected_type=type_hints["forward_entry_name"])
            check_type(argname="argument port_break", value=port_break, expected_type=type_hints["port_break"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "external_ip": external_ip,
            "external_port": external_port,
            "forward_table_id": forward_table_id,
            "internal_ip": internal_ip,
            "internal_port": internal_port,
            "ip_protocol": ip_protocol,
        }
        if forward_entry_name is not None:
            self._values["forward_entry_name"] = forward_entry_name
        if port_break is not None:
            self._values["port_break"] = port_break

    @builtins.property
    def external_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: externalIp: Source IP, must belongs to bandwidth package internet IP
        '''
        result = self._values.get("external_ip")
        assert result is not None, "Required property 'external_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def external_port(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: externalPort: Source port, now support [1-65535]|Any|x/y
        '''
        result = self._values.get("external_port")
        assert result is not None, "Required property 'external_port' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def forward_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: forwardTableId: Create forward entry in specified forward table.
        '''
        result = self._values.get("forward_table_id")
        assert result is not None, "Required property 'forward_table_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def internal_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: internalIp: Destination IP, must belong to VPC private IP
        '''
        result = self._values.get("internal_ip")
        assert result is not None, "Required property 'internal_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def internal_port(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: internalPort: Destination port, now support [1-65535]|Any|x/y
        '''
        result = self._values.get("internal_port")
        assert result is not None, "Required property 'internal_port' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def ip_protocol(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: ipProtocol: Supported protocol, Now support 'TCP|UDP|Any'
        '''
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def forward_entry_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: forwardEntryName: the name of the DNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        '''
        result = self._values.get("forward_entry_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def port_break(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: portBreak: Specifies whether to remove limits on the port range.
        '''
        result = self._values.get("port_break")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosForwardEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosGrantInstanceToCen(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosGrantInstanceToCen",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::GrantInstanceToCen``, which is used to authorize a CEN instance.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``GrantInstanceToCen`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-grantinstancetocen
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosGrantInstanceToCenProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee495d2f870b3cc5c0f7e856aeca68c9a2ab108f01b12bd0f326ca5ab29ddb08)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d326b989a233e141aab9b414404fcae5510c87e013e8fa17107310ca4ce21b97)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrCenId")
    def attr_cen_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: CenId: The ID of the CEN instance to be authorized.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrCenId"))

    @builtins.property
    @jsii.member(jsii_name="attrInstanceId")
    def attr_instance_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: InstanceId: The ID of the network instance.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInstanceId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="cenId")
    def cen_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: cenId: The ID of the CEN instance to be authorized.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "cenId"))

    @cen_id.setter
    def cen_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0d7f37bb729daedb7e49c23c5574af0b49b307f43a7f7a099ab534774093346)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cenId", value)

    @builtins.property
    @jsii.member(jsii_name="cenOwnerId")
    def cen_owner_id(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: cenOwnerId: The UID of the account to which the target CEN instance belongs.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "cenOwnerId"))

    @cen_owner_id.setter
    def cen_owner_id(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__337a3ee75b6ea36d1a71d7101d9b82f24797791f39b7bb3f345535124aa2b552)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cenOwnerId", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c0896121d523f4767f2a61a51136d93d6d3d4e43e5ae9425f78e1f0a4c1dc43)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="instanceId")
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: instanceId: The ID of the network instance.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e179a342d45b9bfce080a70cf05b10afd14a4cecdc21759bac6f2f9e3fa499c8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceId", value)

    @builtins.property
    @jsii.member(jsii_name="instanceType")
    def instance_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        instanceType: The type of the network instance. Valid values:
        VPC: Virtual Private Cloud (VPC).
        VBR: Virtual Border Router (VBR).
        CCN: Cloud Connect Network (CCN).
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "instanceType"))

    @instance_type.setter
    def instance_type(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f68e02e64e6ff3b1bb01d204ce39aea79997aaa12066f4ebcbb4d211dc2b80fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceType", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosGrantInstanceToCenProps",
    jsii_struct_bases=[],
    name_mapping={
        "cen_id": "cenId",
        "cen_owner_id": "cenOwnerId",
        "instance_id": "instanceId",
        "instance_type": "instanceType",
    },
)
class RosGrantInstanceToCenProps:
    def __init__(
        self,
        *,
        cen_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        cen_owner_id: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        instance_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``RosGrantInstanceToCen``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-grantinstancetocen

        :param cen_id: 
        :param cen_owner_id: 
        :param instance_id: 
        :param instance_type: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12063dfd64a34d43f5e225740c5705fa3cae4c36c68ed25c5c254968de2361ba)
            check_type(argname="argument cen_id", value=cen_id, expected_type=type_hints["cen_id"])
            check_type(argname="argument cen_owner_id", value=cen_owner_id, expected_type=type_hints["cen_owner_id"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cen_id": cen_id,
            "cen_owner_id": cen_owner_id,
            "instance_id": instance_id,
            "instance_type": instance_type,
        }

    @builtins.property
    def cen_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: cenId: The ID of the CEN instance to be authorized.
        '''
        result = self._values.get("cen_id")
        assert result is not None, "Required property 'cen_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def cen_owner_id(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: cenOwnerId: The UID of the account to which the target CEN instance belongs.
        '''
        result = self._values.get("cen_owner_id")
        assert result is not None, "Required property 'cen_owner_id' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: instanceId: The ID of the network instance.
        '''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        instanceType: The type of the network instance. Valid values:
        VPC: Virtual Private Cloud (VPC).
        VBR: Virtual Border Router (VBR).
        CCN: Cloud Connect Network (CCN).
        '''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosGrantInstanceToCenProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosHaVip(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosHaVip",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::HaVip``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``HaVip`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-havip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosHaVipProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b364da372c3b3a744e5721a48e385b482a3aa9c611695427ed4f6211c89e3619)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0fe0bf4e80b5e9207116edbd675dd9e8e9001929f6e8e9af2df8051907f0361)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrHaVipId")
    def attr_ha_vip_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: HaVipId: Assigned HaVip ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrHaVipId"))

    @builtins.property
    @jsii.member(jsii_name="attrIpAddress")
    def attr_ip_address(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: IpAddress: The IP address of the HAVIP.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpAddress"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c34e7e869733f922cb6c0ed1b0177a4bf025fb3280a7c767fbb8686a4944837)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vSwitchId: The ID of the vSwitch to which the HAVIP belongs.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vSwitchId"))

    @v_switch_id.setter
    def v_switch_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c917e2fc6974e6fea62c3414d706823f1a1f4b12ac4b104895bb5769a7f136f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vSwitchId", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the HAVIP.
        The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41c5bd1f4efb08ec43e8378d9c30241803b0a4ffb18c5674df93e1df0fa1e152)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="ipAddress")
    def ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipAddress: The IP address of the HAVIP. The specified IP address must be an idle IP address that falls within the CIDR block of the vSwitch. If this parameter is not set, an idle IP address from the CIDR block of the vSwitch is randomly assigned to the HAVIP.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ipAddress"))

    @ip_address.setter
    def ip_address(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2889a664c8abd77aa8b155834b694ace49d02e8be33aa74e0cdcb328f86f55e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipAddress", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the HAVIP.
        The name must be 1 to 128 characters in length, and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de57fe833ab254dbd1ce6fe7cae8ed4d7a28d20c40e587ad6385d508dfb712bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group to which the HAVIP belongs.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__726a1ca5aaaf52d80e2245aacfaa556e2aa105cfbae9a02d5c9cd025cb8c3391)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosHaVip.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosHaVip.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosHaVip.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86c4f9bb83377f1476b2ed5340ec829fa7d158ba3159d7540231949368552724)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosHaVip.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c6991bdda71cef19f1d719e1ea703dbbbaf5d7252cb9ebb69489db6451276c4d)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosHaVipAssociation(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosHaVipAssociation",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::HaVipAssociation``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``HaVipAssociation`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-havipassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosHaVipAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aea0bdaaf46be718f76dd7f5bfb6c028ea38d9b161b0be6aff109c1b336e4ccf)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c68881fd0c2f840b156d0031f2fcb571e16ffa92ff8c9c48691c6cf1d018982)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41872567ba8243440589dc00d44bab55d99a9994b0d76aabab6eda1f7db7c0c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="haVipId")
    def ha_vip_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: haVipId: The ID of the HAVIP.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "haVipId"))

    @ha_vip_id.setter
    def ha_vip_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42acc0c8cf216b327fbb0ed85228c653565a1bbfa52d1f0d0480f88114f040ac)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "haVipId", value)

    @builtins.property
    @jsii.member(jsii_name="instanceId")
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: instanceId: The ID of the ECS instance to be associated with the HAVIP.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a45a386273934b4ac2f57d19244d503e389161b5434b25c3ba26197f15d7914a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceId", value)

    @builtins.property
    @jsii.member(jsii_name="instanceType")
    def instance_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        instanceType: The type of the instance to be associated with the HAVIP. Valid values:
        EcsInstance: an ECS instance
        NetworkInterface: an ENI. If you want to associate the HAVIP with an ENI, this parameter is required.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceType"))

    @instance_type.setter
    def instance_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61fe75d4cec02a61640bf8b0970f226875231dcc1d74344785ff0b5dbbee271d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceType", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosHaVipAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "ha_vip_id": "haVipId",
        "instance_id": "instanceId",
        "instance_type": "instanceType",
    },
)
class RosHaVipAssociationProps:
    def __init__(
        self,
        *,
        ha_vip_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosHaVipAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-havipassociation

        :param ha_vip_id: 
        :param instance_id: 
        :param instance_type: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28f258f29fef26dd46ce90e85c7bbb28a6bc15f7192d99ef2e3ffa37cff90052)
            check_type(argname="argument ha_vip_id", value=ha_vip_id, expected_type=type_hints["ha_vip_id"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ha_vip_id": ha_vip_id,
            "instance_id": instance_id,
        }
        if instance_type is not None:
            self._values["instance_type"] = instance_type

    @builtins.property
    def ha_vip_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: haVipId: The ID of the HAVIP.
        '''
        result = self._values.get("ha_vip_id")
        assert result is not None, "Required property 'ha_vip_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: instanceId: The ID of the ECS instance to be associated with the HAVIP.
        '''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def instance_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        instanceType: The type of the instance to be associated with the HAVIP. Valid values:
        EcsInstance: an ECS instance
        NetworkInterface: an ENI. If you want to associate the HAVIP with an ENI, this parameter is required.
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosHaVipAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosHaVipProps",
    jsii_struct_bases=[],
    name_mapping={
        "v_switch_id": "vSwitchId",
        "description": "description",
        "ip_address": "ipAddress",
        "name": "name",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
    },
)
class RosHaVipProps:
    def __init__(
        self,
        *,
        v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosHaVip.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosHaVip``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-havip

        :param v_switch_id: 
        :param description: 
        :param ip_address: 
        :param name: 
        :param resource_group_id: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16f18a0df4232174a25ecef05d5bbae64e438039d575cecc0438927919eba3d5)
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "v_switch_id": v_switch_id,
        }
        if description is not None:
            self._values["description"] = description
        if ip_address is not None:
            self._values["ip_address"] = ip_address
        if name is not None:
            self._values["name"] = name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vSwitchId: The ID of the vSwitch to which the HAVIP belongs.
        '''
        result = self._values.get("v_switch_id")
        assert result is not None, "Required property 'v_switch_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the HAVIP.
        The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ip_address(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipAddress: The IP address of the HAVIP. The specified IP address must be an idle IP address that falls within the CIDR block of the vSwitch. If this parameter is not set, an idle IP address from the CIDR block of the vSwitch is randomly assigned to the HAVIP.
        '''
        result = self._values.get("ip_address")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the HAVIP.
        The name must be 1 to 128 characters in length, and cannot start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group to which the HAVIP belongs.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosHaVip.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosHaVip.TagsProperty]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosHaVipProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosIpsecServer(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosIpsecServer",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::IpsecServer``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``IpsecServer`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipsecserver
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosIpsecServerProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__832ab52ab741cb60d4a892ef4cc770b54ee22c0ad9893a0eb0b2ba4510ef7e13)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed8d306ee20b614ca544d03c733000376dda539c20d9ad166d9a24aa2bab568f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrIpsecServerId")
    def attr_ipsec_server_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: IpsecServerId: IPsec server ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpsecServerId"))

    @builtins.property
    @jsii.member(jsii_name="attrIpsecServerName")
    def attr_ipsec_server_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: IpsecServerName: IPsec server name.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpsecServerName"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="clientIpPool")
    def client_ip_pool(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: clientIpPool: Client network segment refers to the address segment that assigns access addresses to the virtual network card of the client. Note: The client network segment cannot conflict with the VPC side network segment.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "clientIpPool"))

    @client_ip_pool.setter
    def client_ip_pool(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__920ca49f5d074f3a61fac74a8019a147634d6fb400f34e258c7192b479c5889f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientIpPool", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eba68a3f6818fe177d465d02e255f3620b1729852ab28ae140dfaa5ab4619f55)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="localSubnet")
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: localSubnet: The local network segment refers to the network segment on the VPC side that needs to be interconnected with the client network segment. Use half-width commas (,) to separate multiple network segments, for example: 192.168.1.0/24,192.168.2.0/24.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "localSubnet"))

    @local_subnet.setter
    def local_subnet(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2d1204d48bd82147bebdc32313f7405c2fb2690af8f2cf3de2c9b0933a8719e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSubnet", value)

    @builtins.property
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: VPN gateway instance ID.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpnGatewayId"))

    @vpn_gateway_id.setter
    def vpn_gateway_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c0dcf28c2712d58e58a158564a6aad598f3d565438718c99acd43b6a8e9f22c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpnGatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="effectImmediately")
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        effectImmediately: true: Apply the new configuration and trigger a reconnection immediately.
        false: Trigger a reconnection only when network traffic occurs. (The reconnection may cause the network to be unavailable for a brief moment)
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "effectImmediately"))

    @effect_immediately.setter
    def effect_immediately(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1639df04215cf227bf14bb10a5db76e3d22522a7e50c0e99a66d70655e420ea5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "effectImmediately", value)

    @builtins.property
    @jsii.member(jsii_name="ikeConfig")
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IkeConfigProperty"]]:
        '''
        :Property: ikeConfig: Negotiation parameter configuration in the first phase.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IkeConfigProperty"]], jsii.get(self, "ikeConfig"))

    @ike_config.setter
    def ike_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IkeConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f62769c32090e5355d0acd316ef88b902d0b71c0dec1476130461a25c8018cce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ikeConfig", value)

    @builtins.property
    @jsii.member(jsii_name="ipsecConfig")
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IpsecConfigProperty"]]:
        '''
        :Property: ipsecConfig: Negotiation parameter configuration in the second phase.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IpsecConfigProperty"]], jsii.get(self, "ipsecConfig"))

    @ipsec_config.setter
    def ipsec_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosIpsecServer.IpsecConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e9c0d7adfa04f65a2eda564a8dc3cb0f9b8dff2dbf75f762b7a8c851952bbe7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipsecConfig", value)

    @builtins.property
    @jsii.member(jsii_name="ipsecServerName")
    def ipsec_server_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipsecServerName: The value must be 2 to 128 characters in length and start with a letter or Chinese character. It can contain digits, underscores (_), and hyphens (-).
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ipsecServerName"))

    @ipsec_server_name.setter
    def ipsec_server_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05dfa566db18d18e7a08d877b39b81bb27bfb53b186b67506051f4feb17a2dcc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipsecServerName", value)

    @builtins.property
    @jsii.member(jsii_name="psk")
    def psk(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: psk: Pre-Shared key. Used for identity authentication between the VPN gateway and the client. A 16-bit random string is randomly generated by default, or you can manually specify the key. The length is limited to 100 characters.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "psk"))

    @psk.setter
    def psk(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05394fe0da3f5de751895a4469edbe9d30f743843c3880657c15995284b0a909)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "psk", value)

    @builtins.property
    @jsii.member(jsii_name="pskEnabled")
    def psk_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pskEnabled: Whether to enable the pre-shared key authentication method. Only the value is true, which means that the pre-shared key authentication mode is enabled.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "pskEnabled"))

    @psk_enabled.setter
    def psk_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__951f84f9a070ec3827fef6cd7908f315bcb944041eadab3997eecccebee70e79)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pskEnabled", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosIpsecServer.IkeConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ike_auth_alg": "ikeAuthAlg",
            "ike_enc_alg": "ikeEncAlg",
            "ike_lifetime": "ikeLifetime",
            "ike_mode": "ikeMode",
            "ike_pfs": "ikePfs",
            "ike_version": "ikeVersion",
            "local_id": "localId",
            "remote_id": "remoteId",
        },
    )
    class IkeConfigProperty:
        def __init__(
            self,
            *,
            ike_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            remote_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param ike_auth_alg: 
            :param ike_enc_alg: 
            :param ike_lifetime: 
            :param ike_mode: 
            :param ike_pfs: 
            :param ike_version: 
            :param local_id: 
            :param remote_id: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c9c5aa5be45ec12dc8cbfe4749491ba5e338bd6a12c4e9ef7c7a821ff9c10aa3)
                check_type(argname="argument ike_auth_alg", value=ike_auth_alg, expected_type=type_hints["ike_auth_alg"])
                check_type(argname="argument ike_enc_alg", value=ike_enc_alg, expected_type=type_hints["ike_enc_alg"])
                check_type(argname="argument ike_lifetime", value=ike_lifetime, expected_type=type_hints["ike_lifetime"])
                check_type(argname="argument ike_mode", value=ike_mode, expected_type=type_hints["ike_mode"])
                check_type(argname="argument ike_pfs", value=ike_pfs, expected_type=type_hints["ike_pfs"])
                check_type(argname="argument ike_version", value=ike_version, expected_type=type_hints["ike_version"])
                check_type(argname="argument local_id", value=local_id, expected_type=type_hints["local_id"])
                check_type(argname="argument remote_id", value=remote_id, expected_type=type_hints["remote_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ike_auth_alg is not None:
                self._values["ike_auth_alg"] = ike_auth_alg
            if ike_enc_alg is not None:
                self._values["ike_enc_alg"] = ike_enc_alg
            if ike_lifetime is not None:
                self._values["ike_lifetime"] = ike_lifetime
            if ike_mode is not None:
                self._values["ike_mode"] = ike_mode
            if ike_pfs is not None:
                self._values["ike_pfs"] = ike_pfs
            if ike_version is not None:
                self._values["ike_version"] = ike_version
            if local_id is not None:
                self._values["local_id"] = local_id
            if remote_id is not None:
                self._values["remote_id"] = remote_id

        @builtins.property
        def ike_auth_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeAuthAlg: The authentication algorithm negotiated in the first phase. Default value: sha1.
            '''
            result = self._values.get("ike_auth_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_enc_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeEncAlg: Encryption algorithm negotiated in the first stage. Default value: aes.
            '''
            result = self._values.get("ike_enc_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_lifetime(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeLifetime: The life cycle of the SA negotiated in the first phase. Default value: 86400, in seconds.
            '''
            result = self._values.get("ike_lifetime")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_mode(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeMode: Negotiation mode of the IKE version. Default value: main.
            '''
            result = self._values.get("ike_mode")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_pfs(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikePfs: The Diffie-Hellman key exchange algorithm used in the first stage of negotiation. Default value: group2.
            '''
            result = self._values.get("ike_pfs")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_version(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeVersion: The version of the IKE protocol. Value: ikev1 or ikev2, default value: ikev2.
            '''
            result = self._values.get("ike_version")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: localId: IPsec server ID. Support FQDN and IP address format, the default value is the VPN gateway public network IP address.
            '''
            result = self._values.get("local_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def remote_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: remoteId: Peer ID. Support FQDN and IP address format, the default value is empty.
            '''
            result = self._values.get("remote_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IkeConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosIpsecServer.IpsecConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ipsec_auth_alg": "ipsecAuthAlg",
            "ipsec_enc_alg": "ipsecEncAlg",
            "ipsec_lifetime": "ipsecLifetime",
            "ipsec_pfs": "ipsecPfs",
        },
    )
    class IpsecConfigProperty:
        def __init__(
            self,
            *,
            ipsec_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param ipsec_auth_alg: 
            :param ipsec_enc_alg: 
            :param ipsec_lifetime: 
            :param ipsec_pfs: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8977765ef51ff27e2948207560a58befb936f7dcc7347f7f456e58228f8a3af8)
                check_type(argname="argument ipsec_auth_alg", value=ipsec_auth_alg, expected_type=type_hints["ipsec_auth_alg"])
                check_type(argname="argument ipsec_enc_alg", value=ipsec_enc_alg, expected_type=type_hints["ipsec_enc_alg"])
                check_type(argname="argument ipsec_lifetime", value=ipsec_lifetime, expected_type=type_hints["ipsec_lifetime"])
                check_type(argname="argument ipsec_pfs", value=ipsec_pfs, expected_type=type_hints["ipsec_pfs"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipsec_auth_alg is not None:
                self._values["ipsec_auth_alg"] = ipsec_auth_alg
            if ipsec_enc_alg is not None:
                self._values["ipsec_enc_alg"] = ipsec_enc_alg
            if ipsec_lifetime is not None:
                self._values["ipsec_lifetime"] = ipsec_lifetime
            if ipsec_pfs is not None:
                self._values["ipsec_pfs"] = ipsec_pfs

        @builtins.property
        def ipsec_auth_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecAuthAlg: The authentication algorithm negotiated in the second phase. Default value: sha1.
            '''
            result = self._values.get("ipsec_auth_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_enc_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecEncAlg: Encryption algorithm negotiated in the second stage. Default value: aes.
            '''
            result = self._values.get("ipsec_enc_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_lifetime(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecLifetime: The lifetime of the SA negotiated in the second stage. Default value: 86400, in seconds.
            '''
            result = self._values.get("ipsec_lifetime")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_pfs(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecPfs: The Diffie-Hellman key exchange algorithm used in the second phase of negotiation. Default value: group2.
            '''
            result = self._values.get("ipsec_pfs")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpsecConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosIpsecServerProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_ip_pool": "clientIpPool",
        "local_subnet": "localSubnet",
        "vpn_gateway_id": "vpnGatewayId",
        "effect_immediately": "effectImmediately",
        "ike_config": "ikeConfig",
        "ipsec_config": "ipsecConfig",
        "ipsec_server_name": "ipsecServerName",
        "psk": "psk",
        "psk_enabled": "pskEnabled",
    },
)
class RosIpsecServerProps:
    def __init__(
        self,
        *,
        client_ip_pool: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosIpsecServer.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosIpsecServer.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_server_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        psk_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosIpsecServer``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipsecserver

        :param client_ip_pool: 
        :param local_subnet: 
        :param vpn_gateway_id: 
        :param effect_immediately: 
        :param ike_config: 
        :param ipsec_config: 
        :param ipsec_server_name: 
        :param psk: 
        :param psk_enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5265535c03b31d0256fd6f8cbb96e8d7a6f1dae71e0dccb977dfd2bfa78f240c)
            check_type(argname="argument client_ip_pool", value=client_ip_pool, expected_type=type_hints["client_ip_pool"])
            check_type(argname="argument local_subnet", value=local_subnet, expected_type=type_hints["local_subnet"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument effect_immediately", value=effect_immediately, expected_type=type_hints["effect_immediately"])
            check_type(argname="argument ike_config", value=ike_config, expected_type=type_hints["ike_config"])
            check_type(argname="argument ipsec_config", value=ipsec_config, expected_type=type_hints["ipsec_config"])
            check_type(argname="argument ipsec_server_name", value=ipsec_server_name, expected_type=type_hints["ipsec_server_name"])
            check_type(argname="argument psk", value=psk, expected_type=type_hints["psk"])
            check_type(argname="argument psk_enabled", value=psk_enabled, expected_type=type_hints["psk_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_ip_pool": client_ip_pool,
            "local_subnet": local_subnet,
            "vpn_gateway_id": vpn_gateway_id,
        }
        if effect_immediately is not None:
            self._values["effect_immediately"] = effect_immediately
        if ike_config is not None:
            self._values["ike_config"] = ike_config
        if ipsec_config is not None:
            self._values["ipsec_config"] = ipsec_config
        if ipsec_server_name is not None:
            self._values["ipsec_server_name"] = ipsec_server_name
        if psk is not None:
            self._values["psk"] = psk
        if psk_enabled is not None:
            self._values["psk_enabled"] = psk_enabled

    @builtins.property
    def client_ip_pool(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: clientIpPool: Client network segment refers to the address segment that assigns access addresses to the virtual network card of the client. Note: The client network segment cannot conflict with the VPC side network segment.
        '''
        result = self._values.get("client_ip_pool")
        assert result is not None, "Required property 'client_ip_pool' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: localSubnet: The local network segment refers to the network segment on the VPC side that needs to be interconnected with the client network segment. Use half-width commas (,) to separate multiple network segments, for example: 192.168.1.0/24,192.168.2.0/24.
        '''
        result = self._values.get("local_subnet")
        assert result is not None, "Required property 'local_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: VPN gateway instance ID.
        '''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        effectImmediately: true: Apply the new configuration and trigger a reconnection immediately.
        false: Trigger a reconnection only when network traffic occurs. (The reconnection may cause the network to be unavailable for a brief moment)
        '''
        result = self._values.get("effect_immediately")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosIpsecServer.IkeConfigProperty]]:
        '''
        :Property: ikeConfig: Negotiation parameter configuration in the first phase.
        '''
        result = self._values.get("ike_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosIpsecServer.IkeConfigProperty]], result)

    @builtins.property
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosIpsecServer.IpsecConfigProperty]]:
        '''
        :Property: ipsecConfig: Negotiation parameter configuration in the second phase.
        '''
        result = self._values.get("ipsec_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosIpsecServer.IpsecConfigProperty]], result)

    @builtins.property
    def ipsec_server_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipsecServerName: The value must be 2 to 128 characters in length and start with a letter or Chinese character. It can contain digits, underscores (_), and hyphens (-).
        '''
        result = self._values.get("ipsec_server_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def psk(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: psk: Pre-Shared key. Used for identity authentication between the VPN gateway and the client. A 16-bit random string is randomly generated by default, or you can manually specify the key. The length is limited to 100 characters.
        '''
        result = self._values.get("psk")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def psk_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pskEnabled: Whether to enable the pre-shared key authentication method. Only the value is true, which means that the pre-shared key authentication mode is enabled.
        '''
        result = self._values.get("psk_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosIpsecServerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosIpv4Gateway(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosIpv4Gateway",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::Ipv4Gateway``, which is used to create an IPv4 gateway.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``Ipv4Gateway`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv4gateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosIpv4GatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6775d223fccfaf997b77ce974ba9934c751482737ded173733dea3f41be8593a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a42c34bb32a2fca3f221903f8810755c1640f2e938ed02b0d10d047fe3d0f7b9)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrCreateTime")
    def attr_create_time(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: CreateTime: The creation time of the resource.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrCreateTime"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv4GatewayDescription")
    def attr_ipv4_gateway_description(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Ipv4GatewayDescription: Description information.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv4GatewayDescription"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv4GatewayId")
    def attr_ipv4_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Ipv4GatewayId: The resource attribute field that represents the resource level 1 ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv4GatewayId"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv4GatewayName")
    def attr_ipv4_gateway_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Ipv4GatewayName: Resource name.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv4GatewayName"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv4GatewayRouteTableId")
    def attr_ipv4_gateway_route_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Ipv4GatewayRouteTableId: ID of the route table associated with IPv4 Gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv4GatewayRouteTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpcId: The ID of the VPC associated with the IPv4 Gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpcId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6573962f0bcf872bf3172e1557e3b28131edce500e790d7a510c1ed0797dffb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the VPC associated with the IPv4 Gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c00212c13f21071adb3ba51341b1ac91375a4eb5a5a76fc4e9ad46b062d4be3b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcId", value)

    @builtins.property
    @jsii.member(jsii_name="ipv4GatewayDescription")
    def ipv4_gateway_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipv4GatewayDescription: Description information.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ipv4GatewayDescription"))

    @ipv4_gateway_description.setter
    def ipv4_gateway_description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a2badab1ac1e74cc034b1bbac3762c1e6610d9a96b8bfc89e6f1f8596915de6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipv4GatewayDescription", value)

    @builtins.property
    @jsii.member(jsii_name="ipv4GatewayName")
    def ipv4_gateway_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipv4GatewayName: Resource name.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ipv4GatewayName"))

    @ipv4_gateway_name.setter
    def ipv4_gateway_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f76e8b5b54afa6487172a388f8820a511dfd622044d4b7bff00ff9ddaded1000)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipv4GatewayName", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosIpv4GatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "ipv4_gateway_description": "ipv4GatewayDescription",
        "ipv4_gateway_name": "ipv4GatewayName",
    },
)
class RosIpv4GatewayProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ipv4_gateway_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ipv4_gateway_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosIpv4Gateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv4gateway

        :param vpc_id: 
        :param ipv4_gateway_description: 
        :param ipv4_gateway_name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__661a0a9571e24ad24f8e3004e976f7545bc14ea345b7db4a0b5c4b146285b2d9)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument ipv4_gateway_description", value=ipv4_gateway_description, expected_type=type_hints["ipv4_gateway_description"])
            check_type(argname="argument ipv4_gateway_name", value=ipv4_gateway_name, expected_type=type_hints["ipv4_gateway_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if ipv4_gateway_description is not None:
            self._values["ipv4_gateway_description"] = ipv4_gateway_description
        if ipv4_gateway_name is not None:
            self._values["ipv4_gateway_name"] = ipv4_gateway_name

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the VPC associated with the IPv4 Gateway.
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def ipv4_gateway_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipv4GatewayDescription: Description information.
        '''
        result = self._values.get("ipv4_gateway_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ipv4_gateway_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: ipv4GatewayName: Resource name.
        '''
        result = self._values.get("ipv4_gateway_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosIpv4GatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosIpv6Gateway(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosIpv6Gateway",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::Ipv6Gateway``, which is used to create an IPv6 gateway.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``Ipv6Gateway`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv6gateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosIpv6GatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63e281c935efddb0cbf1939d7aca5364c563b57a6b862cdacd6887e96ebe1122)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7ec8e2d390d25044153bb17f17b45fd59f1550ebebcb156e646034d6c253d02)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrIpv6GatewayId")
    def attr_ipv6_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Ipv6GatewayId: ID IPv6 gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpv6GatewayId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b237fc03f147e3d384b572868c18079537819428838ddf3f4b34cd9442a50dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: To open VPC ID IPv6 gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c96eb5c609681eb5eac00159ce2247c2fe16a44ed8239c19954979f21db68d76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcId", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: Description of IPv6 gateway.
        Length of 2 to 256 characters, must begin with a letter or Chinese, may contain numbers, numbers, underscore (_) and dot dash (-), but not at the http (.): // or https: // at the beginning .
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7fd3e6844422cdca212c8f91c09225b953a8cbdfae32ef56baf0cddc9b5b32bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: Name of the IPv6 gateway.
        Length of 2 to 128 characters, beginning with a letter or Chinese, can contain numbers, dot, underscore (_) and dash (-), but not at http (.): // or with https: // .
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c26c06d8d7bee01302f4a3a88d885b2374ad68cb08978463e2f469f90d3278b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="spec")
    def spec(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spec: Specifications IPv6 gateway, the value:
        Small (default): Free.
        Medium: Enterprise Edition.
        Large: Enterprise Enhanced Edition.
        Different specifications of the IPv6 forwarding capability of the gateway is different. For more information, see IPv6 gateway specification.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spec"))

    @spec.setter
    def spec(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d4caba20e15974143e40af3b97b69d03dcc1909af8cb2e940d7c6b9b86a6704)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spec", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosIpv6Gateway.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosIpv6Gateway.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosIpv6Gateway.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__636b76445d2bdc16b3144492fc47b8de9b94da622412e2a2ec1b3eb5fb78006d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosIpv6Gateway.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__143280a758b403aa15601be0eef4ea22bcd2d76189b09693b3f9f1fe95f7e86f)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosIpv6GatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "description": "description",
        "name": "name",
        "spec": "spec",
        "tags": "tags",
    },
)
class RosIpv6GatewayProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spec: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosIpv6Gateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosIpv6Gateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv6gateway

        :param vpc_id: 
        :param description: 
        :param name: 
        :param spec: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eba6f8115194022cca7a259645c031f8ec69365614d5d1c86034c1655e5b1521)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name
        if spec is not None:
            self._values["spec"] = spec
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: To open VPC ID IPv6 gateway.
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: Description of IPv6 gateway.
        Length of 2 to 256 characters, must begin with a letter or Chinese, may contain numbers, numbers, underscore (_) and dot dash (-), but not at the http (.): // or https: // at the beginning .
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: Name of the IPv6 gateway.
        Length of 2 to 128 characters, beginning with a letter or Chinese, can contain numbers, dot, underscore (_) and dash (-), but not at http (.): // or with https: // .
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spec(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        spec: Specifications IPv6 gateway, the value:
        Small (default): Free.
        Medium: Enterprise Edition.
        Large: Enterprise Enhanced Edition.
        Different specifications of the IPv6 forwarding capability of the gateway is different. For more information, see IPv6 gateway specification.
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosIpv6Gateway.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosIpv6Gateway.TagsProperty]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosIpv6GatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosIpv6InternetBandwidth(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosIpv6InternetBandwidth",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::Ipv6InternetBandwidth``, which is used to purchase Internet bandwidth for an IPv6 address.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``Ipv6InternetBandwidth`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv6internetbandwidth
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosIpv6InternetBandwidthProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75d94ae92b72e1f5d79493dc0be1c4be7d312087e2abec792245f9f612164b85)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c2bf3318415bbad119f2d9200747793cdf6a63be3be1785ab47a99d50551aa1)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrInternetBandwidthId")
    def attr_internet_bandwidth_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: InternetBandwidthId: Purchase of public network bandwidth.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInternetBandwidthId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="bandwidth")
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        bandwidth: Public IPv6 address of bandwidth, unit: Mbps, range: 1-5000.
        When InternetChargeType is PayByBandwidth, the bandwidth of the public network is the IPv6 address 1-5000.
        When InternetChargeType is PayByTraffic, public network bandwidth IPv6 addresses while IPv6 gateway restricted specifications.
        Small (default free version), the public network bandwidth range 1-500.
        Medium (Enterprise Edition), the public network bandwidth range from 1 to 1000.
        Large (Enterprise Edition), the public network bandwidth range 1-2000.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "bandwidth"))

    @bandwidth.setter
    def bandwidth(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36cd44c994568ac0041206df2b2a1d19a4b4068d9c056c72a60cdb71196ffebd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7783726b703d75e84c2781cf0c51292b5a83865a516310481547534ff59d62e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="ipv6AddressId")
    def ipv6_address_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: ipv6AddressId: ID of IPv6 address.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "ipv6AddressId"))

    @ipv6_address_id.setter
    def ipv6_address_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d50d817dcf1a17abe4d8d55adaf73166961a6c5e0ec3dc6e1e53d217712de814)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipv6AddressId", value)

    @builtins.property
    @jsii.member(jsii_name="ipv6GatewayId")
    def ipv6_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: ipv6GatewayId: ID of IPv6 gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "ipv6GatewayId"))

    @ipv6_gateway_id.setter
    def ipv6_gateway_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__977804e151e952e3d250144953a1e295407e1e2b0c901dac4310bc0cea77cb93)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipv6GatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetChargeType: IPv6 public network bandwidth billing, value:

        - **PayByTraffic**: by using the traffic accounting.
        - **PayByBandwidth** (default): Bandwidth billing.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetChargeType"))

    @internet_charge_type.setter
    def internet_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6cfcb36a5c1547cd413dc5444ef8a5ff9958ceb6e48c657da8084ea5e526cd4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetChargeType", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosIpv6InternetBandwidthProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "ipv6_address_id": "ipv6AddressId",
        "ipv6_gateway_id": "ipv6GatewayId",
        "internet_charge_type": "internetChargeType",
    },
)
class RosIpv6InternetBandwidthProps:
    def __init__(
        self,
        *,
        bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        ipv6_address_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        ipv6_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosIpv6InternetBandwidth``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-ipv6internetbandwidth

        :param bandwidth: 
        :param ipv6_address_id: 
        :param ipv6_gateway_id: 
        :param internet_charge_type: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6839650da0dcf6f69f533fedfdb73d40a5412ad4fde7a257ff3f7adb9a112719)
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument ipv6_address_id", value=ipv6_address_id, expected_type=type_hints["ipv6_address_id"])
            check_type(argname="argument ipv6_gateway_id", value=ipv6_gateway_id, expected_type=type_hints["ipv6_gateway_id"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bandwidth": bandwidth,
            "ipv6_address_id": ipv6_address_id,
            "ipv6_gateway_id": ipv6_gateway_id,
        }
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        bandwidth: Public IPv6 address of bandwidth, unit: Mbps, range: 1-5000.
        When InternetChargeType is PayByBandwidth, the bandwidth of the public network is the IPv6 address 1-5000.
        When InternetChargeType is PayByTraffic, public network bandwidth IPv6 addresses while IPv6 gateway restricted specifications.
        Small (default free version), the public network bandwidth range 1-500.
        Medium (Enterprise Edition), the public network bandwidth range from 1 to 1000.
        Large (Enterprise Edition), the public network bandwidth range 1-2000.
        '''
        result = self._values.get("bandwidth")
        assert result is not None, "Required property 'bandwidth' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def ipv6_address_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: ipv6AddressId: ID of IPv6 address.
        '''
        result = self._values.get("ipv6_address_id")
        assert result is not None, "Required property 'ipv6_address_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def ipv6_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: ipv6GatewayId: ID of IPv6 gateway.
        '''
        result = self._values.get("ipv6_gateway_id")
        assert result is not None, "Required property 'ipv6_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetChargeType: IPv6 public network bandwidth billing, value:

        - **PayByTraffic**: by using the traffic accounting.
        - **PayByBandwidth** (default): Bandwidth billing.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosIpv6InternetBandwidthProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosNatGateway(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosNatGateway",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::NatGateway``, which is used to create a NAT gateway.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``NatGateway`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-natgateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosNatGatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3eeff1663dbd7f2dce25f8ef345418e4af3f54f7a2e58f60248324b73f0968e7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59eeea60ac38b56a67f680a6118d46c185f2c699a8c1a5ac669c0f6d285f4677)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrForwardTableId")
    def attr_forward_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ForwardTableId: The forward table id.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrForwardTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrNatGatewayId")
    def attr_nat_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: NatGatewayId: The Id of created NAT gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNatGatewayId"))

    @builtins.property
    @jsii.member(jsii_name="attrSNatTableId")
    def attr_s_nat_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: SNatTableId: The SNAT table id.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSNatTableId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f559e0fac0e3f317dcab22e74aecf1a4d105e84e35bb6b0e896c64128798e121)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The VPC id to create NAT gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c994326d67a359aae6687dcb41509ab205facf56e20337c4e3f3139aeb74df54)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcId", value)

    @builtins.property
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vSwitchId: The VSwitch id to create NAT gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vSwitchId"))

    @v_switch_id.setter
    def v_switch_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74ebf798e1a4b7518cc503f8e9dc01b0cacffc2ff709f5664bfa740d87775696)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vSwitchId", value)

    @builtins.property
    @jsii.member(jsii_name="autoPay")
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: autoPay: Specifies whether to enable automatic payment. Default is true.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoPay"))

    @auto_pay.setter
    def auto_pay(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e675700f7b5b99a35ae0c188b0f455960530a7b0d781f7b3ec797e5cb3e8a24)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoPay", value)

    @builtins.property
    @jsii.member(jsii_name="deletionForce")
    def deletion_force(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: deletionForce: Whether force delete the relative snat and dnat entries in the net gateway and unbind eips. Default value is false.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "deletionForce"))

    @deletion_force.setter
    def deletion_force(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5544fb8324d22421def5e61ab980355913823a7488b3447a253679d205fc62c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionForce", value)

    @builtins.property
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        deletionProtection: Whether to enable deletion protection.
        Default to False.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "deletionProtection"))

    @deletion_protection.setter
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7898f43b5512c17ea83be2fac9cf270c0b0b3514db494f951e1ff91923a70874)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionProtection", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Description of the NAT gateway, [2, 256] characters. Do not fill or empty, the default is empty.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5086b9a0d8d468850073d723bef8a4dc209c2d39bc7fdfdf07329a832a03f91)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="duration")
    def duration(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: duration: The subscription duration. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36. While choose pay by year, it could be from 1 to 3.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "duration"))

    @duration.setter
    def duration(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__189978d070bc2cc13e9fba174160609446dfb32c9cd79de0fe4f20f2db6f5923)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "duration", value)

    @builtins.property
    @jsii.member(jsii_name="eipBindMode")
    def eip_bind_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        eipBindMode: The mode in which the EIP is associated with the NAT gateway. Valid values:MULTI_BINDED (default): the multi-EIP-to-ENI mode.
        NAT: NAT mode. IPv4 gateways are supported.
        Note If the EIP is associated with the NAT gateway in NAT mode,
        the EIP occupies a private IP address of the vSwitch to which the NAT gateway belongs.
        Make sure that the vSwitch has sufficient private IP addresses.
        Otherwise, the EIP cannot be associated with the NAT gateway.
        In NAT mode, a maximum number of 50 EIPs can be associated with each NAT gateway.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "eipBindMode"))

    @eip_bind_mode.setter
    def eip_bind_mode(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d30f27bb3bfd287127c4edc5f8f665549e4872e02158cf2b50ab2d14c0f37cb6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "eipBindMode", value)

    @builtins.property
    @jsii.member(jsii_name="icmpReplyEnabled")
    def icmp_reply_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: icmpReplyEnabled: Specifies whether to enable the ICMP non-retrieval feature. Default: True
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "icmpReplyEnabled"))

    @icmp_reply_enabled.setter
    def icmp_reply_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12091018861781a0a3a19e6bd92620ac5500b7ecb2016e43c5c7b8fabc5d860d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "icmpReplyEnabled", value)

    @builtins.property
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: The billing method. The default value is PostPaid (which means pay-as-you-go).
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceChargeType"))

    @instance_charge_type.setter
    def instance_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a27a44562b4ba937b3b0626eca494357772cb1e7d24d51048d84b178926f342)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetChargeType: The billing method for the NAT gateway. Valid values:
        PayBySpec: billed on a pay-by-specification basis.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "internetChargeType"))

    @internet_charge_type.setter
    def internet_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__526b64355e9e8ce4fca91f88cf769b9680875f4d0d6e0dce4077c7ad28308dbe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internetChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="natGatewayName")
    def nat_gateway_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: natGatewayName: Display name of the NAT gateway, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "natGatewayName"))

    @nat_gateway_name.setter
    def nat_gateway_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bbc21355824c992bb0d6e16aeaf6f0aaaad7e38bee3a4e7883889837574bd426)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "natGatewayName", value)

    @builtins.property
    @jsii.member(jsii_name="natType")
    def nat_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        natType: The type of the NAT gateway. Valid values:

        - Enhanced: enhanced NAT gateway.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "natType"))

    @nat_type.setter
    def nat_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e4f771a19b61af1fc7fc3214138e200704e06d2c69352605598eeaf28a7216a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "natType", value)

    @builtins.property
    @jsii.member(jsii_name="networkType")
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        networkType: The type of the created NAT gateway.
        Internet: public network NAT gateway.
        Intranet: VPC NAT gateway.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "networkType"))

    @network_type.setter
    def network_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccee1062f7c3d86719979e5e2ac219135ac3c7337da79b2c2593f3da098acc58)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "networkType", value)

    @builtins.property
    @jsii.member(jsii_name="pricingCycle")
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pricingCycle: Price cycle of the resource. This property has no default value.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "pricingCycle"))

    @pricing_cycle.setter
    def pricing_cycle(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67eba9c67fbd58c4b7da58ecf1dfc79b5b1a76cd700f419e5a84e04ced2aa006)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pricingCycle", value)

    @builtins.property
    @jsii.member(jsii_name="securityProtectionEnabled")
    def security_protection_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: securityProtectionEnabled: Specifies whether to enable the firewall feature. Default: False
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "securityProtectionEnabled"))

    @security_protection_enabled.setter
    def security_protection_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9f2de05c73d678d01a15fd5a22e9dc0cb212ce9ab503bf042f99dc150f4c457)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityProtectionEnabled", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosNatGateway.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to natgateway. Max support 20 tags to add during create natgateway. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosNatGateway.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosNatGateway.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df283d334859db1381fd76ca969362ba26ae9952317ce5009625ff0920680308)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosNatGateway.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6f3a5242480f89ae8149b8638b2e65cde5c6dfe860d84e5baff2961e3ba61202)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosNatGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "v_switch_id": "vSwitchId",
        "auto_pay": "autoPay",
        "deletion_force": "deletionForce",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "duration": "duration",
        "eip_bind_mode": "eipBindMode",
        "icmp_reply_enabled": "icmpReplyEnabled",
        "instance_charge_type": "instanceChargeType",
        "internet_charge_type": "internetChargeType",
        "nat_gateway_name": "natGatewayName",
        "nat_type": "natType",
        "network_type": "networkType",
        "pricing_cycle": "pricingCycle",
        "security_protection_enabled": "securityProtectionEnabled",
        "tags": "tags",
    },
)
class RosNatGatewayProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_force: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        duration: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        eip_bind_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        icmp_reply_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        nat_gateway_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        nat_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        security_protection_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosNatGateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosNatGateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-natgateway

        :param vpc_id: 
        :param v_switch_id: 
        :param auto_pay: 
        :param deletion_force: 
        :param deletion_protection: 
        :param description: 
        :param duration: 
        :param eip_bind_mode: 
        :param icmp_reply_enabled: 
        :param instance_charge_type: 
        :param internet_charge_type: 
        :param nat_gateway_name: 
        :param nat_type: 
        :param network_type: 
        :param pricing_cycle: 
        :param security_protection_enabled: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aeedcf0fae3964ffd6c19c0f15745ca820a29691cdd258d3637ed72d31ceaa35)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument deletion_force", value=deletion_force, expected_type=type_hints["deletion_force"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument duration", value=duration, expected_type=type_hints["duration"])
            check_type(argname="argument eip_bind_mode", value=eip_bind_mode, expected_type=type_hints["eip_bind_mode"])
            check_type(argname="argument icmp_reply_enabled", value=icmp_reply_enabled, expected_type=type_hints["icmp_reply_enabled"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument internet_charge_type", value=internet_charge_type, expected_type=type_hints["internet_charge_type"])
            check_type(argname="argument nat_gateway_name", value=nat_gateway_name, expected_type=type_hints["nat_gateway_name"])
            check_type(argname="argument nat_type", value=nat_type, expected_type=type_hints["nat_type"])
            check_type(argname="argument network_type", value=network_type, expected_type=type_hints["network_type"])
            check_type(argname="argument pricing_cycle", value=pricing_cycle, expected_type=type_hints["pricing_cycle"])
            check_type(argname="argument security_protection_enabled", value=security_protection_enabled, expected_type=type_hints["security_protection_enabled"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
            "v_switch_id": v_switch_id,
        }
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if deletion_force is not None:
            self._values["deletion_force"] = deletion_force
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if duration is not None:
            self._values["duration"] = duration
        if eip_bind_mode is not None:
            self._values["eip_bind_mode"] = eip_bind_mode
        if icmp_reply_enabled is not None:
            self._values["icmp_reply_enabled"] = icmp_reply_enabled
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if nat_gateway_name is not None:
            self._values["nat_gateway_name"] = nat_gateway_name
        if nat_type is not None:
            self._values["nat_type"] = nat_type
        if network_type is not None:
            self._values["network_type"] = network_type
        if pricing_cycle is not None:
            self._values["pricing_cycle"] = pricing_cycle
        if security_protection_enabled is not None:
            self._values["security_protection_enabled"] = security_protection_enabled
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The VPC id to create NAT gateway.
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vSwitchId: The VSwitch id to create NAT gateway.
        '''
        result = self._values.get("v_switch_id")
        assert result is not None, "Required property 'v_switch_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: autoPay: Specifies whether to enable automatic payment. Default is true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_force(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: deletionForce: Whether force delete the relative snat and dnat entries in the net gateway and unbind eips. Default value is false.
        '''
        result = self._values.get("deletion_force")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        deletionProtection: Whether to enable deletion protection.
        Default to False.
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Description of the NAT gateway, [2, 256] characters. Do not fill or empty, the default is empty.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def duration(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: duration: The subscription duration. While choose by pay by month, it could be from 1 to 9 or 12, 24, 36. While choose pay by year, it could be from 1 to 3.
        '''
        result = self._values.get("duration")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def eip_bind_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        eipBindMode: The mode in which the EIP is associated with the NAT gateway. Valid values:MULTI_BINDED (default): the multi-EIP-to-ENI mode.
        NAT: NAT mode. IPv4 gateways are supported.
        Note If the EIP is associated with the NAT gateway in NAT mode,
        the EIP occupies a private IP address of the vSwitch to which the NAT gateway belongs.
        Make sure that the vSwitch has sufficient private IP addresses.
        Otherwise, the EIP cannot be associated with the NAT gateway.
        In NAT mode, a maximum number of 50 EIPs can be associated with each NAT gateway.
        '''
        result = self._values.get("eip_bind_mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def icmp_reply_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: icmpReplyEnabled: Specifies whether to enable the ICMP non-retrieval feature. Default: True
        '''
        result = self._values.get("icmp_reply_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: The billing method. The default value is PostPaid (which means pay-as-you-go).
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def internet_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        internetChargeType: The billing method for the NAT gateway. Valid values:
        PayBySpec: billed on a pay-by-specification basis.
        '''
        result = self._values.get("internet_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def nat_gateway_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: natGatewayName: Display name of the NAT gateway, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        '''
        result = self._values.get("nat_gateway_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def nat_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        natType: The type of the NAT gateway. Valid values:

        - Enhanced: enhanced NAT gateway.
        '''
        result = self._values.get("nat_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        networkType: The type of the created NAT gateway.
        Internet: public network NAT gateway.
        Intranet: VPC NAT gateway.
        '''
        result = self._values.get("network_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pricingCycle: Price cycle of the resource. This property has no default value.
        '''
        result = self._values.get("pricing_cycle")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def security_protection_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: securityProtectionEnabled: Specifies whether to enable the firewall feature. Default: False
        '''
        result = self._values.get("security_protection_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosNatGateway.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to natgateway. Max support 20 tags to add during create natgateway. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosNatGateway.TagsProperty]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosNatGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosNatIp(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosNatIp",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::NatIp``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``NatIp`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-natip
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosNatIpProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fd201909473a60d9f8f361c6a5b6c9e060b11d49f70b9cf433351e4cd82691b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__907f796efd4f0a10a932a4b55d802bf630f6ddfd782fc6be44f141c19f74fb98)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrNatIp")
    def attr_nat_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: NatIp: NAT IP address.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNatIp"))

    @builtins.property
    @jsii.member(jsii_name="attrNatIpId")
    def attr_nat_ip_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: NatIpId: The ID of the NAT IP address.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNatIpId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce05e7e00ab4e40e08618dbcd7a48ef7dbc5d80b995caebbd0476e7e7c5f06a9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="natGatewayId")
    def nat_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        natGatewayId: The ID of the Virtual Private Cloud (VPC) NAT gateway for which you want to create
        the NAT IP address.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "natGatewayId"))

    @nat_gateway_id.setter
    def nat_gateway_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__362e9d87f9194177a12e3882926c3c1e8efc3ddaef6d740c49a1ae4016d8f4d8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "natGatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="natIpCidr")
    def nat_ip_cidr(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: natIpCidr: The CIDR block to which the NAT IP address belongs.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "natIpCidr"))

    @nat_ip_cidr.setter
    def nat_ip_cidr(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2178666fe35874f2d61d5e8a7d81f61273765cd9c8818c9d67cb9408b7aa7688)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "natIpCidr", value)

    @builtins.property
    @jsii.member(jsii_name="natIpDescription")
    def nat_ip_description(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        natIpDescription: The description of the NAT IP address.
        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "natIpDescription"))

    @nat_ip_description.setter
    def nat_ip_description(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__488e511f10e83bd3551b1d22b0ed4e085a7326a1133384dfdc36fbbe66fbf020)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "natIpDescription", value)

    @builtins.property
    @jsii.member(jsii_name="natIpName")
    def nat_ip_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        natIpName: The name of the NAT IP address.
        The name must be 2 to 128 characters in length, and can contain letters, digits, periods
        (.), underscores (_), and hyphens (-). It must start with a letter. It cannot start
        with http:// or https://.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "natIpName"))

    @nat_ip_name.setter
    def nat_ip_name(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__470972f306e6efaa95d8804451eff78df671d5189f475901a2d56169beb66901)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "natIpName", value)

    @builtins.property
    @jsii.member(jsii_name="natIp")
    def nat_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        natIp: The NAT IP address that you want to create.
        If you do not specify an IP address, the system selects a random IP address from the
        specified CIDR block.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "natIp"))

    @nat_ip.setter
    def nat_ip(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11ed51250d681abcf59bc6a8f6e5d9b3871a69d188ad72793ec1bc15d4dd5a77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "natIp", value)

    @builtins.property
    @jsii.member(jsii_name="natIpCidrId")
    def nat_ip_cidr_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: natIpCidrId: The ID of the CIDR block to which the NAT IP address belongs.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "natIpCidrId"))

    @nat_ip_cidr_id.setter
    def nat_ip_cidr_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__085af50101bb198f34f7d3df4a4726c3be5a39fc01dd63cd56e4cc4d4ccdf166)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "natIpCidrId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosNatIpProps",
    jsii_struct_bases=[],
    name_mapping={
        "nat_gateway_id": "natGatewayId",
        "nat_ip_cidr": "natIpCidr",
        "nat_ip_description": "natIpDescription",
        "nat_ip_name": "natIpName",
        "nat_ip": "natIp",
        "nat_ip_cidr_id": "natIpCidrId",
    },
)
class RosNatIpProps:
    def __init__(
        self,
        *,
        nat_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        nat_ip_cidr: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        nat_ip_description: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        nat_ip_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        nat_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        nat_ip_cidr_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosNatIp``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-natip

        :param nat_gateway_id: 
        :param nat_ip_cidr: 
        :param nat_ip_description: 
        :param nat_ip_name: 
        :param nat_ip: 
        :param nat_ip_cidr_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fae6508c09acb591857026b4b896acc6332abfb0a66064ebf46fec0c22bea3c9)
            check_type(argname="argument nat_gateway_id", value=nat_gateway_id, expected_type=type_hints["nat_gateway_id"])
            check_type(argname="argument nat_ip_cidr", value=nat_ip_cidr, expected_type=type_hints["nat_ip_cidr"])
            check_type(argname="argument nat_ip_description", value=nat_ip_description, expected_type=type_hints["nat_ip_description"])
            check_type(argname="argument nat_ip_name", value=nat_ip_name, expected_type=type_hints["nat_ip_name"])
            check_type(argname="argument nat_ip", value=nat_ip, expected_type=type_hints["nat_ip"])
            check_type(argname="argument nat_ip_cidr_id", value=nat_ip_cidr_id, expected_type=type_hints["nat_ip_cidr_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "nat_gateway_id": nat_gateway_id,
            "nat_ip_cidr": nat_ip_cidr,
            "nat_ip_description": nat_ip_description,
            "nat_ip_name": nat_ip_name,
        }
        if nat_ip is not None:
            self._values["nat_ip"] = nat_ip
        if nat_ip_cidr_id is not None:
            self._values["nat_ip_cidr_id"] = nat_ip_cidr_id

    @builtins.property
    def nat_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        natGatewayId: The ID of the Virtual Private Cloud (VPC) NAT gateway for which you want to create
        the NAT IP address.
        '''
        result = self._values.get("nat_gateway_id")
        assert result is not None, "Required property 'nat_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def nat_ip_cidr(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: natIpCidr: The CIDR block to which the NAT IP address belongs.
        '''
        result = self._values.get("nat_ip_cidr")
        assert result is not None, "Required property 'nat_ip_cidr' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def nat_ip_description(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        natIpDescription: The description of the NAT IP address.
        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        result = self._values.get("nat_ip_description")
        assert result is not None, "Required property 'nat_ip_description' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def nat_ip_name(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        natIpName: The name of the NAT IP address.
        The name must be 2 to 128 characters in length, and can contain letters, digits, periods
        (.), underscores (_), and hyphens (-). It must start with a letter. It cannot start
        with http:// or https://.
        '''
        result = self._values.get("nat_ip_name")
        assert result is not None, "Required property 'nat_ip_name' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def nat_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        natIp: The NAT IP address that you want to create.
        If you do not specify an IP address, the system selects a random IP address from the
        specified CIDR block.
        '''
        result = self._values.get("nat_ip")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def nat_ip_cidr_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: natIpCidrId: The ID of the CIDR block to which the NAT IP address belongs.
        '''
        result = self._values.get("nat_ip_cidr_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosNatIpProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosNetworkAcl(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosNetworkAcl",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::NetworkAcl``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``NetworkAcl`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-networkacl
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosNetworkAclProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__622c4f69a7f491ff7980c9d9abbf834934a8215b7192d49804d4965485f7949b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2303d4740563e970085a89714d1360406ca08e25aea9e80f4f673d1382aac9e7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrNetworkAclEntryName")
    def attr_network_acl_entry_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: NetworkAclEntryName: The name of the inbound rule.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNetworkAclEntryName"))

    @builtins.property
    @jsii.member(jsii_name="attrNetworkAclId")
    def attr_network_acl_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: NetworkAclId: The ID of the network ACL.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNetworkAclId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__687f07b2f042f8e6e4ad5d28e8929dd692438f7ce42b7d4b97df39c1233bad92)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the virtual private cloud (VPC) to which the network ACL belongs.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd84706106546ccf920d2a8e9f3a23d21d026855e09ddcd1f1d0690cc947d386)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcId", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the network ACL.
        The description must be 2 to 256 characters in length. The description must start
        with a letter but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ebab63dd08b4fe88937733d081709d741634142789c69d5ae7853efb54e26c66)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="egressAclEntries")
    def egress_acl_entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.EgressAclEntriesProperty"]]]]:
        '''
        :Property: egressAclEntries: The list of egress network ACL entries.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.EgressAclEntriesProperty"]]]], jsii.get(self, "egressAclEntries"))

    @egress_acl_entries.setter
    def egress_acl_entries(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.EgressAclEntriesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5580fec652b66f1131f4ef0e39047edf2454a7423907f42616564901863dc412)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "egressAclEntries", value)

    @builtins.property
    @jsii.member(jsii_name="ingressAclEntries")
    def ingress_acl_entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.IngressAclEntriesProperty"]]]]:
        '''
        :Property: ingressAclEntries: The list of ingress network ACL entries.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.IngressAclEntriesProperty"]]]], jsii.get(self, "ingressAclEntries"))

    @ingress_acl_entries.setter
    def ingress_acl_entries(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAcl.IngressAclEntriesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b60f9d19a2dcfbd2cb7a0fe4e07eef6a1c6354b5dd19a30290a43cf366f7564)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ingressAclEntries", value)

    @builtins.property
    @jsii.member(jsii_name="networkAclName")
    def network_acl_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        networkAclName: The name of the network ACL.
        The name must be 2 to 128 characters in length and can contain letters, digits, periods
        (.), underscores (_), and hyphens (-). The name must start with a letter and cannot
        start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "networkAclName"))

    @network_acl_name.setter
    def network_acl_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__993c4c64e524b2b8ba1154b4284a80076c13eff849a9742fadd1635b90ab5dd5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "networkAclName", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosNetworkAcl.EgressAclEntriesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "policy": "policy",
            "port": "port",
            "protocol": "protocol",
            "description": "description",
            "destination_cidr_ip": "destinationCidrIp",
            "entry_type": "entryType",
            "network_acl_entry_name": "networkAclEntryName",
        },
    )
    class EgressAclEntriesProperty:
        def __init__(
            self,
            *,
            policy: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            destination_cidr_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            entry_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            network_acl_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param policy: 
            :param port: 
            :param protocol: 
            :param description: 
            :param destination_cidr_ip: 
            :param entry_type: 
            :param network_acl_entry_name: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ebb506b1a5e75f4cf80323e7251b722a8e98277db7f27cc4488d7081b5619fa7)
                check_type(argname="argument policy", value=policy, expected_type=type_hints["policy"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument destination_cidr_ip", value=destination_cidr_ip, expected_type=type_hints["destination_cidr_ip"])
                check_type(argname="argument entry_type", value=entry_type, expected_type=type_hints["entry_type"])
                check_type(argname="argument network_acl_entry_name", value=network_acl_entry_name, expected_type=type_hints["network_acl_entry_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "policy": policy,
                "port": port,
                "protocol": protocol,
            }
            if description is not None:
                self._values["description"] = description
            if destination_cidr_ip is not None:
                self._values["destination_cidr_ip"] = destination_cidr_ip
            if entry_type is not None:
                self._values["entry_type"] = entry_type
            if network_acl_entry_name is not None:
                self._values["network_acl_entry_name"] = network_acl_entry_name

        @builtins.property
        def policy(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            policy: The authorization policy. Valid values:
            accept: access permissions granted.
            drop: access permissions denied.
            '''
            result = self._values.get("policy")
            assert result is not None, "Required property 'policy' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def port(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: port: The source ports. The value range is from 1 to 65535; setting formats such as "1/200" and "80/80", where "-1/-1" cannot be set individually, which means that the port is not restricted.
            '''
            result = self._values.get("port")
            assert result is not None, "Required property 'port' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def protocol(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            protocol: The transport layer protocols. Valid values:
            icmp
            gre
            tcp
            udp
            all: All protocols are supported.
            '''
            result = self._values.get("protocol")
            assert result is not None, "Required property 'protocol' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def description(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: description: The description of the egress entry.
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def destination_cidr_ip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: destinationCidrIp: Destination address network segment.
            '''
            result = self._values.get("destination_cidr_ip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def entry_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            entryType: The type of the rule. Valid values:
            custom : custom rules.
            system : system rules.
            '''
            result = self._values.get("entry_type")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def network_acl_entry_name(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: networkAclEntryName: The name of the egress entry.
            '''
            result = self._values.get("network_acl_entry_name")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EgressAclEntriesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosNetworkAcl.IngressAclEntriesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "policy": "policy",
            "port": "port",
            "protocol": "protocol",
            "description": "description",
            "entry_type": "entryType",
            "network_acl_entry_name": "networkAclEntryName",
            "source_cidr_ip": "sourceCidrIp",
        },
    )
    class IngressAclEntriesProperty:
        def __init__(
            self,
            *,
            policy: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            entry_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            network_acl_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            source_cidr_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param policy: 
            :param port: 
            :param protocol: 
            :param description: 
            :param entry_type: 
            :param network_acl_entry_name: 
            :param source_cidr_ip: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4f25cf51554fa08fe4c797bd365412748c3d0b6c930828f1ade1810a548a9d58)
                check_type(argname="argument policy", value=policy, expected_type=type_hints["policy"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument entry_type", value=entry_type, expected_type=type_hints["entry_type"])
                check_type(argname="argument network_acl_entry_name", value=network_acl_entry_name, expected_type=type_hints["network_acl_entry_name"])
                check_type(argname="argument source_cidr_ip", value=source_cidr_ip, expected_type=type_hints["source_cidr_ip"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "policy": policy,
                "port": port,
                "protocol": protocol,
            }
            if description is not None:
                self._values["description"] = description
            if entry_type is not None:
                self._values["entry_type"] = entry_type
            if network_acl_entry_name is not None:
                self._values["network_acl_entry_name"] = network_acl_entry_name
            if source_cidr_ip is not None:
                self._values["source_cidr_ip"] = source_cidr_ip

        @builtins.property
        def policy(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            policy: The authorization policy. Valid values:
            accept: access permissions granted.
            drop: access permissions denied.
            '''
            result = self._values.get("policy")
            assert result is not None, "Required property 'policy' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def port(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: port: The source ports. The value range is from 1 to 65535; setting formats such as "1/200" and "80/80", where "-1/-1" cannot be set individually, which means that the port is not restricted.
            '''
            result = self._values.get("port")
            assert result is not None, "Required property 'port' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def protocol(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            protocol: The transport layer protocols. Valid values:
            icmp
            gre
            tcp
            udp
            all: All protocols are supported.
            '''
            result = self._values.get("protocol")
            assert result is not None, "Required property 'protocol' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def description(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: description: The description of the ingress entry.
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def entry_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            entryType: The type of the rule. Valid values:
            custom : custom rules.
            system : system rules.
            '''
            result = self._values.get("entry_type")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def network_acl_entry_name(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: networkAclEntryName: The name of the ingress entry.
            '''
            result = self._values.get("network_acl_entry_name")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def source_cidr_ip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: sourceCidrIp: Source address network segment.
            '''
            result = self._values.get("source_cidr_ip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IngressAclEntriesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosNetworkAclAssociation(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosNetworkAclAssociation",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::NetworkAclAssociation``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``NetworkAclAssociation`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-networkaclassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosNetworkAclAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8039de8df49b84f7883ece4b24fd67f0971f5328389c02248bd8a92499db338)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74e296f9f655db9c8d83865e7aa2216c66967a180d860d763e2dcb73a9dad988)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrNetworkAclId")
    def attr_network_acl_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: NetworkAclId: The ID of the network ACL.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNetworkAclId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__765b5c0cc418716e29f144b0754429c6cea7189a6afb4afe0de109295e886a13)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="networkAclId")
    def network_acl_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: networkAclId: The ID of the network ACL.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "networkAclId"))

    @network_acl_id.setter
    def network_acl_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffc2d9dbb2437af9b732dcae2e2998138292252268c9a6d05c8e63c7e81cc2ca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "networkAclId", value)

    @builtins.property
    @jsii.member(jsii_name="resources")
    def resources(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAclAssociation.ResourcesProperty"]]]:
        '''
        :Property: resources: The list of resources that need to be associated with network ACL.
        '''
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAclAssociation.ResourcesProperty"]]], jsii.get(self, "resources"))

    @resources.setter
    def resources(
        self,
        value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosNetworkAclAssociation.ResourcesProperty"]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec6d19fb4afec95bb9c47398b6e13b548ad7d6507997444dc86e7da1314c86d1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resources", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosNetworkAclAssociation.ResourcesProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_id": "resourceId", "resource_type": "resourceType"},
    )
    class ResourcesProperty:
        def __init__(
            self,
            *,
            resource_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            resource_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param resource_id: 
            :param resource_type: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d0fd192e8362f9272c75caba5a9f2cc36599783380e1acd7d4c9fe4ba39dfa3b)
                check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "resource_id": resource_id,
            }
            if resource_type is not None:
                self._values["resource_type"] = resource_type

        @builtins.property
        def resource_id(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: resourceId: The ID of the associated resource.
            '''
            result = self._values.get("resource_id")
            assert result is not None, "Required property 'resource_id' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def resource_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: resourceType: The type of the associated resource. Valid value: VSwitch.
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ResourcesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosNetworkAclAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"network_acl_id": "networkAclId", "resources": "resources"},
)
class RosNetworkAclAssociationProps:
    def __init__(
        self,
        *,
        network_acl_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        resources: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAclAssociation.ResourcesProperty, typing.Dict[builtins.str, typing.Any]]]]],
    ) -> None:
        '''Properties for defining a ``RosNetworkAclAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-networkaclassociation

        :param network_acl_id: 
        :param resources: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44d1347f2a778e3c517a98af32f7835d3ade79c67b079286e830f9a001186c70)
            check_type(argname="argument network_acl_id", value=network_acl_id, expected_type=type_hints["network_acl_id"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_acl_id": network_acl_id,
            "resources": resources,
        }

    @builtins.property
    def network_acl_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: networkAclId: The ID of the network ACL.
        '''
        result = self._values.get("network_acl_id")
        assert result is not None, "Required property 'network_acl_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAclAssociation.ResourcesProperty]]]:
        '''
        :Property: resources: The list of resources that need to be associated with network ACL.
        '''
        result = self._values.get("resources")
        assert result is not None, "Required property 'resources' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAclAssociation.ResourcesProperty]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosNetworkAclAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosNetworkAclProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "description": "description",
        "egress_acl_entries": "egressAclEntries",
        "ingress_acl_entries": "ingressAclEntries",
        "network_acl_name": "networkAclName",
    },
)
class RosNetworkAclProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        egress_acl_entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAcl.EgressAclEntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ingress_acl_entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAcl.IngressAclEntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        network_acl_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosNetworkAcl``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-networkacl

        :param vpc_id: 
        :param description: 
        :param egress_acl_entries: 
        :param ingress_acl_entries: 
        :param network_acl_name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa3beeaabc3f2dfeab5d23ecff8281136e9e77081cd76f5596b05b9755d327f6)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument egress_acl_entries", value=egress_acl_entries, expected_type=type_hints["egress_acl_entries"])
            check_type(argname="argument ingress_acl_entries", value=ingress_acl_entries, expected_type=type_hints["ingress_acl_entries"])
            check_type(argname="argument network_acl_name", value=network_acl_name, expected_type=type_hints["network_acl_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if description is not None:
            self._values["description"] = description
        if egress_acl_entries is not None:
            self._values["egress_acl_entries"] = egress_acl_entries
        if ingress_acl_entries is not None:
            self._values["ingress_acl_entries"] = ingress_acl_entries
        if network_acl_name is not None:
            self._values["network_acl_name"] = network_acl_name

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the virtual private cloud (VPC) to which the network ACL belongs.
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the network ACL.
        The description must be 2 to 256 characters in length. The description must start
        with a letter but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def egress_acl_entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAcl.EgressAclEntriesProperty]]]]:
        '''
        :Property: egressAclEntries: The list of egress network ACL entries.
        '''
        result = self._values.get("egress_acl_entries")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAcl.EgressAclEntriesProperty]]]], result)

    @builtins.property
    def ingress_acl_entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAcl.IngressAclEntriesProperty]]]]:
        '''
        :Property: ingressAclEntries: The list of ingress network ACL entries.
        '''
        result = self._values.get("ingress_acl_entries")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAcl.IngressAclEntriesProperty]]]], result)

    @builtins.property
    def network_acl_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        networkAclName: The name of the network ACL.
        The name must be 2 to 128 characters in length and can contain letters, digits, periods
        (.), underscores (_), and hyphens (-). The name must start with a letter and cannot
        start with http:// or https://.
        '''
        result = self._values.get("network_acl_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosNetworkAclProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosPeeringRouterInterfaceBinding(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosPeeringRouterInterfaceBinding",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::PeeringRouterInterfaceBinding``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``PeeringRouterInterfaceBinding`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-peeringrouterinterfacebinding
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosPeeringRouterInterfaceBindingProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e1665849c32c5b6e7a6393e52a56b3e97e5597696cfe2a23e1868856df33e80)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bba5a5fbb286238d0e674162afe3b4858beb9c029babb6803c344c0077df5d1e)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrRouterInterfaceId")
    def attr_router_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouterInterfaceId: The RouterInterface ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouterInterfaceId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f03fbf29d1c199a4fc8c0ada8d45570d11cbee0bb31c33a53cf8b375dd273e2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeInterfaceId")
    def opposite_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: oppositeInterfaceId: The connection peer RouterInterface ID.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "oppositeInterfaceId"))

    @opposite_interface_id.setter
    def opposite_interface_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d5f4c911de936b9cbabafd0f95278dfb2f1af9ae0ad3faa86fb8829bd4b5379)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeInterfaceId", value)

    @builtins.property
    @jsii.member(jsii_name="routerInterfaceId")
    def router_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerInterfaceId: The RouterInterface is set the parameters of the connection peer RouterInterface.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routerInterfaceId"))

    @router_interface_id.setter
    def router_interface_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3579c235213a021e88d84b37c1cf07cb6bd278787935b54d897a4c1a7972e008)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routerInterfaceId", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeInterfaceOwnerId")
    def opposite_interface_owner_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeInterfaceOwnerId: Owner account ID of the connection peer RouterInterface.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "oppositeInterfaceOwnerId"))

    @opposite_interface_owner_id.setter
    def opposite_interface_owner_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b419770a58552171a6735890b526c25bf09b189368e98694ae90ec729a6bf194)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeInterfaceOwnerId", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeRouterId")
    def opposite_router_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeRouterId: Router ID of the connection peer RouterInterface.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "oppositeRouterId"))

    @opposite_router_id.setter
    def opposite_router_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f68630a96a326e2e86f690fe939df722f04a6ad922fb708ddde1069840b86a3a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeRouterId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosPeeringRouterInterfaceBindingProps",
    jsii_struct_bases=[],
    name_mapping={
        "opposite_interface_id": "oppositeInterfaceId",
        "router_interface_id": "routerInterfaceId",
        "opposite_interface_owner_id": "oppositeInterfaceOwnerId",
        "opposite_router_id": "oppositeRouterId",
    },
)
class RosPeeringRouterInterfaceBindingProps:
    def __init__(
        self,
        *,
        opposite_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        router_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        opposite_interface_owner_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_router_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosPeeringRouterInterfaceBinding``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-peeringrouterinterfacebinding

        :param opposite_interface_id: 
        :param router_interface_id: 
        :param opposite_interface_owner_id: 
        :param opposite_router_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1df84191911935a7ec43c18b4fd7d7e2d348c2f4f22795764638ee58ba802ff2)
            check_type(argname="argument opposite_interface_id", value=opposite_interface_id, expected_type=type_hints["opposite_interface_id"])
            check_type(argname="argument router_interface_id", value=router_interface_id, expected_type=type_hints["router_interface_id"])
            check_type(argname="argument opposite_interface_owner_id", value=opposite_interface_owner_id, expected_type=type_hints["opposite_interface_owner_id"])
            check_type(argname="argument opposite_router_id", value=opposite_router_id, expected_type=type_hints["opposite_router_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "opposite_interface_id": opposite_interface_id,
            "router_interface_id": router_interface_id,
        }
        if opposite_interface_owner_id is not None:
            self._values["opposite_interface_owner_id"] = opposite_interface_owner_id
        if opposite_router_id is not None:
            self._values["opposite_router_id"] = opposite_router_id

    @builtins.property
    def opposite_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: oppositeInterfaceId: The connection peer RouterInterface ID.
        '''
        result = self._values.get("opposite_interface_id")
        assert result is not None, "Required property 'opposite_interface_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerInterfaceId: The RouterInterface is set the parameters of the connection peer RouterInterface.
        '''
        result = self._values.get("router_interface_id")
        assert result is not None, "Required property 'router_interface_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def opposite_interface_owner_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeInterfaceOwnerId: Owner account ID of the connection peer RouterInterface.
        '''
        result = self._values.get("opposite_interface_owner_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_router_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeRouterId: Router ID of the connection peer RouterInterface.
        '''
        result = self._values.get("opposite_router_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosPeeringRouterInterfaceBindingProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosPeeringRouterInterfaceConnection(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosPeeringRouterInterfaceConnection",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::PeeringRouterInterfaceConnection``, which is used to initiate a router interface connection.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``PeeringRouterInterfaceConnection`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-peeringrouterinterfaceconnection
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosPeeringRouterInterfaceConnectionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44987bcfa8881c96364a50393025977b81586bc5994c2fb11ab8d0b75400c044)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dffed333b5496c34c44fe77999200ceb61f7029c219621863ecaf75cf2e02251)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrOppositeInterfaceId")
    def attr_opposite_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: OppositeInterfaceId: The receiver RouterInterface ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOppositeInterfaceId"))

    @builtins.property
    @jsii.member(jsii_name="attrRouterInterfaceId")
    def attr_router_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouterInterfaceId: The initiator RouterInterface ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouterInterfaceId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8af356424acf408973557bf1c99ea83975b6a849de82b646669963bcb61d8b73)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeInterfaceId")
    def opposite_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: oppositeInterfaceId: The Receiver RouterInterface ID to accept peer RouterInterface.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "oppositeInterfaceId"))

    @opposite_interface_id.setter
    def opposite_interface_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0bd6de685b38a094283568c9097ddc7a7145631560506476efef94df08c2204)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeInterfaceId", value)

    @builtins.property
    @jsii.member(jsii_name="routerInterfaceId")
    def router_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerInterfaceId: The Initiator RouterInterface ID to connect peer RouterInterface.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routerInterfaceId"))

    @router_interface_id.setter
    def router_interface_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb70baa7b925553d34ffb200ac619a100780e4aca99b4aca7824cc82646c5022)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routerInterfaceId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosPeeringRouterInterfaceConnectionProps",
    jsii_struct_bases=[],
    name_mapping={
        "opposite_interface_id": "oppositeInterfaceId",
        "router_interface_id": "routerInterfaceId",
    },
)
class RosPeeringRouterInterfaceConnectionProps:
    def __init__(
        self,
        *,
        opposite_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        router_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``RosPeeringRouterInterfaceConnection``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-peeringrouterinterfaceconnection

        :param opposite_interface_id: 
        :param router_interface_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c38589dc8a0481c1f9df83196bfb5965ff7fb938c0f6f4f0f5aa2290549b338)
            check_type(argname="argument opposite_interface_id", value=opposite_interface_id, expected_type=type_hints["opposite_interface_id"])
            check_type(argname="argument router_interface_id", value=router_interface_id, expected_type=type_hints["router_interface_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "opposite_interface_id": opposite_interface_id,
            "router_interface_id": router_interface_id,
        }

    @builtins.property
    def opposite_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: oppositeInterfaceId: The Receiver RouterInterface ID to accept peer RouterInterface.
        '''
        result = self._values.get("opposite_interface_id")
        assert result is not None, "Required property 'opposite_interface_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_interface_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerInterfaceId: The Initiator RouterInterface ID to connect peer RouterInterface.
        '''
        result = self._values.get("router_interface_id")
        assert result is not None, "Required property 'router_interface_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosPeeringRouterInterfaceConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosPrefixList(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosPrefixList",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::PrefixList``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``PrefixList`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-prefixlist
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosPrefixListProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ec0d7a63b277f3e0aa707a671dd212e4597b30b065974b1ab43020953991e2b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91f89452820776f65b4214d643e0b5dc4dff840bcaf4b17e4d87294b85dcb5c2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrCreateTime")
    def attr_create_time(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: CreateTime: The time when the prefix list was created.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrCreateTime"))

    @builtins.property
    @jsii.member(jsii_name="attrEntries")
    def attr_entries(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Entries: The CIDR address block list of the prefix list.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEntries"))

    @builtins.property
    @jsii.member(jsii_name="attrIpVersion")
    def attr_ip_version(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: IpVersion: The IP version of the prefix list.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIpVersion"))

    @builtins.property
    @jsii.member(jsii_name="attrMaxEntries")
    def attr_max_entries(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: MaxEntries: The maximum number of entries for CIDR address blocks in the prefix list.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrMaxEntries"))

    @builtins.property
    @jsii.member(jsii_name="attrOwnerId")
    def attr_owner_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: OwnerId: The Alibaba Cloud account (primary account) to which the prefix list belongs.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOwnerId"))

    @builtins.property
    @jsii.member(jsii_name="attrPrefixListDescription")
    def attr_prefix_list_description(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: PrefixListDescription: The description of the prefix list.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPrefixListDescription"))

    @builtins.property
    @jsii.member(jsii_name="attrPrefixListId")
    def attr_prefix_list_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: PrefixListId: The ID of the query Prefix List.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPrefixListId"))

    @builtins.property
    @jsii.member(jsii_name="attrPrefixListName")
    def attr_prefix_list_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: PrefixListName: The name of the prefix list.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPrefixListName"))

    @builtins.property
    @jsii.member(jsii_name="attrResourceGroupId")
    def attr_resource_group_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ResourceGroupId: The ID of the resource group to which the VPC belongs.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrResourceGroupId"))

    @builtins.property
    @jsii.member(jsii_name="attrShareType")
    def attr_share_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: ShareType: The share type of the prefix list.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrShareType"))

    @builtins.property
    @jsii.member(jsii_name="attrTags")
    def attr_tags(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Tags: The tags of PrefixList.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTags"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a106ecced8fd28041ed2d306e9379e30278a458b392a368e9fba4c9271791fc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="entries")
    def entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosPrefixList.EntriesProperty"]]]]:
        '''
        :Property: entries: The CIDR address block list of the prefix list.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosPrefixList.EntriesProperty"]]]], jsii.get(self, "entries"))

    @entries.setter
    def entries(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosPrefixList.EntriesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__191b93214c05c74170002701b8adb8d8c2c6f26e8c9b52ee442371041206d4aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "entries", value)

    @builtins.property
    @jsii.member(jsii_name="ipVersion")
    def ip_version(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        ipVersion: The IP version of the prefix list. Value:

        - **IPvv4**:IPv4 version.
        - **IPv6**:IPv6.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "ipVersion"))

    @ip_version.setter
    def ip_version(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__320790e7862009fbbda2d09158c18bf16b0728d1b67d52244719a082fba89ed1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipVersion", value)

    @builtins.property
    @jsii.member(jsii_name="maxEntries")
    def max_entries(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: maxEntries: The maximum number of entries for CIDR address blocks in the prefix list.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "maxEntries"))

    @max_entries.setter
    def max_entries(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f95cd11071a7502bbe262f8a96146d73a396c0417ffee6ced440f9740cb553cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxEntries", value)

    @builtins.property
    @jsii.member(jsii_name="prefixListDescription")
    def prefix_list_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        prefixListDescription: The description of the prefix list.
        It must be 2 to 256 characters in length and must start with a letter or Chinese, but cannot start with http:// or https.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "prefixListDescription"))

    @prefix_list_description.setter
    def prefix_list_description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18d67b830339f2737e74dd3b4931bfbdc29b04649eaf86ae2b303b18616b1349)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "prefixListDescription", value)

    @builtins.property
    @jsii.member(jsii_name="prefixListName")
    def prefix_list_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: prefixListName: The name of the prefix list.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "prefixListName"))

    @prefix_list_name.setter
    def prefix_list_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ee0e392c2022200b02734d320b50ab32518fda1b7e94726fbbfe6cc6b8bf9b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "prefixListName", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group to which the VPC belongs.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edcb2c1193e3093ad17ad068e7a26a4658232c134f162c1bf85184364822ab70)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosPrefixList.TagsProperty"]]:
        '''
        :Property: tags: Tags of prefix list.
        '''
        return typing.cast(typing.Optional[typing.List["RosPrefixList.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosPrefixList.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01af4571a0204bd67e53d8f0c85bdf49ace2ac82d462279bdcc52a55bdd0800c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosPrefixList.EntriesProperty",
        jsii_struct_bases=[],
        name_mapping={"cidr": "cidr", "description": "description"},
    )
    class EntriesProperty:
        def __init__(
            self,
            *,
            cidr: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param cidr: 
            :param description: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6df0a6005524d66a257e5a755f9db9c451e588c87cf35c0de5a46591d5d057dc)
                check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "cidr": cidr,
            }
            if description is not None:
                self._values["description"] = description

        @builtins.property
        def cidr(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: cidr: CIDR block.
            '''
            result = self._values.get("cidr")
            assert result is not None, "Required property 'cidr' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def description(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: description: The description of the CIDR entry.
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EntriesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosPrefixList.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f84115a7c06c086ff3540cf47e02a798cbdfb08ffb307699a9e0a5cad84f9b84)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosPrefixListProps",
    jsii_struct_bases=[],
    name_mapping={
        "entries": "entries",
        "ip_version": "ipVersion",
        "max_entries": "maxEntries",
        "prefix_list_description": "prefixListDescription",
        "prefix_list_name": "prefixListName",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
    },
)
class RosPrefixListProps:
    def __init__(
        self,
        *,
        entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosPrefixList.EntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ip_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        max_entries: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        prefix_list_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        prefix_list_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosPrefixList.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosPrefixList``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-prefixlist

        :param entries: 
        :param ip_version: 
        :param max_entries: 
        :param prefix_list_description: 
        :param prefix_list_name: 
        :param resource_group_id: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7710791c91f209e1de5aff535dcf0cb04d0295fc235c20976e01f10ef5fdd1ec)
            check_type(argname="argument entries", value=entries, expected_type=type_hints["entries"])
            check_type(argname="argument ip_version", value=ip_version, expected_type=type_hints["ip_version"])
            check_type(argname="argument max_entries", value=max_entries, expected_type=type_hints["max_entries"])
            check_type(argname="argument prefix_list_description", value=prefix_list_description, expected_type=type_hints["prefix_list_description"])
            check_type(argname="argument prefix_list_name", value=prefix_list_name, expected_type=type_hints["prefix_list_name"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if entries is not None:
            self._values["entries"] = entries
        if ip_version is not None:
            self._values["ip_version"] = ip_version
        if max_entries is not None:
            self._values["max_entries"] = max_entries
        if prefix_list_description is not None:
            self._values["prefix_list_description"] = prefix_list_description
        if prefix_list_name is not None:
            self._values["prefix_list_name"] = prefix_list_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def entries(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosPrefixList.EntriesProperty]]]]:
        '''
        :Property: entries: The CIDR address block list of the prefix list.
        '''
        result = self._values.get("entries")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosPrefixList.EntriesProperty]]]], result)

    @builtins.property
    def ip_version(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        ipVersion: The IP version of the prefix list. Value:

        - **IPvv4**:IPv4 version.
        - **IPv6**:IPv6.
        '''
        result = self._values.get("ip_version")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def max_entries(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: maxEntries: The maximum number of entries for CIDR address blocks in the prefix list.
        '''
        result = self._values.get("max_entries")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def prefix_list_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        prefixListDescription: The description of the prefix list.
        It must be 2 to 256 characters in length and must start with a letter or Chinese, but cannot start with http:// or https.
        '''
        result = self._values.get("prefix_list_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def prefix_list_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: prefixListName: The name of the prefix list.
        '''
        result = self._values.get("prefix_list_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group to which the VPC belongs.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosPrefixList.TagsProperty]]:
        '''
        :Property: tags: Tags of prefix list.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosPrefixList.TagsProperty]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosPrefixListProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosRouteTable(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosRouteTable",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::RouteTable``, which is used to create a custom route table.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``RouteTable`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routetable
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosRouteTableProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c983e5fa62c18a673ec2ac91cc2b03eda190f39d041227b336f1c605c23b08ab)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c50579c7181d2dda7d2f8e1941b3754de1918570cee38eab9f2744bfde13033a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouteTableId: The ID of the route table.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableName")
    def attr_route_table_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouteTableName: The name of the route table.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableName"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableType")
    def attr_route_table_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouteTableType: The type of the route table.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableType"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpcId: The ID of the VRouter to which the route table belongs.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpcId"))

    @builtins.property
    @jsii.member(jsii_name="attrVSwitchIds")
    def attr_v_switch_ids(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VSwitchIds: A list of VSwitches under the VPC.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVSwitchIds"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a7d1e0a29c5ae44cc88179d59c81145404c95c1e10d052b3020c610eb16400b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the VPC to which the custom route table belongs.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b3abf8fce028089276cd26de75ebc5fe61eed23a3b8da91546b31784ae349f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcId", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the route table.
        The description must be 2 to 256 characters in length. The description must start with a letter, but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e59ffed103d9684219aaea9783015d8b8065553aa3788cb2be11b87368ec56b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="routeTableName")
    def route_table_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        routeTableName: The name of the route table.
        The name must be 2 to 128 characters in length. It can contain letters, numbers, periods (.), underscores (_), and hyphens (-). It must start with a letter and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "routeTableName"))

    @route_table_name.setter
    def route_table_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13a836bdc828e1ccf1895c085166fdcb2e2d2ab785c0ffab023926b62cf4ac91)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routeTableName", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosRouteTable.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to routetable. Max support 20 tags to add during create routetable. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosRouteTable.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosRouteTable.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64405493076495669b45f0d55fccc85bf66982e1e688e3755e2c0b510e7e462b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosRouteTable.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__de1e44f50cbea952f53669efa37796254c56cc63683bcc8f287bd79eea0ccb0b)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosRouteTableAssociation(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosRouteTableAssociation",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::RouteTableAssociation``, which is used to associate a custom routing table with a vSwitch in the same VPC.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``RouteTableAssociation`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routetableassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosRouteTableAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ecf003c09bfde4acc8a6d76b57416c5b66f9784f58ddb2c40e2cbb0de709266)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93f6d103376daedd78c8e595eaecd89a62dd56f31ba44fd65ddfe672e1340636)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouteTableId: The ID of the route table.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrVSwitchId")
    def attr_v_switch_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VSwitchId: The VSwitch ID which the route table associated with.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVSwitchId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1afb2df34db1c5f8b97d58c0c1481a0a76c67055f2cfa4c00ebb4854e61379e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="routeTableId")
    def route_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routeTableId: The ID of the route table.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routeTableId"))

    @route_table_id.setter
    def route_table_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__667dbd07f4d3debda705c0b11540481f8b1595032df40e06c7cdf9cb57209754)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routeTableId", value)

    @builtins.property
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vSwitchId: The ID of the VSwitch.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vSwitchId"))

    @v_switch_id.setter
    def v_switch_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de8af07d8749130388e97c2ad8cc8c02c5e4d5cbdcaa1b08e47cea83179935eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vSwitchId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosRouteTableAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"route_table_id": "routeTableId", "v_switch_id": "vSwitchId"},
)
class RosRouteTableAssociationProps:
    def __init__(
        self,
        *,
        route_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``RosRouteTableAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routetableassociation

        :param route_table_id: 
        :param v_switch_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45fcbc12cc0f5a391d0cc3b05e3652b0bba95e21d8aea015c01e5d458cd95765)
            check_type(argname="argument route_table_id", value=route_table_id, expected_type=type_hints["route_table_id"])
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "route_table_id": route_table_id,
            "v_switch_id": v_switch_id,
        }

    @builtins.property
    def route_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routeTableId: The ID of the route table.
        '''
        result = self._values.get("route_table_id")
        assert result is not None, "Required property 'route_table_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vSwitchId: The ID of the VSwitch.
        '''
        result = self._values.get("v_switch_id")
        assert result is not None, "Required property 'v_switch_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosRouteTableAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosRouteTableProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "description": "description",
        "route_table_name": "routeTableName",
        "tags": "tags",
    },
)
class RosRouteTableProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        route_table_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosRouteTable.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosRouteTable``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routetable

        :param vpc_id: 
        :param description: 
        :param route_table_name: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c89452327d71974ccd5b1d69027c2a30b2e8e59fbb181b3c27271316c9b9035c)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument route_table_name", value=route_table_name, expected_type=type_hints["route_table_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if description is not None:
            self._values["description"] = description
        if route_table_name is not None:
            self._values["route_table_name"] = route_table_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the VPC to which the custom route table belongs.
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the route table.
        The description must be 2 to 256 characters in length. The description must start with a letter, but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def route_table_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        routeTableName: The name of the route table.
        The name must be 2 to 128 characters in length. It can contain letters, numbers, periods (.), underscores (_), and hyphens (-). It must start with a letter and cannot start with http:// or https://.
        '''
        result = self._values.get("route_table_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosRouteTable.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to routetable. Max support 20 tags to add during create routetable. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosRouteTable.TagsProperty]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosRouteTableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosRouterInterface(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosRouterInterface",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::RouterInterface``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``RouterInterface`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routerinterface
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosRouterInterfaceProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0172b4fe8788d7f2e2ec77329bc8fc6d9dba547567309178cf887d4939a35e7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b453b0c6eecebd94542509420c531b5485c80783416fffd08e868bc87c06c851)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrRouterInterfaceId")
    def attr_router_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouterInterfaceId: The ID of created RouterInterface.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouterInterfaceId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e40099305693c4850acc558eb3f9574fcb8b557cf04e5817e05c0a12a56a81a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="role")
    def role(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: role: RouterInterface role. Now support 'InitiatingSide|AcceptingSide'.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "role"))

    @role.setter
    def role(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e29cb2efc7c93ec0e7fee6563b8789a7947bd3ad004ebe8070a4af6e7cd64fd3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "role", value)

    @builtins.property
    @jsii.member(jsii_name="routerId")
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerId: The router ID to create RouterInterface.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routerId"))

    @router_id.setter
    def router_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f45c6adf9fd5f340fc25d01c4e9d7c39c753c532cedfe07d5cd678a20c5248a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routerId", value)

    @builtins.property
    @jsii.member(jsii_name="accessPointId")
    def access_point_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: accessPointId: Access point ID. If 'RouterType' is specified as 'VBR', the value is required.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "accessPointId"))

    @access_point_id.setter
    def access_point_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9260693a52272402bd07edc23c2c7b32273e201874ee04ecebe1f5bee8106d69)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "accessPointId", value)

    @builtins.property
    @jsii.member(jsii_name="autoPay")
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoPay: Indicates whether automatic payment is enabled. Valid values:
        false: Automatic payment is disabled. You need to go to Orders to make the payment once an order is generated.
        true: Automatic payment is enabled. The payment is automatically made.
        Default: true.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoPay"))

    @auto_pay.setter
    def auto_pay(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14233a945f438c0b1e2334791f42e9959e9103d764d44f132649a6403b4df1d2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoPay", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Custom description of the RouterInterface, [2, 256] characters. Don't fill or empty, the default is empty.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2824d5dafae8d523292a03eb733de601834c1e01433a3da2f187170bb92ce08f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="healthCheckSourceIp")
    def health_check_source_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: healthCheckSourceIp: Source IP address of the packet for leased line HealthCheck in leased line disaster tolerance and ECMP scenarios. It is valid only for a VRouter RouterInterface with a peer on a VBR. The source IP address must be in the VPC of the local VRouter and is not used. HealthCheckSourceIp and HealthCheckTargetIp parameters must be both specified or left unspecified.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "healthCheckSourceIp"))

    @health_check_source_ip.setter
    def health_check_source_ip(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2f6d37eabfa145d22bbcbf5d962ff01a1dcc4cc863f13bec3b4ba1f547bf2c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "healthCheckSourceIp", value)

    @builtins.property
    @jsii.member(jsii_name="healthCheckTargetIp")
    def health_check_target_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: healthCheckTargetIp: Target IP address of the packet for leased line HealthCheck in leased line disaster tolerance and ECMP scenarios. It is valid only for a VRouter RouterInterface with a peer on a VBR. Usually you can use the CPE IP address of the leased line user's client (that is, the PeerGatewayIP on the VBR of the peer RouterInterface), you can also specify another IP address of the leased line user's client as the HealthCheck target IP address. HealthCheckSourceIp and HealthCheckTargetIp parameters must be both specified or left unspecified.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "healthCheckTargetIp"))

    @health_check_target_ip.setter
    def health_check_target_ip(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5031a49d1b421b2551331d6577126b27ab8043604633d4f8f1e950b925e29996)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "healthCheckTargetIp", value)

    @builtins.property
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: The billing method of the router interface. Valid values: PrePaid (Subscription), PostPaid (default, Pay-As-You-Go)
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceChargeType"))

    @instance_charge_type.setter
    def instance_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87c219c02d0710711a029cc84c3eeee4d33ffc209fa59b021288754f7680a184)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: Custom name of the RouterInterface, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af8d854aa5b7136ff2e8bee97803a1f16246657cd30456e4f39db2b6b1bcbb36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeAccessPointId")
    def opposite_access_point_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeAccessPointId: Access point ID of the connection peer RouterInterface. If 'OppositeRouterType' is specified as 'VBR', the value is required.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "oppositeAccessPointId"))

    @opposite_access_point_id.setter
    def opposite_access_point_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc3d5fd4c379ef6ce626f77484fc2ab8db72d5e7d0647c0965afc672b5c4e71f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeAccessPointId", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeInterfaceId")
    def opposite_interface_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeInterfaceId: The ID of the peer router interface.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "oppositeInterfaceId"))

    @opposite_interface_id.setter
    def opposite_interface_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__180919bd10df0a75e82868e4f3c3e3edeb3f8273499b2605858b201c9532a5c0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeInterfaceId", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeInterfaceOwnerId")
    def opposite_interface_owner_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeInterfaceOwnerId: Owner account ID of the connection peer RouterInterface. The default value is current user Id.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "oppositeInterfaceOwnerId"))

    @opposite_interface_owner_id.setter
    def opposite_interface_owner_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13ed9c7056a510efffff5d4fc36583d7bef36f783aebd198d13d3b1ed1b2dee1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeInterfaceOwnerId", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeRegionId")
    def opposite_region_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeRegionId: The region where the connection peer RouterInterface locates. The default value is region where stack is created.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "oppositeRegionId"))

    @opposite_region_id.setter
    def opposite_region_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18ae85e63fc9e0a209e087fbc4f03ca4c9422835b0214ab8877097523aeb3b47)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeRegionId", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeRouterId")
    def opposite_router_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeRouterId: The router ID of the connection peer RouterInterface.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "oppositeRouterId"))

    @opposite_router_id.setter
    def opposite_router_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f4b994e361ac251ff161e25a1b6b7a61149e5141f3d3acddfd5ce4f70c9b645)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeRouterId", value)

    @builtins.property
    @jsii.member(jsii_name="oppositeRouterType")
    def opposite_router_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeRouterType: Router type of the connection peer router. Now support 'VRouter|VBR'. If 'RouterType' is specified as 'VBR', the value must be 'VRouter'.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "oppositeRouterType"))

    @opposite_router_type.setter
    def opposite_router_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c686b2ce39ef8727fa468d932106aeca83b27c78adb49b5c2e83f0c3ab45f877)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oppositeRouterType", value)

    @builtins.property
    @jsii.member(jsii_name="period")
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: period: Prepaid time period. It could be from 1 to 9 when PricingCycle is Month, or 1 to 3 when PricingCycle is Year.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "period"))

    @period.setter
    def period(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f4910a29f7b96ee34f1da9e7adbe3ddc39c26c2655488733e6b476e40654ea7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "period", value)

    @builtins.property
    @jsii.member(jsii_name="pricingCycle")
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pricingCycle: Unit of the payment cycle. It could be Month (default) or Year.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "pricingCycle"))

    @pricing_cycle.setter
    def pricing_cycle(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81ba94aece005b4ca8f43d3c62debc0b4c7a7d2a4cf68deecdbf27c6928e4c6f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pricingCycle", value)

    @builtins.property
    @jsii.member(jsii_name="routerType")
    def router_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: routerType: Router type. Now support 'VRouter|VBR'
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "routerType"))

    @router_type.setter
    def router_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2fc6cd4e3eb494e5b0ea9396bcfdcf59ef442f3803caceda9dbabdbe2d6273b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routerType", value)

    @builtins.property
    @jsii.member(jsii_name="spec")
    def spec(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: spec: RouterInterface specification. If 'Role' is specified as 'InitiatingSide', the value is required. If 'Role' is specified as 'AcceptingSide', the value is set as 'Negative' by default.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "spec"))

    @spec.setter
    def spec(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a656b98c1b9f6efd97ea8e796fcc33ae318630d9ab1e55a9240de7ccd568865b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spec", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosRouterInterfaceProps",
    jsii_struct_bases=[],
    name_mapping={
        "role": "role",
        "router_id": "routerId",
        "access_point_id": "accessPointId",
        "auto_pay": "autoPay",
        "description": "description",
        "health_check_source_ip": "healthCheckSourceIp",
        "health_check_target_ip": "healthCheckTargetIp",
        "instance_charge_type": "instanceChargeType",
        "name": "name",
        "opposite_access_point_id": "oppositeAccessPointId",
        "opposite_interface_id": "oppositeInterfaceId",
        "opposite_interface_owner_id": "oppositeInterfaceOwnerId",
        "opposite_region_id": "oppositeRegionId",
        "opposite_router_id": "oppositeRouterId",
        "opposite_router_type": "oppositeRouterType",
        "period": "period",
        "pricing_cycle": "pricingCycle",
        "router_type": "routerType",
        "spec": "spec",
    },
)
class RosRouterInterfaceProps:
    def __init__(
        self,
        *,
        role: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        access_point_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_source_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_target_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_access_point_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_interface_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_interface_owner_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_router_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_router_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        router_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spec: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosRouterInterface``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routerinterface

        :param role: 
        :param router_id: 
        :param access_point_id: 
        :param auto_pay: 
        :param description: 
        :param health_check_source_ip: 
        :param health_check_target_ip: 
        :param instance_charge_type: 
        :param name: 
        :param opposite_access_point_id: 
        :param opposite_interface_id: 
        :param opposite_interface_owner_id: 
        :param opposite_region_id: 
        :param opposite_router_id: 
        :param opposite_router_type: 
        :param period: 
        :param pricing_cycle: 
        :param router_type: 
        :param spec: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__341de5154ef1e750e1e8899deeb9deced0d0c25b4b577e27fdf45be0567cedec)
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument router_id", value=router_id, expected_type=type_hints["router_id"])
            check_type(argname="argument access_point_id", value=access_point_id, expected_type=type_hints["access_point_id"])
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument health_check_source_ip", value=health_check_source_ip, expected_type=type_hints["health_check_source_ip"])
            check_type(argname="argument health_check_target_ip", value=health_check_target_ip, expected_type=type_hints["health_check_target_ip"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument opposite_access_point_id", value=opposite_access_point_id, expected_type=type_hints["opposite_access_point_id"])
            check_type(argname="argument opposite_interface_id", value=opposite_interface_id, expected_type=type_hints["opposite_interface_id"])
            check_type(argname="argument opposite_interface_owner_id", value=opposite_interface_owner_id, expected_type=type_hints["opposite_interface_owner_id"])
            check_type(argname="argument opposite_region_id", value=opposite_region_id, expected_type=type_hints["opposite_region_id"])
            check_type(argname="argument opposite_router_id", value=opposite_router_id, expected_type=type_hints["opposite_router_id"])
            check_type(argname="argument opposite_router_type", value=opposite_router_type, expected_type=type_hints["opposite_router_type"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument pricing_cycle", value=pricing_cycle, expected_type=type_hints["pricing_cycle"])
            check_type(argname="argument router_type", value=router_type, expected_type=type_hints["router_type"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "role": role,
            "router_id": router_id,
        }
        if access_point_id is not None:
            self._values["access_point_id"] = access_point_id
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if description is not None:
            self._values["description"] = description
        if health_check_source_ip is not None:
            self._values["health_check_source_ip"] = health_check_source_ip
        if health_check_target_ip is not None:
            self._values["health_check_target_ip"] = health_check_target_ip
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if name is not None:
            self._values["name"] = name
        if opposite_access_point_id is not None:
            self._values["opposite_access_point_id"] = opposite_access_point_id
        if opposite_interface_id is not None:
            self._values["opposite_interface_id"] = opposite_interface_id
        if opposite_interface_owner_id is not None:
            self._values["opposite_interface_owner_id"] = opposite_interface_owner_id
        if opposite_region_id is not None:
            self._values["opposite_region_id"] = opposite_region_id
        if opposite_router_id is not None:
            self._values["opposite_router_id"] = opposite_router_id
        if opposite_router_type is not None:
            self._values["opposite_router_type"] = opposite_router_type
        if period is not None:
            self._values["period"] = period
        if pricing_cycle is not None:
            self._values["pricing_cycle"] = pricing_cycle
        if router_type is not None:
            self._values["router_type"] = router_type
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def role(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: role: RouterInterface role. Now support 'InitiatingSide|AcceptingSide'.
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routerId: The router ID to create RouterInterface.
        '''
        result = self._values.get("router_id")
        assert result is not None, "Required property 'router_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def access_point_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: accessPointId: Access point ID. If 'RouterType' is specified as 'VBR', the value is required.
        '''
        result = self._values.get("access_point_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoPay: Indicates whether automatic payment is enabled. Valid values:
        false: Automatic payment is disabled. You need to go to Orders to make the payment once an order is generated.
        true: Automatic payment is enabled. The payment is automatically made.
        Default: true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: Custom description of the RouterInterface, [2, 256] characters. Don't fill or empty, the default is empty.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_source_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: healthCheckSourceIp: Source IP address of the packet for leased line HealthCheck in leased line disaster tolerance and ECMP scenarios. It is valid only for a VRouter RouterInterface with a peer on a VBR. The source IP address must be in the VPC of the local VRouter and is not used. HealthCheckSourceIp and HealthCheckTargetIp parameters must be both specified or left unspecified.
        '''
        result = self._values.get("health_check_source_ip")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_target_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: healthCheckTargetIp: Target IP address of the packet for leased line HealthCheck in leased line disaster tolerance and ECMP scenarios. It is valid only for a VRouter RouterInterface with a peer on a VBR. Usually you can use the CPE IP address of the leased line user's client (that is, the PeerGatewayIP on the VBR of the peer RouterInterface), you can also specify another IP address of the leased line user's client as the HealthCheck target IP address. HealthCheckSourceIp and HealthCheckTargetIp parameters must be both specified or left unspecified.
        '''
        result = self._values.get("health_check_target_ip")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: instanceChargeType: The billing method of the router interface. Valid values: PrePaid (Subscription), PostPaid (default, Pay-As-You-Go)
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: name: Custom name of the RouterInterface, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_access_point_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeAccessPointId: Access point ID of the connection peer RouterInterface. If 'OppositeRouterType' is specified as 'VBR', the value is required.
        '''
        result = self._values.get("opposite_access_point_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_interface_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeInterfaceId: The ID of the peer router interface.
        '''
        result = self._values.get("opposite_interface_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_interface_owner_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeInterfaceOwnerId: Owner account ID of the connection peer RouterInterface. The default value is current user Id.
        '''
        result = self._values.get("opposite_interface_owner_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_region_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeRegionId: The region where the connection peer RouterInterface locates. The default value is region where stack is created.
        '''
        result = self._values.get("opposite_region_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_router_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeRouterId: The router ID of the connection peer RouterInterface.
        '''
        result = self._values.get("opposite_router_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_router_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: oppositeRouterType: Router type of the connection peer router. Now support 'VRouter|VBR'. If 'RouterType' is specified as 'VBR', the value must be 'VRouter'.
        '''
        result = self._values.get("opposite_router_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: period: Prepaid time period. It could be from 1 to 9 when PricingCycle is Month, or 1 to 3 when PricingCycle is Year.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: pricingCycle: Unit of the payment cycle. It could be Month (default) or Year.
        '''
        result = self._values.get("pricing_cycle")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def router_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: routerType: Router type. Now support 'VRouter|VBR'
        '''
        result = self._values.get("router_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spec(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: spec: RouterInterface specification. If 'Role' is specified as 'InitiatingSide', the value is required. If 'Role' is specified as 'AcceptingSide', the value is set as 'Negative' by default.
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosRouterInterfaceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSnatEntry(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosSnatEntry",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::SnatEntry``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``SnatEntry`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-snatentry
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosSnatEntryProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a29c4c86acf16e2071a7122a1035b74679b83ea41e725f3c33ab39d015ff1dec)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83ad12473b17ec7dbf6e1c7d0d67f119c81c62b0ba2fdd42ae1a514ae38355e5)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrSnatEntryIds")
    def attr_snat_entry_ids(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: SnatEntryIds: The IDS of the SNAT entry.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSnatEntryIds"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12883c19a92383afb95ddb0606f7e795f7bc3fd88fcef024b1c5051f839cbfe2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="snatIp")
    def snat_ip(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: snatIp: The public IP address. Separate multiple EIPs with commas.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "snatIp"))

    @snat_ip.setter
    def snat_ip(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce77c957cd0b7613152702f62ca10dd1c590a9b9c0782d68926733620e01d639)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "snatIp", value)

    @builtins.property
    @jsii.member(jsii_name="snatTableId")
    def snat_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: snatTableId: The ID of the SNAT table.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "snatTableId"))

    @snat_table_id.setter
    def snat_table_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__537e4ac5aa3ed8553026b7b855f2123b8183f88523b8fc0b7b6c02d67c0e322d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "snatTableId", value)

    @builtins.property
    @jsii.member(jsii_name="eipAffinity")
    def eip_affinity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        eipAffinity: Specifies whether to enable EIP affinity. Valid values:
        0: no
        1: yes
        If EIP affinity is enabled and the SNAT entry is associated with multiple EIPs, a client uses the same EIP to access the Internet. Otherwise, the client uses an EIP selected from the associated EIPs to access the Internet.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "eipAffinity"))

    @eip_affinity.setter
    def eip_affinity(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__810843085eb2f6959e8be080411d9ad3aebc2715a02f70325d7414e780170135)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "eipAffinity", value)

    @builtins.property
    @jsii.member(jsii_name="snatEntryName")
    def snat_entry_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: snatEntryName: he name of the SNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "snatEntryName"))

    @snat_entry_name.setter
    def snat_entry_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d7e1672c0a8632d76ad3cc74a2faa08482587a404e16df04163439b066262b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "snatEntryName", value)

    @builtins.property
    @jsii.member(jsii_name="sourceCidr")
    def source_cidr(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: sourceCidr: Specifies the network segment of the switch. For example, 10.0.0.1/24. This parameter and the SourceVSwtichId parameter are mutually exclusive and cannot appear at the same time.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "sourceCidr"))

    @source_cidr.setter
    def source_cidr(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__378f6bc2c7a2f274742a63620bb64092a33477009365a8d89fceac920f9e13a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceCidr", value)

    @builtins.property
    @jsii.member(jsii_name="sourceVSwitchIds")
    def source_v_switch_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: sourceVSwitchIds: The ID of the VSwitch to access the Internet.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], jsii.get(self, "sourceVSwitchIds"))

    @source_v_switch_ids.setter
    def source_v_switch_ids(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f851a29102d15d13ec9f8992750126b6b74f49e45ee6fe69e325047800fffd9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceVSwitchIds", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosSnatEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "snat_ip": "snatIp",
        "snat_table_id": "snatTableId",
        "eip_affinity": "eipAffinity",
        "snat_entry_name": "snatEntryName",
        "source_cidr": "sourceCidr",
        "source_v_switch_ids": "sourceVSwitchIds",
    },
)
class RosSnatEntryProps:
    def __init__(
        self,
        *,
        snat_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        snat_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        eip_affinity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        snat_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        source_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        source_v_switch_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosSnatEntry``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-snatentry

        :param snat_ip: 
        :param snat_table_id: 
        :param eip_affinity: 
        :param snat_entry_name: 
        :param source_cidr: 
        :param source_v_switch_ids: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c7ce955789cfe72295d3e37f82c3c25976ddfd708f13c2211068342ebd5b9d4)
            check_type(argname="argument snat_ip", value=snat_ip, expected_type=type_hints["snat_ip"])
            check_type(argname="argument snat_table_id", value=snat_table_id, expected_type=type_hints["snat_table_id"])
            check_type(argname="argument eip_affinity", value=eip_affinity, expected_type=type_hints["eip_affinity"])
            check_type(argname="argument snat_entry_name", value=snat_entry_name, expected_type=type_hints["snat_entry_name"])
            check_type(argname="argument source_cidr", value=source_cidr, expected_type=type_hints["source_cidr"])
            check_type(argname="argument source_v_switch_ids", value=source_v_switch_ids, expected_type=type_hints["source_v_switch_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "snat_ip": snat_ip,
            "snat_table_id": snat_table_id,
        }
        if eip_affinity is not None:
            self._values["eip_affinity"] = eip_affinity
        if snat_entry_name is not None:
            self._values["snat_entry_name"] = snat_entry_name
        if source_cidr is not None:
            self._values["source_cidr"] = source_cidr
        if source_v_switch_ids is not None:
            self._values["source_v_switch_ids"] = source_v_switch_ids

    @builtins.property
    def snat_ip(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: snatIp: The public IP address. Separate multiple EIPs with commas.
        '''
        result = self._values.get("snat_ip")
        assert result is not None, "Required property 'snat_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def snat_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: snatTableId: The ID of the SNAT table.
        '''
        result = self._values.get("snat_table_id")
        assert result is not None, "Required property 'snat_table_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def eip_affinity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        eipAffinity: Specifies whether to enable EIP affinity. Valid values:
        0: no
        1: yes
        If EIP affinity is enabled and the SNAT entry is associated with multiple EIPs, a client uses the same EIP to access the Internet. Otherwise, the client uses an EIP selected from the associated EIPs to access the Internet.
        '''
        result = self._values.get("eip_affinity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def snat_entry_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: snatEntryName: he name of the SNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        '''
        result = self._values.get("snat_entry_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def source_cidr(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: sourceCidr: Specifies the network segment of the switch. For example, 10.0.0.1/24. This parameter and the SourceVSwtichId parameter are mutually exclusive and cannot appear at the same time.
        '''
        result = self._values.get("source_cidr")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def source_v_switch_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''
        :Property: sourceVSwitchIds: The ID of the VSwitch to access the Internet.
        '''
        result = self._values.get("source_v_switch_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSnatEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSslVpnClientCert(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosSslVpnClientCert",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::SslVpnClientCert``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``SslVpnClientCert`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-sslvpnclientcert
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosSslVpnClientCertProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__004dec61a0e1b465207ccfb1f30938b893a9765f396099149f7e0c0b0793f9c5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9794b1c126a18951d54cb1db8dac851b5e8a85c11f81c8be67071099e4566fe)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrSslVpnClientCertId")
    def attr_ssl_vpn_client_cert_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: SslVpnClientCertId: The ID of the client certificate.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSslVpnClientCertId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc240251efbb3bbfd997fd3a63b74b03cc76af11afbb06b6bcbb27177465ef85)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="sslVpnServerId")
    def ssl_vpn_server_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: sslVpnServerId: ID of the SSL-VPN server.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "sslVpnServerId"))

    @ssl_vpn_server_id.setter
    def ssl_vpn_server_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14c08a60bc7d90f0445506403bf1f1140d2b81efd79c9ce0dcac56fe0d523373)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sslVpnServerId", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the client certificate.
        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab30938e3b86c61cec638589b3f5e988255f5ab569188400dfccb4ddf1052f3e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosSslVpnClientCertProps",
    jsii_struct_bases=[],
    name_mapping={"ssl_vpn_server_id": "sslVpnServerId", "name": "name"},
)
class RosSslVpnClientCertProps:
    def __init__(
        self,
        *,
        ssl_vpn_server_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosSslVpnClientCert``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-sslvpnclientcert

        :param ssl_vpn_server_id: 
        :param name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__100476f5233363cf761fb887010f6118ca281652ff1b138d18fee5142dfca23b)
            check_type(argname="argument ssl_vpn_server_id", value=ssl_vpn_server_id, expected_type=type_hints["ssl_vpn_server_id"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ssl_vpn_server_id": ssl_vpn_server_id,
        }
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def ssl_vpn_server_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: sslVpnServerId: ID of the SSL-VPN server.
        '''
        result = self._values.get("ssl_vpn_server_id")
        assert result is not None, "Required property 'ssl_vpn_server_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the client certificate.
        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSslVpnClientCertProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSslVpnServer(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosSslVpnServer",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::SslVpnServer``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``SslVpnServer`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-sslvpnserver
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosSslVpnServerProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17e94676e406223e314936eb5da2f9e2f70632fb8aed72bea6b8f7299262c09b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29d95908144e9a4955879330fe90d7692ce8533decb60668d246a731b0868625)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrSslVpnServerId")
    def attr_ssl_vpn_server_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: SslVpnServerId: ID of the SSL-VPN server.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSslVpnServerId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="clientIpPool")
    def client_ip_pool(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        clientIpPool: It is the address segment that assigns the access address to the client virtual NIC. It does not refer to the existing intranet segment of the client.
        When the client accesses the local end through an SSL-VPN connection, the VPN gateway allocates an IP address to the client from the specified client network segment.
        The network segment cannot conflict with the LocalSubnet address segment.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "clientIpPool"))

    @client_ip_pool.setter
    def client_ip_pool(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83ac0b43fbeb2a6abe5ac5dff3a3b8586649a2a392131dac86598f8bd05892ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientIpPool", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7aff46ac7330d0ab6c7fd60811b3331e5af0cc5cb889bd81edc655d96d0e424)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="localSubnet")
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        localSubnet: Is the address segment that the client wants to access through an SSL-VPN connection.
        The local network segment can be the network segment of the VPC, the network segment of the switch, the network segment of the IDC interconnected by the leased line and the VPC, and the network segment of the cloud service such as RDS/OSS.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "localSubnet"))

    @local_subnet.setter
    def local_subnet(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71716a5e2778bdcc4bd29f196174c495a48aadb9a72c6b04f373229906824b17)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSubnet", value)

    @builtins.property
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: ID of the VPN gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpnGatewayId"))

    @vpn_gateway_id.setter
    def vpn_gateway_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9e0a244626e1dc57daf1418e408f0f43776331fa4445554901591bb8b4da1e7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpnGatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="cipher")
    def cipher(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        cipher: The encryption algorithm used by SSL-VPN. Value:
        AES-128-CBC (default) | AES-192-CBC | AES-256-CBC | none
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "cipher"))

    @cipher.setter
    def cipher(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adbb738bb09d3b5a728919f8611eb1ac0328b7339037925f1222236ee3ce8c87)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cipher", value)

    @builtins.property
    @jsii.member(jsii_name="compress")
    def compress(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: compress: Whether it is compressed.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "compress"))

    @compress.setter
    def compress(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae3078718f8c9f606e2de05158ff63efdb8d938f61779cadefe8e41178ef1275)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "compress", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the SSL-VPN server. The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-).
        But it can't start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1239ecf6e7d56ece02234b9c1c97b507a8f783e611661d65bbc14b0118419968)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        port: The port used by the SSL-VPN server. The default value is 1194. Cannot use the following ports:
        22, 2222, 22222, 9000, 9001, 9002, 7505, 80, 443, 53, 68, 123, 4510, 4560, 500, 4500
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "port"))

    @port.setter
    def port(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adb3e9d6cb3989334f2571680623df0d2398854c2e0a22a496e9a3086f615a27)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="proto")
    def proto(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: proto: The protocol used by the SSL-VPN server. Allowed values: UDP (default) | TCP.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "proto"))

    @proto.setter
    def proto(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e52e6679fbee877926d5ce90a8987f673f83579d4dc09b0b3cafaa2f6476a43)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "proto", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosSslVpnServerProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_ip_pool": "clientIpPool",
        "local_subnet": "localSubnet",
        "vpn_gateway_id": "vpnGatewayId",
        "cipher": "cipher",
        "compress": "compress",
        "name": "name",
        "port": "port",
        "proto": "proto",
    },
)
class RosSslVpnServerProps:
    def __init__(
        self,
        *,
        client_ip_pool: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        cipher: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        compress: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        proto: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosSslVpnServer``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-sslvpnserver

        :param client_ip_pool: 
        :param local_subnet: 
        :param vpn_gateway_id: 
        :param cipher: 
        :param compress: 
        :param name: 
        :param port: 
        :param proto: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a5d4b9c8bf49357bc26ce80aec9ee88bf55437a0e10ea13d9bbdcc36af42d23)
            check_type(argname="argument client_ip_pool", value=client_ip_pool, expected_type=type_hints["client_ip_pool"])
            check_type(argname="argument local_subnet", value=local_subnet, expected_type=type_hints["local_subnet"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument cipher", value=cipher, expected_type=type_hints["cipher"])
            check_type(argname="argument compress", value=compress, expected_type=type_hints["compress"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument proto", value=proto, expected_type=type_hints["proto"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_ip_pool": client_ip_pool,
            "local_subnet": local_subnet,
            "vpn_gateway_id": vpn_gateway_id,
        }
        if cipher is not None:
            self._values["cipher"] = cipher
        if compress is not None:
            self._values["compress"] = compress
        if name is not None:
            self._values["name"] = name
        if port is not None:
            self._values["port"] = port
        if proto is not None:
            self._values["proto"] = proto

    @builtins.property
    def client_ip_pool(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        clientIpPool: It is the address segment that assigns the access address to the client virtual NIC. It does not refer to the existing intranet segment of the client.
        When the client accesses the local end through an SSL-VPN connection, the VPN gateway allocates an IP address to the client from the specified client network segment.
        The network segment cannot conflict with the LocalSubnet address segment.
        '''
        result = self._values.get("client_ip_pool")
        assert result is not None, "Required property 'client_ip_pool' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        localSubnet: Is the address segment that the client wants to access through an SSL-VPN connection.
        The local network segment can be the network segment of the VPC, the network segment of the switch, the network segment of the IDC interconnected by the leased line and the VPC, and the network segment of the cloud service such as RDS/OSS.
        '''
        result = self._values.get("local_subnet")
        assert result is not None, "Required property 'local_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: ID of the VPN gateway.
        '''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def cipher(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        cipher: The encryption algorithm used by SSL-VPN. Value:
        AES-128-CBC (default) | AES-192-CBC | AES-256-CBC | none
        '''
        result = self._values.get("cipher")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def compress(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: compress: Whether it is compressed.
        '''
        result = self._values.get("compress")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the SSL-VPN server. The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-).
        But it can't start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def port(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        port: The port used by the SSL-VPN server. The default value is 1194. Cannot use the following ports:
        22, 2222, 22222, 9000, 9001, 9002, 7505, 80, 443, 53, 68, 123, 4510, 4560, 500, 4500
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def proto(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: proto: The protocol used by the SSL-VPN server. Allowed values: UDP (default) | TCP.
        '''
        result = self._values.get("proto")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSslVpnServerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosTrafficMirrorFilter(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorFilter",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::TrafficMirrorFilter``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``TrafficMirrorFilter`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorfilter
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosTrafficMirrorFilterProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90860213fdf5a5ee1aa4db4dec3397837e7bf73ce156f94a77f755850ae8467a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c861ea396182d75101d01adfa868eda379aebae8348eff79f9353500ea6293d7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrEgressRules")
    def attr_egress_rules(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: EgressRules: Egress rules.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEgressRules"))

    @builtins.property
    @jsii.member(jsii_name="attrIngressRules")
    def attr_ingress_rules(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: IngressRules: Ingress rules.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIngressRules"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficMirrorFilterDescription")
    def attr_traffic_mirror_filter_description(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: TrafficMirrorFilterDescription: The description of the filter.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficMirrorFilterDescription"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficMirrorFilterId")
    def attr_traffic_mirror_filter_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: TrafficMirrorFilterId: The ID of the filter.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficMirrorFilterId"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficMirrorFilterName")
    def attr_traffic_mirror_filter_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: TrafficMirrorFilterName: The name of the filter.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficMirrorFilterName"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__beb6261f3d63ef30a183ef5d0d69ab5f8be97d35f6fda0944364d76017b22b48)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="egressRules")
    def egress_rules(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosTrafficMirrorFilter.EgressRulesProperty"]]]]:
        '''
        :Property: egressRules: Egress rules.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosTrafficMirrorFilter.EgressRulesProperty"]]]], jsii.get(self, "egressRules"))

    @egress_rules.setter
    def egress_rules(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosTrafficMirrorFilter.EgressRulesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29eb6c4b9c7645d4a8dd80158ae19db340c3150a284f38094e341a6b41e0c70b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "egressRules", value)

    @builtins.property
    @jsii.member(jsii_name="ingressRules")
    def ingress_rules(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosTrafficMirrorFilter.IngressRulesProperty"]]]]:
        '''
        :Property: ingressRules: Ingress rules.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosTrafficMirrorFilter.IngressRulesProperty"]]]], jsii.get(self, "ingressRules"))

    @ingress_rules.setter
    def ingress_rules(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosTrafficMirrorFilter.IngressRulesProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5dd6feed0a783f2c3439bae3f950538c5672d86f75d8eb1d47fa03595a0efa2e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ingressRules", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorFilterDescription")
    def traffic_mirror_filter_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: trafficMirrorFilterDescription: The description of the filter. The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "trafficMirrorFilterDescription"))

    @traffic_mirror_filter_description.setter
    def traffic_mirror_filter_description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a949154a08825770ff11a17b81aa628ff79ec14e947ce8199f2240287eb1e020)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorFilterDescription", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorFilterName")
    def traffic_mirror_filter_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: trafficMirrorFilterName: The name of the filter.The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "trafficMirrorFilterName"))

    @traffic_mirror_filter_name.setter
    def traffic_mirror_filter_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66c2168abadd129ecce4d4bab1c569e36fa0bdcb866c7453834878d5076618ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorFilterName", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorFilter.EgressRulesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "action": "action",
            "protocol": "protocol",
            "destination_cidr_block": "destinationCidrBlock",
            "destination_port_range": "destinationPortRange",
            "priority": "priority",
            "source_cidr_block": "sourceCidrBlock",
            "source_port_range": "sourcePortRange",
        },
    )
    class EgressRulesProperty:
        def __init__(
            self,
            *,
            action: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            destination_cidr_block: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            destination_port_range: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            priority: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            source_cidr_block: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            source_port_range: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param action: 
            :param protocol: 
            :param destination_cidr_block: 
            :param destination_port_range: 
            :param priority: 
            :param source_cidr_block: 
            :param source_port_range: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5dc2bd744f6bf407dc46046d60ddd30911f669afe2996afe9e80e6f1c5ac9549)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
                check_type(argname="argument destination_port_range", value=destination_port_range, expected_type=type_hints["destination_port_range"])
                check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
                check_type(argname="argument source_cidr_block", value=source_cidr_block, expected_type=type_hints["source_cidr_block"])
                check_type(argname="argument source_port_range", value=source_port_range, expected_type=type_hints["source_port_range"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "action": action,
                "protocol": protocol,
            }
            if destination_cidr_block is not None:
                self._values["destination_cidr_block"] = destination_cidr_block
            if destination_port_range is not None:
                self._values["destination_port_range"] = destination_port_range
            if priority is not None:
                self._values["priority"] = priority
            if source_cidr_block is not None:
                self._values["source_cidr_block"] = source_cidr_block
            if source_port_range is not None:
                self._values["source_port_range"] = source_port_range

        @builtins.property
        def action(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            action: The action of the outbound rule. Valid values:
            accept: collects network traffic.
            drop: does not collect network traffic.
            '''
            result = self._values.get("action")
            assert result is not None, "Required property 'action' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def protocol(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            protocol: The protocol that is used by the outbound traffic to be mirrored. Valid values:
            ALL: all protocols
            ICMP: ICMP
            TCP: TCP
            UDP: User Datagram Protocol (UDP)
            '''
            result = self._values.get("protocol")
            assert result is not None, "Required property 'protocol' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def destination_cidr_block(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: destinationCidrBlock: The destination CIDR block of the outbound traffic.
            '''
            result = self._values.get("destination_cidr_block")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def destination_port_range(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: destinationPortRange: The destination port range of the outbound traffic. Valid values for a port: 1 to 65535. Separate the first port and the last port with a forward slash (/). Examples: 1/200 and 80/80. You cannot set this parameter to only -1/-1. The value -1/-1 specifies all ports.
            '''
            result = self._values.get("destination_port_range")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def priority(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: priority: The priority of the outbound rule. A smaller value specifies a higher priority..
            '''
            result = self._values.get("priority")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def source_cidr_block(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: sourceCidrBlock: The source CIDR block of the outbound traffic..
            '''
            result = self._values.get("source_cidr_block")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def source_port_range(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: sourcePortRange: The source port range of the outbound traffic. Valid values for a port: 1 to 65535. Separate the first port and the last port with a forward slash (/). Examples: 1/200 and 80/80. You cannot set this parameter to only -1/-1. The value -1/-1 specifies all ports.
            '''
            result = self._values.get("source_port_range")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EgressRulesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorFilter.IngressRulesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "action": "action",
            "protocol": "protocol",
            "destination_cidr_block": "destinationCidrBlock",
            "destination_port_range": "destinationPortRange",
            "priority": "priority",
            "source_cidr_block": "sourceCidrBlock",
            "source_port_range": "sourcePortRange",
        },
    )
    class IngressRulesProperty:
        def __init__(
            self,
            *,
            action: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            destination_cidr_block: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            destination_port_range: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            priority: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            source_cidr_block: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            source_port_range: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param action: 
            :param protocol: 
            :param destination_cidr_block: 
            :param destination_port_range: 
            :param priority: 
            :param source_cidr_block: 
            :param source_port_range: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6b22826ee5fd9c20dbd5e1282713fe9637f16969074522423111445785dfd532)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
                check_type(argname="argument destination_port_range", value=destination_port_range, expected_type=type_hints["destination_port_range"])
                check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
                check_type(argname="argument source_cidr_block", value=source_cidr_block, expected_type=type_hints["source_cidr_block"])
                check_type(argname="argument source_port_range", value=source_port_range, expected_type=type_hints["source_port_range"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "action": action,
                "protocol": protocol,
            }
            if destination_cidr_block is not None:
                self._values["destination_cidr_block"] = destination_cidr_block
            if destination_port_range is not None:
                self._values["destination_port_range"] = destination_port_range
            if priority is not None:
                self._values["priority"] = priority
            if source_cidr_block is not None:
                self._values["source_cidr_block"] = source_cidr_block
            if source_port_range is not None:
                self._values["source_port_range"] = source_port_range

        @builtins.property
        def action(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            action: The action of the inbound rule. Valid values:
            accept: collects network traffic.
            drop: does not collect network traffic.
            '''
            result = self._values.get("action")
            assert result is not None, "Required property 'action' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def protocol(
            self,
        ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property:

            protocol: The protocol that is used by the inbound traffic to be mirrored. Valid values:
            ALL: all protocols
            ICMP: ICMP
            TCP: TCP
            UDP: User Datagram Protocol (UDP)
            '''
            result = self._values.get("protocol")
            assert result is not None, "Required property 'protocol' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def destination_cidr_block(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: destinationCidrBlock: The destination CIDR block of the inbound traffic.
            '''
            result = self._values.get("destination_cidr_block")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def destination_port_range(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: destinationPortRange: The destination port range of the inbound traffic. Valid values for a port: 1 to 65535. Separate the first port and the last port with a forward slash (/). Examples: 1/200 and 80/80.
            '''
            result = self._values.get("destination_port_range")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def priority(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: priority: The priority of the inbound rule. A smaller value specifies a higher priority..
            '''
            result = self._values.get("priority")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def source_cidr_block(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: sourceCidrBlock: The source CIDR block of the inbound traffic..
            '''
            result = self._values.get("source_cidr_block")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def source_port_range(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: sourcePortRange: The source port range of the inbound traffic. Valid values for a port: 1 to 65535. Separate the first port and the last port with a forward slash (/). Examples: 1/200 and 80/80.
            '''
            result = self._values.get("source_port_range")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IngressRulesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorFilterProps",
    jsii_struct_bases=[],
    name_mapping={
        "egress_rules": "egressRules",
        "ingress_rules": "ingressRules",
        "traffic_mirror_filter_description": "trafficMirrorFilterDescription",
        "traffic_mirror_filter_name": "trafficMirrorFilterName",
    },
)
class RosTrafficMirrorFilterProps:
    def __init__(
        self,
        *,
        egress_rules: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosTrafficMirrorFilter.EgressRulesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ingress_rules: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosTrafficMirrorFilter.IngressRulesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        traffic_mirror_filter_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        traffic_mirror_filter_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosTrafficMirrorFilter``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorfilter

        :param egress_rules: 
        :param ingress_rules: 
        :param traffic_mirror_filter_description: 
        :param traffic_mirror_filter_name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d084b0cb62301a9ce20bcab1b4fd5817878b2b09c84db35808468413474283b4)
            check_type(argname="argument egress_rules", value=egress_rules, expected_type=type_hints["egress_rules"])
            check_type(argname="argument ingress_rules", value=ingress_rules, expected_type=type_hints["ingress_rules"])
            check_type(argname="argument traffic_mirror_filter_description", value=traffic_mirror_filter_description, expected_type=type_hints["traffic_mirror_filter_description"])
            check_type(argname="argument traffic_mirror_filter_name", value=traffic_mirror_filter_name, expected_type=type_hints["traffic_mirror_filter_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if egress_rules is not None:
            self._values["egress_rules"] = egress_rules
        if ingress_rules is not None:
            self._values["ingress_rules"] = ingress_rules
        if traffic_mirror_filter_description is not None:
            self._values["traffic_mirror_filter_description"] = traffic_mirror_filter_description
        if traffic_mirror_filter_name is not None:
            self._values["traffic_mirror_filter_name"] = traffic_mirror_filter_name

    @builtins.property
    def egress_rules(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.EgressRulesProperty]]]]:
        '''
        :Property: egressRules: Egress rules.
        '''
        result = self._values.get("egress_rules")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.EgressRulesProperty]]]], result)

    @builtins.property
    def ingress_rules(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.IngressRulesProperty]]]]:
        '''
        :Property: ingressRules: Ingress rules.
        '''
        result = self._values.get("ingress_rules")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.IngressRulesProperty]]]], result)

    @builtins.property
    def traffic_mirror_filter_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: trafficMirrorFilterDescription: The description of the filter. The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("traffic_mirror_filter_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def traffic_mirror_filter_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: trafficMirrorFilterName: The name of the filter.The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("traffic_mirror_filter_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosTrafficMirrorFilterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosTrafficMirrorSession(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorSession",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::TrafficMirrorSession``DATASOURCE::VPC::NatGateways is used to query NAT gateways.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``TrafficMirrorSession`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorsession
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosTrafficMirrorSessionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a938adb2e557843985b0558776db25d239754c877c1d817ed092791a760800cd)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8b7f2b788db8c48a529c3015ed6bb8875b6274fc81c3345733a28becad04193)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficMirrorSessionId")
    def attr_traffic_mirror_session_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: TrafficMirrorSessionId: The ID of the traffic mirror session.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficMirrorSessionId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__121aa9d93f01a24212187690202fe6cbb727b35a24ac6dde8256354d615d58c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="priority")
    def priority(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        priority: The priority of the traffic mirror session. Valid values: **1 to 32766**.
        A smaller value indicates a higher priority. You cannot specify identical priorities for traffic mirror sessions that are created in the same region by using the same account.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "priority"))

    @priority.setter
    def priority(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de84ac732217fdbd20744c7dc527c29077eba88a2d2da7d907707d77d67c8494)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "priority", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorFilterId")
    def traffic_mirror_filter_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: trafficMirrorFilterId: The ID of the filter.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "trafficMirrorFilterId"))

    @traffic_mirror_filter_id.setter
    def traffic_mirror_filter_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f39408732a10859ebe3171c16b7c7e05831c84cfca85098e6e56284430a8960)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorFilterId", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorSourceIds")
    def traffic_mirror_source_ids(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''
        :Property: trafficMirrorSourceIds: undefined
        '''
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], jsii.get(self, "trafficMirrorSourceIds"))

    @traffic_mirror_source_ids.setter
    def traffic_mirror_source_ids(
        self,
        value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c020c9b058f9355d0392b04b80f006a2bea004a7c85b0f02ebfa8dda1169b645)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorSourceIds", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorTargetId")
    def traffic_mirror_target_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: trafficMirrorTargetId: The ID of the traffic mirror destination. You can specify only an elastic network interface (ENI) or a Server Load Balancer (SLB) instance as a traffic mirror destination.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "trafficMirrorTargetId"))

    @traffic_mirror_target_id.setter
    def traffic_mirror_target_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__538283a5bfcb15675e5700433617206b8e857b1cb48069255ed781f511dd4ba9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorTargetId", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorTargetType")
    def traffic_mirror_target_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        trafficMirrorTargetType: The type of the traffic mirror destination. Valid values:

        - **NetworkInterface**: an ENI
        - **SLB**: an SLB instance
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "trafficMirrorTargetType"))

    @traffic_mirror_target_type.setter
    def traffic_mirror_target_type(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72f906e96d7f6670b25a3c8e6af7caa76fc643b8672455c90ef0a2e24363b76a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorTargetType", value)

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enabled: Specifies whether to enable the traffic mirror session. Valid values:

        - **false** (default): does not enable the traffic mirror session.
        - **true**: enables the traffic mirror session.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__531c7d7b743cf560b0f55aebcdaa15e5406cedc6cde2c0812ad17f74837a08a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value)

    @builtins.property
    @jsii.member(jsii_name="packetLength")
    def packet_length(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: packetLength: The maximum transmission unit (MTU). Default value: **1500**.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "packetLength"))

    @packet_length.setter
    def packet_length(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76aa6da3bc5c3f76edd326ae707460f2422cfcc823e9f70e650302b01bb553cf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "packetLength", value)

    @builtins.property
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group to which the mirrored traffic belongs.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "resourceGroupId"))

    @resource_group_id.setter
    def resource_group_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7807de63aa595e43f6793eb483ad64b0d95d467009be65aa89c7e0b80230c1b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="tag")
    def tag(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, _ros_cdk_core_7adfd82f.RosTag]]]]:
        '''
        :Property: tag:
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, _ros_cdk_core_7adfd82f.RosTag]]]], jsii.get(self, "tag"))

    @tag.setter
    def tag(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, _ros_cdk_core_7adfd82f.RosTag]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfaea2d9d267aa2d110f06847b498bf5cf2a0ed601794038fcde70794f53aeae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tag", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorSessionDescription")
    def traffic_mirror_session_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        trafficMirrorSessionDescription: The description of the traffic mirror session.
        The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "trafficMirrorSessionDescription"))

    @traffic_mirror_session_description.setter
    def traffic_mirror_session_description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__603ff654620a07ec7c580d018ced2002a98654a6997ef68fccfc6500da641d10)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorSessionDescription", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorSessionName")
    def traffic_mirror_session_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        trafficMirrorSessionName: The name of the traffic mirror session.
        The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "trafficMirrorSessionName"))

    @traffic_mirror_session_name.setter
    def traffic_mirror_session_name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34b15d6d997652fc52f689353c2c6658c93db1a34c97286ff8ccbb33bc296db8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorSessionName", value)

    @builtins.property
    @jsii.member(jsii_name="virtualNetworkId")
    def virtual_network_id(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        virtualNetworkId: The VXLAN network identifier (VNI). Valid values: **0 to 16777215**.
        You can use VNIs to identify mirrored traffic from different sessions at the traffic mirror destination. You can specify a custom VNI or use a random VNI allocated by the system. If you want the system to randomly allocate a VNI, do not enter a value.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "virtualNetworkId"))

    @virtual_network_id.setter
    def virtual_network_id(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__978d07a83fa2a200bc125e8092b6f27becb079e25fa3309f406b22bc097c714a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "virtualNetworkId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorSession.TagProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__79ad37e4fbcdb8c44bdd18dfd21a742bbad10d107315f75b0e63a9eae79373a2)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorSessionProps",
    jsii_struct_bases=[],
    name_mapping={
        "priority": "priority",
        "traffic_mirror_filter_id": "trafficMirrorFilterId",
        "traffic_mirror_source_ids": "trafficMirrorSourceIds",
        "traffic_mirror_target_id": "trafficMirrorTargetId",
        "traffic_mirror_target_type": "trafficMirrorTargetType",
        "enabled": "enabled",
        "packet_length": "packetLength",
        "resource_group_id": "resourceGroupId",
        "tag": "tag",
        "traffic_mirror_session_description": "trafficMirrorSessionDescription",
        "traffic_mirror_session_name": "trafficMirrorSessionName",
        "virtual_network_id": "virtualNetworkId",
    },
)
class RosTrafficMirrorSessionProps:
    def __init__(
        self,
        *,
        priority: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_mirror_filter_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_mirror_source_ids: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
        traffic_mirror_target_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_mirror_target_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        packet_length: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tag: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[_ros_cdk_core_7adfd82f.RosTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        traffic_mirror_session_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        traffic_mirror_session_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        virtual_network_id: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosTrafficMirrorSession``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorsession

        :param priority: 
        :param traffic_mirror_filter_id: 
        :param traffic_mirror_source_ids: 
        :param traffic_mirror_target_id: 
        :param traffic_mirror_target_type: 
        :param enabled: 
        :param packet_length: 
        :param resource_group_id: 
        :param tag: 
        :param traffic_mirror_session_description: 
        :param traffic_mirror_session_name: 
        :param virtual_network_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c55d075fc34721d8b6b1dfc9bd1faef1d051112dc8aad8d380eb7bf2cffedac8)
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
            check_type(argname="argument traffic_mirror_filter_id", value=traffic_mirror_filter_id, expected_type=type_hints["traffic_mirror_filter_id"])
            check_type(argname="argument traffic_mirror_source_ids", value=traffic_mirror_source_ids, expected_type=type_hints["traffic_mirror_source_ids"])
            check_type(argname="argument traffic_mirror_target_id", value=traffic_mirror_target_id, expected_type=type_hints["traffic_mirror_target_id"])
            check_type(argname="argument traffic_mirror_target_type", value=traffic_mirror_target_type, expected_type=type_hints["traffic_mirror_target_type"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument packet_length", value=packet_length, expected_type=type_hints["packet_length"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
            check_type(argname="argument traffic_mirror_session_description", value=traffic_mirror_session_description, expected_type=type_hints["traffic_mirror_session_description"])
            check_type(argname="argument traffic_mirror_session_name", value=traffic_mirror_session_name, expected_type=type_hints["traffic_mirror_session_name"])
            check_type(argname="argument virtual_network_id", value=virtual_network_id, expected_type=type_hints["virtual_network_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "priority": priority,
            "traffic_mirror_filter_id": traffic_mirror_filter_id,
            "traffic_mirror_source_ids": traffic_mirror_source_ids,
            "traffic_mirror_target_id": traffic_mirror_target_id,
            "traffic_mirror_target_type": traffic_mirror_target_type,
        }
        if enabled is not None:
            self._values["enabled"] = enabled
        if packet_length is not None:
            self._values["packet_length"] = packet_length
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tag is not None:
            self._values["tag"] = tag
        if traffic_mirror_session_description is not None:
            self._values["traffic_mirror_session_description"] = traffic_mirror_session_description
        if traffic_mirror_session_name is not None:
            self._values["traffic_mirror_session_name"] = traffic_mirror_session_name
        if virtual_network_id is not None:
            self._values["virtual_network_id"] = virtual_network_id

    @builtins.property
    def priority(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        priority: The priority of the traffic mirror session. Valid values: **1 to 32766**.
        A smaller value indicates a higher priority. You cannot specify identical priorities for traffic mirror sessions that are created in the same region by using the same account.
        '''
        result = self._values.get("priority")
        assert result is not None, "Required property 'priority' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_mirror_filter_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: trafficMirrorFilterId: The ID of the filter.
        '''
        result = self._values.get("traffic_mirror_filter_id")
        assert result is not None, "Required property 'traffic_mirror_filter_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_mirror_source_ids(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''
        :Property: trafficMirrorSourceIds: undefined
        '''
        result = self._values.get("traffic_mirror_source_ids")
        assert result is not None, "Required property 'traffic_mirror_source_ids' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], result)

    @builtins.property
    def traffic_mirror_target_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: trafficMirrorTargetId: The ID of the traffic mirror destination. You can specify only an elastic network interface (ENI) or a Server Load Balancer (SLB) instance as a traffic mirror destination.
        '''
        result = self._values.get("traffic_mirror_target_id")
        assert result is not None, "Required property 'traffic_mirror_target_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_mirror_target_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        trafficMirrorTargetType: The type of the traffic mirror destination. Valid values:

        - **NetworkInterface**: an ENI
        - **SLB**: an SLB instance
        '''
        result = self._values.get("traffic_mirror_target_type")
        assert result is not None, "Required property 'traffic_mirror_target_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enabled: Specifies whether to enable the traffic mirror session. Valid values:

        - **false** (default): does not enable the traffic mirror session.
        - **true**: enables the traffic mirror session.
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def packet_length(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: packetLength: The maximum transmission unit (MTU). Default value: **1500**.
        '''
        result = self._values.get("packet_length")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: resourceGroupId: The ID of the resource group to which the mirrored traffic belongs.
        '''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tag(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, _ros_cdk_core_7adfd82f.RosTag]]]]:
        '''
        :Property: tag:
        '''
        result = self._values.get("tag")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, _ros_cdk_core_7adfd82f.RosTag]]]], result)

    @builtins.property
    def traffic_mirror_session_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        trafficMirrorSessionDescription: The description of the traffic mirror session.
        The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("traffic_mirror_session_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def traffic_mirror_session_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        trafficMirrorSessionName: The name of the traffic mirror session.
        The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("traffic_mirror_session_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def virtual_network_id(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        virtualNetworkId: The VXLAN network identifier (VNI). Valid values: **0 to 16777215**.
        You can use VNIs to identify mirrored traffic from different sessions at the traffic mirror destination. You can specify a custom VNI or use a random VNI allocated by the system. If you want the system to randomly allocate a VNI, do not enter a value.
        '''
        result = self._values.get("virtual_network_id")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosTrafficMirrorSessionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosTrafficMirrorSessionSourcesAddition(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorSessionSourcesAddition",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::TrafficMirrorSessionSourcesAddition``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``TrafficMirrorSessionSourcesAddition`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorsessionsourcesaddition
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosTrafficMirrorSessionSourcesAdditionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9d52017ebfda21175e16ba5292e7b84987cccb16f6a1e6817e10c9a1918ea72)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61a3765017104a10136e69e405bbc79d98d1b7f2dc13ea34343fdb3ad13174fe)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__852893a63b01db314402792fec09c46df24ed09d320b395be01c15e6e31c85cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorSessionId")
    def traffic_mirror_session_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: trafficMirrorSessionId: The ID of the traffic mirror session.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "trafficMirrorSessionId"))

    @traffic_mirror_session_id.setter
    def traffic_mirror_session_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__572c041101c20681b4f0efa35adefe8d664cda9739577e465db884322052dd9f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorSessionId", value)

    @builtins.property
    @jsii.member(jsii_name="trafficMirrorSourceIds")
    def traffic_mirror_source_ids(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''
        :Property: trafficMirrorSourceIds: undefined
        '''
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], jsii.get(self, "trafficMirrorSourceIds"))

    @traffic_mirror_source_ids.setter
    def traffic_mirror_source_ids(
        self,
        value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbac35c7a438cc82f3d0603f84baa2bc3cd63e7928929b00ff3fd6824c25eecc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "trafficMirrorSourceIds", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosTrafficMirrorSessionSourcesAdditionProps",
    jsii_struct_bases=[],
    name_mapping={
        "traffic_mirror_session_id": "trafficMirrorSessionId",
        "traffic_mirror_source_ids": "trafficMirrorSourceIds",
    },
)
class RosTrafficMirrorSessionSourcesAdditionProps:
    def __init__(
        self,
        *,
        traffic_mirror_session_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_mirror_source_ids: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    ) -> None:
        '''Properties for defining a ``RosTrafficMirrorSessionSourcesAddition``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorsessionsourcesaddition

        :param traffic_mirror_session_id: 
        :param traffic_mirror_source_ids: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38c902af49c5b3bfbc7ca1916bb3c32daa878812a2b55966232d52c59f161d50)
            check_type(argname="argument traffic_mirror_session_id", value=traffic_mirror_session_id, expected_type=type_hints["traffic_mirror_session_id"])
            check_type(argname="argument traffic_mirror_source_ids", value=traffic_mirror_source_ids, expected_type=type_hints["traffic_mirror_source_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "traffic_mirror_session_id": traffic_mirror_session_id,
            "traffic_mirror_source_ids": traffic_mirror_source_ids,
        }

    @builtins.property
    def traffic_mirror_session_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: trafficMirrorSessionId: The ID of the traffic mirror session.
        '''
        result = self._values.get("traffic_mirror_session_id")
        assert result is not None, "Required property 'traffic_mirror_session_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_mirror_source_ids(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''
        :Property: trafficMirrorSourceIds: undefined
        '''
        result = self._values.get("traffic_mirror_source_ids")
        assert result is not None, "Required property 'traffic_mirror_source_ids' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosTrafficMirrorSessionSourcesAdditionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVirtualBorderRouter(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosVirtualBorderRouter",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::VirtualBorderRouter``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``VirtualBorderRouter`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-virtualborderrouter
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosVirtualBorderRouterProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c63753b07470adbe636d5634390c4586a0bb089f47eb1f611f9395f5f9e2aaf)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d213a55ed2f5189579f24075a6d2d2851fa94c3433c24fea5cf36c07df11962d)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrName")
    def attr_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Name: The name of the VBR.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrName"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouteTableId: The ID of the route table of the VBR.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrVbrId")
    def attr_vbr_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VbrId: The ID of the VBR.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVbrId"))

    @builtins.property
    @jsii.member(jsii_name="attrVlanInterfaceId")
    def attr_vlan_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VlanInterfaceId: The ID of the VBR interface.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVlanInterfaceId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2994d02cc406342fcd6efff7c7a54abf23fe69ee70df8f18e34f931b3fe1052d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="localGatewayIp")
    def local_gateway_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: localGatewayIp: The IP address of the VBR on the Alibaba Cloud side.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "localGatewayIp"))

    @local_gateway_ip.setter
    def local_gateway_ip(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e3666b766584811fb55066fbdf833e28afc14f5d487a11be2301034316b3831)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localGatewayIp", value)

    @builtins.property
    @jsii.member(jsii_name="peerGatewayIp")
    def peer_gateway_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        peerGatewayIp: The IP address of the peer router interface of the VBR.
        Only the owner of the VBR can set or modify the value.
        This parameter is required when you create a VBR for the owner of the physical connection.
        You can ignore this parameter when you create a VBR for another Alibaba Cloud account.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "peerGatewayIp"))

    @peer_gateway_ip.setter
    def peer_gateway_ip(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84a8f14336c7d587a436f9947ddb52fdc2c3ca13271121bc19ce0bc60a46ffe6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "peerGatewayIp", value)

    @builtins.property
    @jsii.member(jsii_name="peeringSubnetMask")
    def peering_subnet_mask(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        peeringSubnetMask: The subnet mask for the IP addresses of the VBR on the Alibaba Cloud side and on the
        user side.
        The two IP addresses must fall within the same subnet.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "peeringSubnetMask"))

    @peering_subnet_mask.setter
    def peering_subnet_mask(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71f0bd3a2172dead36d2e5ff11a45f99015a08c2e33f8226bb1e487fcafff795)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "peeringSubnetMask", value)

    @builtins.property
    @jsii.member(jsii_name="physicalConnectionId")
    def physical_connection_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: physicalConnectionId: The ID of the physical connection.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "physicalConnectionId"))

    @physical_connection_id.setter
    def physical_connection_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86c38b806a1010087db3b24b3b902e83942c205338f914554824671de54151f9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "physicalConnectionId", value)

    @builtins.property
    @jsii.member(jsii_name="vlanId")
    def vlan_id(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        vlanId: The VLAN ID of the VBR. Valid values: 0 to 2999.
        Note Only the owner of the physical connection can set this parameter. The VLAN IDs of
        two VBRs of the same physical connection must be different.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vlanId"))

    @vlan_id.setter
    def vlan_id(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2b6a41299c56716fd7e4f81af3a18c9996d38bf0c1c85253d42141cad83f768)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vlanId", value)

    @builtins.property
    @jsii.member(jsii_name="circuitCode")
    def circuit_code(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        circuitCode: The circuit code provided by the Internet service provider (ISP) for the physical
        connection.
        Note Only the owner of the physical connection can set this parameter.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "circuitCode"))

    @circuit_code.setter
    def circuit_code(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5756e2e21717acb28073574884a32735dca317b53f944e7359e07b128314028)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "circuitCode", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the VBR.
        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3087bbe3eb170d0fc636c24bf556030977dbb92c4a5f36bc4dadf97233b5394f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the VBR.
        The name must be 2 to 128 characters in length, and can contain, digits, periods (.),
        underscores (_), and hyphens (-). The name cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f530449409282ad86b727fb11410ad4ef3fa6a94ed4c3407ab49be871fa44b06)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosVirtualBorderRouterProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_gateway_ip": "localGatewayIp",
        "peer_gateway_ip": "peerGatewayIp",
        "peering_subnet_mask": "peeringSubnetMask",
        "physical_connection_id": "physicalConnectionId",
        "vlan_id": "vlanId",
        "circuit_code": "circuitCode",
        "description": "description",
        "name": "name",
    },
)
class RosVirtualBorderRouterProps:
    def __init__(
        self,
        *,
        local_gateway_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        peer_gateway_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        peering_subnet_mask: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        physical_connection_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vlan_id: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        circuit_code: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosVirtualBorderRouter``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-virtualborderrouter

        :param local_gateway_ip: 
        :param peer_gateway_ip: 
        :param peering_subnet_mask: 
        :param physical_connection_id: 
        :param vlan_id: 
        :param circuit_code: 
        :param description: 
        :param name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6c237c07b95b3a43fcecdfc13e77dec87d5603ad2d34fb9509a774591850b11)
            check_type(argname="argument local_gateway_ip", value=local_gateway_ip, expected_type=type_hints["local_gateway_ip"])
            check_type(argname="argument peer_gateway_ip", value=peer_gateway_ip, expected_type=type_hints["peer_gateway_ip"])
            check_type(argname="argument peering_subnet_mask", value=peering_subnet_mask, expected_type=type_hints["peering_subnet_mask"])
            check_type(argname="argument physical_connection_id", value=physical_connection_id, expected_type=type_hints["physical_connection_id"])
            check_type(argname="argument vlan_id", value=vlan_id, expected_type=type_hints["vlan_id"])
            check_type(argname="argument circuit_code", value=circuit_code, expected_type=type_hints["circuit_code"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "local_gateway_ip": local_gateway_ip,
            "peer_gateway_ip": peer_gateway_ip,
            "peering_subnet_mask": peering_subnet_mask,
            "physical_connection_id": physical_connection_id,
            "vlan_id": vlan_id,
        }
        if circuit_code is not None:
            self._values["circuit_code"] = circuit_code
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def local_gateway_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: localGatewayIp: The IP address of the VBR on the Alibaba Cloud side.
        '''
        result = self._values.get("local_gateway_ip")
        assert result is not None, "Required property 'local_gateway_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def peer_gateway_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        peerGatewayIp: The IP address of the peer router interface of the VBR.
        Only the owner of the VBR can set or modify the value.
        This parameter is required when you create a VBR for the owner of the physical connection.
        You can ignore this parameter when you create a VBR for another Alibaba Cloud account.
        '''
        result = self._values.get("peer_gateway_ip")
        assert result is not None, "Required property 'peer_gateway_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def peering_subnet_mask(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        peeringSubnetMask: The subnet mask for the IP addresses of the VBR on the Alibaba Cloud side and on the
        user side.
        The two IP addresses must fall within the same subnet.
        '''
        result = self._values.get("peering_subnet_mask")
        assert result is not None, "Required property 'peering_subnet_mask' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def physical_connection_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: physicalConnectionId: The ID of the physical connection.
        '''
        result = self._values.get("physical_connection_id")
        assert result is not None, "Required property 'physical_connection_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vlan_id(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        vlanId: The VLAN ID of the VBR. Valid values: 0 to 2999.
        Note Only the owner of the physical connection can set this parameter. The VLAN IDs of
        two VBRs of the same physical connection must be different.
        '''
        result = self._values.get("vlan_id")
        assert result is not None, "Required property 'vlan_id' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def circuit_code(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        circuitCode: The circuit code provided by the Internet service provider (ISP) for the physical
        connection.
        Note Only the owner of the physical connection can set this parameter.
        '''
        result = self._values.get("circuit_code")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the VBR.
        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the VBR.
        The name must be 2 to 128 characters in length, and can contain, digits, periods (.),
        underscores (_), and hyphens (-). The name cannot start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVirtualBorderRouterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVpcPeerConnection(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosVpcPeerConnection",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::VpcPeerConnection``, which is used to create a peering connection between virtual private clouds (VPCs).

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``VpcPeerConnection`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpcpeerconnection
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosVpcPeerConnectionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8974cad520f2b085f065864fb1d51cc457b079b69fefbf0f10648ad1f8344ee)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bed53fefd9ff394e2041bb3a8d00f7ff6e40f341c90323afe98547093c633006)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrInstanceId")
    def attr_instance_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: InstanceId: The ID of the VPC peering connection.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInstanceId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="acceptingVpcId")
    def accepting_vpc_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: acceptingVpcId: The ID of the acceptor VPC.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "acceptingVpcId"))

    @accepting_vpc_id.setter
    def accepting_vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb72ac418d8e8f0fc2a0967117455085b6a53bc42524410fd9afdad5ba30e637)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "acceptingVpcId", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__411e257387a473985e9d11a7238f6b87c7e3a7d21b642ae2f67c33198e51489b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the requester VPC.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61e1fccd322f3d62f8a555ad593478e5c21a54b11333edf1362652559ecb2396)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcId", value)

    @builtins.property
    @jsii.member(jsii_name="acceptingAliUid")
    def accepting_ali_uid(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        acceptingAliUid: The ID of the Alibaba Cloud account to which the acceptor VPC belongs.
        To create a VPC peering connection within your Alibaba Cloud account, enter the ID
        of your Alibaba Cloud account.
        To create a VPC peering connection between your Alibaba Cloud account and another
        Alibaba Cloud account, enter the ID of the peer Alibaba Cloud account.
        Note If the acceptor VPC belongs to a Resource Access Management (RAM) user, you must set
        the value of AcceptingAliUid to the ID of the corresponding Alibaba Cloud account.
        Default current account ID.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "acceptingAliUid"))

    @accepting_ali_uid.setter
    def accepting_ali_uid(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d5e0e269fba554486d6a419282922c96ec1795cf8d4afcc653efd24e5ae25ea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "acceptingAliUid", value)

    @builtins.property
    @jsii.member(jsii_name="acceptingRegionId")
    def accepting_region_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        acceptingRegionId: The region ID of the acceptor VPC of the VPC peering connection that you want to create.
        To create an intra-region VPC peering connection, enter a region ID that is the same
        as that of the requester VPC.
        To create an inter-region VPC peering connection, enter a region ID that is different
        from that of the requester VPC.
        Default current region.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "acceptingRegionId"))

    @accepting_region_id.setter
    def accepting_region_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9026eadc828db9cca2b647edb912ab48be37c663def2e59f5474fdab04883bb8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "acceptingRegionId", value)

    @builtins.property
    @jsii.member(jsii_name="deletionForce")
    def deletion_force(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: deletionForce: Specifies whether to forcefully delete the VPC peering connection. Valid values:false (default): notrue: yes If you forcefully delete the VPC peering connection, the system deletes the routes that point to the VPC peering connection from the VPC route table.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "deletionForce"))

    @deletion_force.setter
    def deletion_force(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a62c7bc95ba02dad281780733b20a90357916c6f79932cf241ebb0d67f86247)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionForce", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the VPC peering connection.
        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5af5d61322087420ec7da902ac105a56fee62c55dec4ba0ac80035bb6d86fca2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the VPC peering connection.
        The name must be 2 to 128 characters in length and can contain digits, underscores
        (_), and hyphens (-). It must start with a letter.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75625182378103677aae966a14a575db8643b7747dca43049e7da05e71ed1d21)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosVpcPeerConnectionProps",
    jsii_struct_bases=[],
    name_mapping={
        "accepting_vpc_id": "acceptingVpcId",
        "vpc_id": "vpcId",
        "accepting_ali_uid": "acceptingAliUid",
        "accepting_region_id": "acceptingRegionId",
        "deletion_force": "deletionForce",
        "description": "description",
        "name": "name",
    },
)
class RosVpcPeerConnectionProps:
    def __init__(
        self,
        *,
        accepting_vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        accepting_ali_uid: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        accepting_region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_force: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosVpcPeerConnection``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpcpeerconnection

        :param accepting_vpc_id: 
        :param vpc_id: 
        :param accepting_ali_uid: 
        :param accepting_region_id: 
        :param deletion_force: 
        :param description: 
        :param name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f2c93304480b341b97edb164693d6eaef838a8a5750ff7cf6c429309964d817)
            check_type(argname="argument accepting_vpc_id", value=accepting_vpc_id, expected_type=type_hints["accepting_vpc_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument accepting_ali_uid", value=accepting_ali_uid, expected_type=type_hints["accepting_ali_uid"])
            check_type(argname="argument accepting_region_id", value=accepting_region_id, expected_type=type_hints["accepting_region_id"])
            check_type(argname="argument deletion_force", value=deletion_force, expected_type=type_hints["deletion_force"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "accepting_vpc_id": accepting_vpc_id,
            "vpc_id": vpc_id,
        }
        if accepting_ali_uid is not None:
            self._values["accepting_ali_uid"] = accepting_ali_uid
        if accepting_region_id is not None:
            self._values["accepting_region_id"] = accepting_region_id
        if deletion_force is not None:
            self._values["deletion_force"] = deletion_force
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def accepting_vpc_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: acceptingVpcId: The ID of the acceptor VPC.
        '''
        result = self._values.get("accepting_vpc_id")
        assert result is not None, "Required property 'accepting_vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: The ID of the requester VPC.
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def accepting_ali_uid(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        acceptingAliUid: The ID of the Alibaba Cloud account to which the acceptor VPC belongs.
        To create a VPC peering connection within your Alibaba Cloud account, enter the ID
        of your Alibaba Cloud account.
        To create a VPC peering connection between your Alibaba Cloud account and another
        Alibaba Cloud account, enter the ID of the peer Alibaba Cloud account.
        Note If the acceptor VPC belongs to a Resource Access Management (RAM) user, you must set
        the value of AcceptingAliUid to the ID of the corresponding Alibaba Cloud account.
        Default current account ID.
        '''
        result = self._values.get("accepting_ali_uid")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def accepting_region_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        acceptingRegionId: The region ID of the acceptor VPC of the VPC peering connection that you want to create.
        To create an intra-region VPC peering connection, enter a region ID that is the same
        as that of the requester VPC.
        To create an inter-region VPC peering connection, enter a region ID that is different
        from that of the requester VPC.
        Default current region.
        '''
        result = self._values.get("accepting_region_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_force(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: deletionForce: Specifies whether to forcefully delete the VPC peering connection. Valid values:false (default): notrue: yes If you forcefully delete the VPC peering connection, the system deletes the routes that point to the VPC peering connection from the VPC route table.
        '''
        result = self._values.get("deletion_force")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: The description of the VPC peering connection.
        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the VPC peering connection.
        The name must be 2 to 128 characters in length and can contain digits, underscores
        (_), and hyphens (-). It must start with a letter.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVpcPeerConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVpnAttachment(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnAttachment",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::VpnAttachment``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``VpnAttachment`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosVpnAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36c37407ff6cb0bd19e58ec97ac621c64242cf498880716e6e5ee5dd01a74348)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d30ce44413a9e627a132feff30cc0972330029651108e565f1ebed000b99fa3f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrInternetIp")
    def attr_internet_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: InternetIp: The gateway IP address of the IPsec connection.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInternetIp"))

    @builtins.property
    @jsii.member(jsii_name="attrPeerVpnAttachmentConfig")
    def attr_peer_vpn_attachment_config(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: PeerVpnAttachmentConfig: Peer vpc Attachment config.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPeerVpnAttachmentConfig"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnAttachmentId")
    def attr_vpn_attachment_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpnAttachmentId: ID of the IPsec attachment.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnAttachmentId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="customerGatewayId")
    def customer_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: customerGatewayId: The ID of the user gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "customerGatewayId"))

    @customer_gateway_id.setter
    def customer_gateway_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12311299189231dcde6be12488ad0f69549a0a00cb5620261eca1dac375e58b3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "customerGatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63ee0097f02737a40c9253586f11756484584c4211a6a7aefdc3d80196511197)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="localSubnet")
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        localSubnet: A network segment on the VPC side that needs to be interconnected with the local IDC for the second phase negotiation.
        Multiple network segments are separated by commas, for example: 192.168.1.0/24, 192.168.2.0/24.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "localSubnet"))

    @local_subnet.setter
    def local_subnet(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__611b14bb20358a066bd48bdfcdfe9307bc02675fe0e2d7724c2a0df2b692f2fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSubnet", value)

    @builtins.property
    @jsii.member(jsii_name="remoteSubnet")
    def remote_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        remoteSubnet: The network segment of the local IDC is used for the second phase negotiation.
        Multiple network segments are separated by commas, for example: 192.168.3.0/24, 192.168.4.0/24.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "remoteSubnet"))

    @remote_subnet.setter
    def remote_subnet(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f1910544f14a43fb44d41108eee81f52cf5329d89c5ad9f4e153d4885a980b7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "remoteSubnet", value)

    @builtins.property
    @jsii.member(jsii_name="autoConfigRoute")
    def auto_config_route(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoConfigRoute: Specifies whether to automatically configure routes. Valid values:
        true (default)
        false
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoConfigRoute"))

    @auto_config_route.setter
    def auto_config_route(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c4cef3553bb396e5a70d00830f0c8208c9eddd84109617db3cbe0ad04b846b3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoConfigRoute", value)

    @builtins.property
    @jsii.member(jsii_name="bgpConfig")
    def bgp_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.BgpConfigProperty"]]:
        '''
        :Property:

        bgpConfig: The Border Gateway Protocol (BGP) configuration.
        This parameter is required when the VPN gateway has dynamic BGP enabled.
        Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see VPN Gateway supports BGP dynamic routing.
        We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP.
        Refer to the relevant documentation for the private ASN range.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.BgpConfigProperty"]], jsii.get(self, "bgpConfig"))

    @bgp_config.setter
    def bgp_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.BgpConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3240b3e0e97a098d220786d11525ff5b147f450c594f7d821852eb39f5d2acfb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bgpConfig", value)

    @builtins.property
    @jsii.member(jsii_name="effectImmediately")
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        effectImmediately: Whether to delete the currently negotiated IPsec tunnel and re-initiate the negotiation. Value:
        True: Negotiate immediately after the configuration is complete.
        False (default): Negotiate when traffic enters.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "effectImmediately"))

    @effect_immediately.setter
    def effect_immediately(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__948a8f900b4079ab5ac5e2f3430a96f02945d1825a639b651499b4978fe5f0df)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "effectImmediately", value)

    @builtins.property
    @jsii.member(jsii_name="enableDpd")
    def enable_dpd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableDpd: Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
        true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
        false: disables DPD. The IPsec initiator does not send DPD packets.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enableDpd"))

    @enable_dpd.setter
    def enable_dpd(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0dc58f4bdc7e5e9e3c1670db03a4a1337f959ea6f1a88462b98316f22287b449)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableDpd", value)

    @builtins.property
    @jsii.member(jsii_name="enableNatTraversal")
    def enable_nat_traversal(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableNatTraversal: Specifies whether to enable NAT traversal. Valid values:
        true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
        false
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enableNatTraversal"))

    @enable_nat_traversal.setter
    def enable_nat_traversal(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8692830a580408ba2cff06ba898cab94a4daa7d2757e22cb5e3d7c72da12aa0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableNatTraversal", value)

    @builtins.property
    @jsii.member(jsii_name="healthCheckConfig")
    def health_check_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.HealthCheckConfigProperty"]]:
        '''
        :Property: healthCheckConfig: Whether to enable the health check configuration.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.HealthCheckConfigProperty"]], jsii.get(self, "healthCheckConfig"))

    @health_check_config.setter
    def health_check_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.HealthCheckConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__588c8cdd10220e11103a228ca1f4db213317b3900e5a233d7df50cd5e899e888)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "healthCheckConfig", value)

    @builtins.property
    @jsii.member(jsii_name="ikeConfig")
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.IkeConfigProperty"]]:
        '''
        :Property: ikeConfig: Configuration information for the first phase of negotiation.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.IkeConfigProperty"]], jsii.get(self, "ikeConfig"))

    @ike_config.setter
    def ike_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.IkeConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eed994f7a2b8e9bfe6a5cd2716431f2b8531e0ce9227f7c1b5dd1801f88d22c5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ikeConfig", value)

    @builtins.property
    @jsii.member(jsii_name="ipsecConfig")
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.IpsecConfigProperty"]]:
        '''
        :Property: ipsecConfig: Configuration information for the second phase negotiation.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.IpsecConfigProperty"]], jsii.get(self, "ipsecConfig"))

    @ipsec_config.setter
    def ipsec_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnAttachment.IpsecConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59087a7b41542e3fef22c5d38b4e5501ce7d816ece8586113cbebf4f6d12ed8e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipsecConfig", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the IPsec connection.
        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_) and dashes (-), but cannot start with http:// or https:// .
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b952e06f2f5d9041babd2511fa428304335d9dcd2bf271693d0efd20e97051f1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="networkType")
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: networkType: The network type of the IPsec connection. Value: public|private.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "networkType"))

    @network_type.setter
    def network_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8690c5e6877b1666ce06007b03581c17d44e84f2baa156975688426e16da530f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "networkType", value)

    @builtins.property
    @jsii.member(jsii_name="remoteCaCert")
    def remote_ca_cert(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        remoteCaCert: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.
        This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
        You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "remoteCaCert"))

    @remote_ca_cert.setter
    def remote_ca_cert(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__714467ef84bc01d8b482be226f19fa90c2418f4fa9dea059108cb0779e7fcef6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "remoteCaCert", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnAttachment.BgpConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_bgp": "enableBgp",
            "local_asn": "localAsn",
            "local_bgp_ip": "localBgpIp",
            "tunnel_cidr": "tunnelCidr",
        },
    )
    class BgpConfigProperty:
        def __init__(
            self,
            *,
            enable_bgp: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_bgp_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            tunnel_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param enable_bgp: 
            :param local_asn: 
            :param local_bgp_ip: 
            :param tunnel_cidr: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9f813d82a18270f85c9cca21204a90d2ae8a962a65d6ec78070fa928a7c77e79)
                check_type(argname="argument enable_bgp", value=enable_bgp, expected_type=type_hints["enable_bgp"])
                check_type(argname="argument local_asn", value=local_asn, expected_type=type_hints["local_asn"])
                check_type(argname="argument local_bgp_ip", value=local_bgp_ip, expected_type=type_hints["local_bgp_ip"])
                check_type(argname="argument tunnel_cidr", value=tunnel_cidr, expected_type=type_hints["tunnel_cidr"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enable_bgp is not None:
                self._values["enable_bgp"] = enable_bgp
            if local_asn is not None:
                self._values["local_asn"] = local_asn
            if local_bgp_ip is not None:
                self._values["local_bgp_ip"] = local_bgp_ip
            if tunnel_cidr is not None:
                self._values["tunnel_cidr"] = tunnel_cidr

        @builtins.property
        def enable_bgp(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            enableBgp: Specifies whether to enable the BGP feature for the tunnel.
            Valid values: true and false. Default value: false.
            '''
            result = self._values.get("enable_bgp")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_asn(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: localAsn: the ASN on the Alibaba Cloud side. Valid values: 1 to 4294967295. Default value: 45104.
            '''
            result = self._values.get("local_asn")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_bgp_ip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            localBgpIp: the BGP IP address on the Alibaba Cloud side.
            This IP address must fall within the CIDR block of the IPsec tunnel.
            '''
            result = self._values.get("local_bgp_ip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def tunnel_cidr(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: tunnelCidr: the CIDR block of the IPsec tunnel. The CIDR block must fall within 169.254.0.0/16. The subnet mask of the CIDR block must be 30 bits in length.
            '''
            result = self._values.get("tunnel_cidr")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BgpConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnAttachment.HealthCheckConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "dip": "dip",
            "enable": "enable",
            "interval": "interval",
            "policy": "policy",
            "retry": "retry",
            "sip": "sip",
        },
    )
    class HealthCheckConfigProperty:
        def __init__(
            self,
            *,
            dip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            enable: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            interval: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            retry: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            sip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param dip: 
            :param enable: 
            :param interval: 
            :param policy: 
            :param retry: 
            :param sip: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__95f679d8e18e9f4ecd67794e336ef0da8037f8a3cc31c73d37f68bfe2bce08e6)
                check_type(argname="argument dip", value=dip, expected_type=type_hints["dip"])
                check_type(argname="argument enable", value=enable, expected_type=type_hints["enable"])
                check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
                check_type(argname="argument policy", value=policy, expected_type=type_hints["policy"])
                check_type(argname="argument retry", value=retry, expected_type=type_hints["retry"])
                check_type(argname="argument sip", value=sip, expected_type=type_hints["sip"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if dip is not None:
                self._values["dip"] = dip
            if enable is not None:
                self._values["enable"] = enable
            if interval is not None:
                self._values["interval"] = interval
            if policy is not None:
                self._values["policy"] = policy
            if retry is not None:
                self._values["retry"] = retry
            if sip is not None:
                self._values["sip"] = sip

        @builtins.property
        def dip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: dip:
            '''
            result = self._values.get("dip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def enable(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: enable:
            '''
            result = self._values.get("enable")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def interval(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: interval:
            '''
            result = self._values.get("interval")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def policy(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: policy: Whether to revoke published routes when the health check fails.
            '''
            result = self._values.get("policy")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def retry(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: retry:
            '''
            result = self._values.get("retry")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def sip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: sip:
            '''
            result = self._values.get("sip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HealthCheckConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnAttachment.IkeConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ike_auth_alg": "ikeAuthAlg",
            "ike_enc_alg": "ikeEncAlg",
            "ike_lifetime": "ikeLifetime",
            "ike_mode": "ikeMode",
            "ike_pfs": "ikePfs",
            "ike_version": "ikeVersion",
            "local_id": "localId",
            "psk": "psk",
            "remote_id": "remoteId",
        },
    )
    class IkeConfigProperty:
        def __init__(
            self,
            *,
            ike_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            remote_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param ike_auth_alg: 
            :param ike_enc_alg: 
            :param ike_lifetime: 
            :param ike_mode: 
            :param ike_pfs: 
            :param ike_version: 
            :param local_id: 
            :param psk: 
            :param remote_id: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__16b764251938487721b413a5cfcd84085024ad61b28c90c0f6c7caddb01f1e42)
                check_type(argname="argument ike_auth_alg", value=ike_auth_alg, expected_type=type_hints["ike_auth_alg"])
                check_type(argname="argument ike_enc_alg", value=ike_enc_alg, expected_type=type_hints["ike_enc_alg"])
                check_type(argname="argument ike_lifetime", value=ike_lifetime, expected_type=type_hints["ike_lifetime"])
                check_type(argname="argument ike_mode", value=ike_mode, expected_type=type_hints["ike_mode"])
                check_type(argname="argument ike_pfs", value=ike_pfs, expected_type=type_hints["ike_pfs"])
                check_type(argname="argument ike_version", value=ike_version, expected_type=type_hints["ike_version"])
                check_type(argname="argument local_id", value=local_id, expected_type=type_hints["local_id"])
                check_type(argname="argument psk", value=psk, expected_type=type_hints["psk"])
                check_type(argname="argument remote_id", value=remote_id, expected_type=type_hints["remote_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ike_auth_alg is not None:
                self._values["ike_auth_alg"] = ike_auth_alg
            if ike_enc_alg is not None:
                self._values["ike_enc_alg"] = ike_enc_alg
            if ike_lifetime is not None:
                self._values["ike_lifetime"] = ike_lifetime
            if ike_mode is not None:
                self._values["ike_mode"] = ike_mode
            if ike_pfs is not None:
                self._values["ike_pfs"] = ike_pfs
            if ike_version is not None:
                self._values["ike_version"] = ike_version
            if local_id is not None:
                self._values["local_id"] = local_id
            if psk is not None:
                self._values["psk"] = psk
            if remote_id is not None:
                self._values["remote_id"] = remote_id

        @builtins.property
        def ike_auth_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ikeAuthAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is md5|sha1|sha256|sha384|sha512, and the default value is md5.
            If the VPN gateway instance type is national secret type, The value is sm3 (default value).
            '''
            result = self._values.get("ike_auth_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_enc_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ikeEncAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is aes|aes192|aes256|des|3des, and the default value is aes.
            If the VPN gateway instance type is national secret type, The value is sm4 (default value).
            '''
            result = self._values.get("ike_enc_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_lifetime(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeLifetime: The life cycle of the SA negotiated in the first phase. The value ranges from 0 to 86400, in seconds. The default value is 86400.
            '''
            result = self._values.get("ike_lifetime")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_mode(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeMode: Negotiation mode for IKE V1. Value: main|aggressive, default: main.
            '''
            result = self._values.get("ike_mode")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_pfs(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikePfs: Diffie-Hellman key exchange algorithm used in the first phase negotiation. Value: group1|group2|group5|group14|group24, default value: group2.
            '''
            result = self._values.get("ike_pfs")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_version(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeVersion: The version of the IKE protocol. Value: ikev1|ikev2, default: ikev1.
            '''
            result = self._values.get("ike_version")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: localId: ID of the VPN gateway. The length is limited to 100 characters. The default value is the public IP address of the VPN gateway.
            '''
            result = self._values.get("local_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def psk(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: psk: Used for identity authentication between the IPsec VPN gateway and the user gateway. It is generated randomly by default, or you can specify the key manually. The length is limited to 100 characters.
            '''
            result = self._values.get("psk")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def remote_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: remoteId: ID of the user gateway. The length is limited to 100 characters. The default value is the public IP address of the user gateway.
            '''
            result = self._values.get("remote_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IkeConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnAttachment.IpsecConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ipsec_auth_alg": "ipsecAuthAlg",
            "ipsec_enc_alg": "ipsecEncAlg",
            "ipsec_lifetime": "ipsecLifetime",
            "ipsec_pfs": "ipsecPfs",
        },
    )
    class IpsecConfigProperty:
        def __init__(
            self,
            *,
            ipsec_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param ipsec_auth_alg: 
            :param ipsec_enc_alg: 
            :param ipsec_lifetime: 
            :param ipsec_pfs: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0729c17724e3226bb66d98445057f4e94d2e2c72aa813d6a8bb8997720e82838)
                check_type(argname="argument ipsec_auth_alg", value=ipsec_auth_alg, expected_type=type_hints["ipsec_auth_alg"])
                check_type(argname="argument ipsec_enc_alg", value=ipsec_enc_alg, expected_type=type_hints["ipsec_enc_alg"])
                check_type(argname="argument ipsec_lifetime", value=ipsec_lifetime, expected_type=type_hints["ipsec_lifetime"])
                check_type(argname="argument ipsec_pfs", value=ipsec_pfs, expected_type=type_hints["ipsec_pfs"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipsec_auth_alg is not None:
                self._values["ipsec_auth_alg"] = ipsec_auth_alg
            if ipsec_enc_alg is not None:
                self._values["ipsec_enc_alg"] = ipsec_enc_alg
            if ipsec_lifetime is not None:
                self._values["ipsec_lifetime"] = ipsec_lifetime
            if ipsec_pfs is not None:
                self._values["ipsec_pfs"] = ipsec_pfs

        @builtins.property
        def ipsec_auth_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ipsecAuthAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is md5|sha1|sha256|sha384|sha512, and the default value is md5.
            If the VPN gateway instance type is national secret type, The value is sm3 (default value).
            '''
            result = self._values.get("ipsec_auth_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_enc_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ipsecEncAlg: The authentication algorithm negotiated in the second phase.
            If the VPN gateway instance type is normal, the value is aes|aes192|aes256|des|3des, and the default value is aes.
            If the VPN gateway instance type is national secret type, The value is sm4 (default value).
            '''
            result = self._values.get("ipsec_enc_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_lifetime(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecLifetime: IpsecLifetime: The life cycle of the SA negotiated in the second phase. The value ranges from 0 to 86400, in seconds. The default value is 86400.
            '''
            result = self._values.get("ipsec_lifetime")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_pfs(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecPfs: Forwards all protocol packets. The Diffie-Hellman key exchange algorithm used in the first phase negotiation, the value: group1|group2|group5|group14|group24, default value: group2.
            '''
            result = self._values.get("ipsec_pfs")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpsecConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "customer_gateway_id": "customerGatewayId",
        "local_subnet": "localSubnet",
        "remote_subnet": "remoteSubnet",
        "auto_config_route": "autoConfigRoute",
        "bgp_config": "bgpConfig",
        "effect_immediately": "effectImmediately",
        "enable_dpd": "enableDpd",
        "enable_nat_traversal": "enableNatTraversal",
        "health_check_config": "healthCheckConfig",
        "ike_config": "ikeConfig",
        "ipsec_config": "ipsecConfig",
        "name": "name",
        "network_type": "networkType",
        "remote_ca_cert": "remoteCaCert",
    },
)
class RosVpnAttachmentProps:
    def __init__(
        self,
        *,
        customer_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        remote_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auto_config_route: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.BgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.HealthCheckConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        remote_ca_cert: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosVpnAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnattachment

        :param customer_gateway_id: 
        :param local_subnet: 
        :param remote_subnet: 
        :param auto_config_route: 
        :param bgp_config: 
        :param effect_immediately: 
        :param enable_dpd: 
        :param enable_nat_traversal: 
        :param health_check_config: 
        :param ike_config: 
        :param ipsec_config: 
        :param name: 
        :param network_type: 
        :param remote_ca_cert: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__547b650b0b0960fce9a502d546f122faa7bb87955c65427feb7e1b496b2bc41c)
            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
            check_type(argname="argument local_subnet", value=local_subnet, expected_type=type_hints["local_subnet"])
            check_type(argname="argument remote_subnet", value=remote_subnet, expected_type=type_hints["remote_subnet"])
            check_type(argname="argument auto_config_route", value=auto_config_route, expected_type=type_hints["auto_config_route"])
            check_type(argname="argument bgp_config", value=bgp_config, expected_type=type_hints["bgp_config"])
            check_type(argname="argument effect_immediately", value=effect_immediately, expected_type=type_hints["effect_immediately"])
            check_type(argname="argument enable_dpd", value=enable_dpd, expected_type=type_hints["enable_dpd"])
            check_type(argname="argument enable_nat_traversal", value=enable_nat_traversal, expected_type=type_hints["enable_nat_traversal"])
            check_type(argname="argument health_check_config", value=health_check_config, expected_type=type_hints["health_check_config"])
            check_type(argname="argument ike_config", value=ike_config, expected_type=type_hints["ike_config"])
            check_type(argname="argument ipsec_config", value=ipsec_config, expected_type=type_hints["ipsec_config"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument network_type", value=network_type, expected_type=type_hints["network_type"])
            check_type(argname="argument remote_ca_cert", value=remote_ca_cert, expected_type=type_hints["remote_ca_cert"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "customer_gateway_id": customer_gateway_id,
            "local_subnet": local_subnet,
            "remote_subnet": remote_subnet,
        }
        if auto_config_route is not None:
            self._values["auto_config_route"] = auto_config_route
        if bgp_config is not None:
            self._values["bgp_config"] = bgp_config
        if effect_immediately is not None:
            self._values["effect_immediately"] = effect_immediately
        if enable_dpd is not None:
            self._values["enable_dpd"] = enable_dpd
        if enable_nat_traversal is not None:
            self._values["enable_nat_traversal"] = enable_nat_traversal
        if health_check_config is not None:
            self._values["health_check_config"] = health_check_config
        if ike_config is not None:
            self._values["ike_config"] = ike_config
        if ipsec_config is not None:
            self._values["ipsec_config"] = ipsec_config
        if name is not None:
            self._values["name"] = name
        if network_type is not None:
            self._values["network_type"] = network_type
        if remote_ca_cert is not None:
            self._values["remote_ca_cert"] = remote_ca_cert

    @builtins.property
    def customer_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: customerGatewayId: The ID of the user gateway.
        '''
        result = self._values.get("customer_gateway_id")
        assert result is not None, "Required property 'customer_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        localSubnet: A network segment on the VPC side that needs to be interconnected with the local IDC for the second phase negotiation.
        Multiple network segments are separated by commas, for example: 192.168.1.0/24, 192.168.2.0/24.
        '''
        result = self._values.get("local_subnet")
        assert result is not None, "Required property 'local_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def remote_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        remoteSubnet: The network segment of the local IDC is used for the second phase negotiation.
        Multiple network segments are separated by commas, for example: 192.168.3.0/24, 192.168.4.0/24.
        '''
        result = self._values.get("remote_subnet")
        assert result is not None, "Required property 'remote_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auto_config_route(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoConfigRoute: Specifies whether to automatically configure routes. Valid values:
        true (default)
        false
        '''
        result = self._values.get("auto_config_route")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def bgp_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.BgpConfigProperty]]:
        '''
        :Property:

        bgpConfig: The Border Gateway Protocol (BGP) configuration.
        This parameter is required when the VPN gateway has dynamic BGP enabled.
        Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see VPN Gateway supports BGP dynamic routing.
        We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP.
        Refer to the relevant documentation for the private ASN range.
        '''
        result = self._values.get("bgp_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.BgpConfigProperty]], result)

    @builtins.property
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        effectImmediately: Whether to delete the currently negotiated IPsec tunnel and re-initiate the negotiation. Value:
        True: Negotiate immediately after the configuration is complete.
        False (default): Negotiate when traffic enters.
        '''
        result = self._values.get("effect_immediately")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_dpd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableDpd: Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
        true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
        false: disables DPD. The IPsec initiator does not send DPD packets.
        '''
        result = self._values.get("enable_dpd")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_nat_traversal(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableNatTraversal: Specifies whether to enable NAT traversal. Valid values:
        true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
        false
        '''
        result = self._values.get("enable_nat_traversal")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.HealthCheckConfigProperty]]:
        '''
        :Property: healthCheckConfig: Whether to enable the health check configuration.
        '''
        result = self._values.get("health_check_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.HealthCheckConfigProperty]], result)

    @builtins.property
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IkeConfigProperty]]:
        '''
        :Property: ikeConfig: Configuration information for the first phase of negotiation.
        '''
        result = self._values.get("ike_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IkeConfigProperty]], result)

    @builtins.property
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IpsecConfigProperty]]:
        '''
        :Property: ipsecConfig: Configuration information for the second phase negotiation.
        '''
        result = self._values.get("ipsec_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IpsecConfigProperty]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the IPsec connection.
        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_) and dashes (-), but cannot start with http:// or https:// .
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: networkType: The network type of the IPsec connection. Value: public|private.
        '''
        result = self._values.get("network_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def remote_ca_cert(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        remoteCaCert: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.
        This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
        You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
        '''
        result = self._values.get("remote_ca_cert")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVpnAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVpnConnection(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::VpnConnection``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``VpnConnection`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnconnection
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosVpnConnectionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3872d59216c7907048603c751ff9f971ed1c9e79957adc3da04606016090997d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7a2a539f3177548ac7085ac74354614333240cf3fe703796e9bda3b37d858a7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrPeerVpnConnectionConfig")
    def attr_peer_vpn_connection_config(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: PeerVpnConnectionConfig: Peer vpc connection config.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPeerVpnConnectionConfig"))

    @builtins.property
    @jsii.member(jsii_name="attrStatus")
    def attr_status(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Status: Status of the IPsec connection.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrStatus"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnConnectionId")
    def attr_vpn_connection_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpnConnectionId: ID of the IPsec connection.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnConnectionId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0ea372e162db491831218393244bf1fb9e3935de6a63291811344e0f0d66683)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="localSubnet")
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        localSubnet: A network segment on the VPC side that needs to be interconnected with the local IDC for the second phase negotiation.
        Multiple network segments are separated by commas, for example: 192.168.1.0/24, 192.168.2.0/24.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "localSubnet"))

    @local_subnet.setter
    def local_subnet(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb0f9a51303120ff778015e15b39dc2954da6d3b998838aa0f3437019538a577)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSubnet", value)

    @builtins.property
    @jsii.member(jsii_name="remoteSubnet")
    def remote_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        remoteSubnet: The network segment of the local IDC is used for the second phase negotiation.
        Multiple network segments are separated by commas, for example: 192.168.3.0/24, 192.168.4.0/24.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "remoteSubnet"))

    @remote_subnet.setter
    def remote_subnet(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33282f393380b866ed41de39794e96d838ab627e2bc2193d7c8aaae50224257c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "remoteSubnet", value)

    @builtins.property
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: ID of the VPN gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpnGatewayId"))

    @vpn_gateway_id.setter
    def vpn_gateway_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c0a95b3ff983ec19870e921b704efbc8c05bd7a7b8a502e4d6b5e7c7c7974cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpnGatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="autoConfigRoute")
    def auto_config_route(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoConfigRoute: Specifies whether to automatically configure routes. Valid values:
        true (default)
        false
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoConfigRoute"))

    @auto_config_route.setter
    def auto_config_route(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a494114b53b1799b0fe3fac3b168e6d2a9d084fc1408f93cc1ae7334a00cc448)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoConfigRoute", value)

    @builtins.property
    @jsii.member(jsii_name="bgpConfig")
    def bgp_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.BgpConfigProperty"]]:
        '''
        :Property:

        bgpConfig: The Border Gateway Protocol (BGP) configuration.
        This parameter is required when the VPN gateway has dynamic BGP enabled.
        Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see VPN Gateway supports BGP dynamic routing.
        We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP.
        Refer to the relevant documentation for the private ASN range.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.BgpConfigProperty"]], jsii.get(self, "bgpConfig"))

    @bgp_config.setter
    def bgp_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.BgpConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eda04e6064cb5a0e83dfaf73de93f02c39d915ac3bb8fbac850ee4726d06da9f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bgpConfig", value)

    @builtins.property
    @jsii.member(jsii_name="customerGatewayId")
    def customer_gateway_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: customerGatewayId: The ID of the user gateway.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "customerGatewayId"))

    @customer_gateway_id.setter
    def customer_gateway_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33a93db7dcb41c337781754a30d505f2a0c58d27a1c7b45ccd4f32f41510f680)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "customerGatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="effectImmediately")
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        effectImmediately: Whether to delete the currently negotiated IPsec tunnel and re-initiate the negotiation. Value:
        True: Negotiate immediately after the configuration is complete.
        False (default): Negotiate when traffic enters.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "effectImmediately"))

    @effect_immediately.setter
    def effect_immediately(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a877d3a454e0409f784c00b698df55cdfbac5ed83eb3846d9f05f5f6dfde19ef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "effectImmediately", value)

    @builtins.property
    @jsii.member(jsii_name="enableDpd")
    def enable_dpd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableDpd: Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
        true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
        false: disables DPD. The IPsec initiator does not send DPD packets.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enableDpd"))

    @enable_dpd.setter
    def enable_dpd(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d71669d26aa26b537a98fa6d85171a24fa28d3638b19011c15cb34d982d015a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableDpd", value)

    @builtins.property
    @jsii.member(jsii_name="enableNatTraversal")
    def enable_nat_traversal(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableNatTraversal: Specifies whether to enable NAT traversal. Valid values:
        true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
        false
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enableNatTraversal"))

    @enable_nat_traversal.setter
    def enable_nat_traversal(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60de6e474d2d6c4d262141dc8d91231c112f361255b2a3157597da9a3a3c9f93)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableNatTraversal", value)

    @builtins.property
    @jsii.member(jsii_name="enableTunnelsBgp")
    def enable_tunnels_bgp(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableTunnelsBgp: Specifies whether to enable the BGP feature for the tunnel.
        Valid values: true and false. Default value: false.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enableTunnelsBgp"))

    @enable_tunnels_bgp.setter
    def enable_tunnels_bgp(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a382729740405df4f3bc4878a9333ab70be55e69c4cea17d38be0f9da9c43c14)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableTunnelsBgp", value)

    @builtins.property
    @jsii.member(jsii_name="healthCheckConfig")
    def health_check_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.HealthCheckConfigProperty"]]:
        '''
        :Property: healthCheckConfig: Whether to enable the health check configuration.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.HealthCheckConfigProperty"]], jsii.get(self, "healthCheckConfig"))

    @health_check_config.setter
    def health_check_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.HealthCheckConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d6e94e84fdf0552bb77967a632f70ca95639e20e9af5b6f37846e7428464bb9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "healthCheckConfig", value)

    @builtins.property
    @jsii.member(jsii_name="ikeConfig")
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.IkeConfigProperty"]]:
        '''
        :Property: ikeConfig: Configuration information for the first phase of negotiation.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.IkeConfigProperty"]], jsii.get(self, "ikeConfig"))

    @ike_config.setter
    def ike_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.IkeConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__338690ebb0fb996d2ff6a7b7e83f0661101e8069037fe6e80493850029eafad2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ikeConfig", value)

    @builtins.property
    @jsii.member(jsii_name="ipsecConfig")
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.IpsecConfigProperty"]]:
        '''
        :Property: ipsecConfig: Configuration information for the second phase negotiation.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.IpsecConfigProperty"]], jsii.get(self, "ipsecConfig"))

    @ipsec_config.setter
    def ipsec_config(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.IpsecConfigProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25ebf454f853ec6b874d3e1b14bda3b6d434aee16b29062db8a2ccd538dfc6ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ipsecConfig", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the IPsec connection.
        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_) and dashes (-), but cannot start with http:// or https:// .
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45035c568e16624c720543c238925aa341962724c4384e56c46a9744cb1eddc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="remoteCaCertificate")
    def remote_ca_certificate(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        remoteCaCertificate: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.
        This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
        You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "remoteCaCertificate"))

    @remote_ca_certificate.setter
    def remote_ca_certificate(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c99e4292258c7fb608b181593a41fe3c9a862b29c2f0197ee3c3eb2620608e51)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "remoteCaCertificate", value)

    @builtins.property
    @jsii.member(jsii_name="tunnelOptionsSpecification")
    def tunnel_options_specification(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelOptionsSpecificationProperty"]]]]:
        '''
        :Property:

        tunnelOptionsSpecification: TunnelOptionsSpecification parameters are supported by dual-tunnel IPsec-VPN gateways.
        You can modify both the active and standby tunnels of the IPsec-VPN connection.
        '''
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelOptionsSpecificationProperty"]]]], jsii.get(self, "tunnelOptionsSpecification"))

    @tunnel_options_specification.setter
    def tunnel_options_specification(
        self,
        value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelOptionsSpecificationProperty"]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__942c21eae4bc1e7515cf720984cc88931c73ba32a8126d5ae5c38c23342d20db)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tunnelOptionsSpecification", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection.BgpConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_bgp": "enableBgp",
            "local_asn": "localAsn",
            "local_bgp_ip": "localBgpIp",
            "tunnel_cidr": "tunnelCidr",
        },
    )
    class BgpConfigProperty:
        def __init__(
            self,
            *,
            enable_bgp: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_bgp_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            tunnel_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param enable_bgp: 
            :param local_asn: 
            :param local_bgp_ip: 
            :param tunnel_cidr: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9a82a562a9c3a8618a46af978f7e6532be92a5f9f85f30402415a5125b80079f)
                check_type(argname="argument enable_bgp", value=enable_bgp, expected_type=type_hints["enable_bgp"])
                check_type(argname="argument local_asn", value=local_asn, expected_type=type_hints["local_asn"])
                check_type(argname="argument local_bgp_ip", value=local_bgp_ip, expected_type=type_hints["local_bgp_ip"])
                check_type(argname="argument tunnel_cidr", value=tunnel_cidr, expected_type=type_hints["tunnel_cidr"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enable_bgp is not None:
                self._values["enable_bgp"] = enable_bgp
            if local_asn is not None:
                self._values["local_asn"] = local_asn
            if local_bgp_ip is not None:
                self._values["local_bgp_ip"] = local_bgp_ip
            if tunnel_cidr is not None:
                self._values["tunnel_cidr"] = tunnel_cidr

        @builtins.property
        def enable_bgp(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            enableBgp: Specifies whether to enable the BGP feature for the tunnel.
            Valid values: true and false. Default value: false.
            '''
            result = self._values.get("enable_bgp")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_asn(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: localAsn: the ASN on the Alibaba Cloud side. Valid values: 1 to 4294967295. Default value: 45104.
            '''
            result = self._values.get("local_asn")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_bgp_ip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            localBgpIp: the BGP IP address on the Alibaba Cloud side.
            This IP address must fall within the CIDR block of the IPsec tunnel.
            '''
            result = self._values.get("local_bgp_ip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def tunnel_cidr(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: tunnelCidr: the CIDR block of the IPsec tunnel. The CIDR block must fall within 169.254.0.0/16. The subnet mask of the CIDR block must be 30 bits in length.
            '''
            result = self._values.get("tunnel_cidr")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BgpConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection.HealthCheckConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "dip": "dip",
            "enable": "enable",
            "interval": "interval",
            "policy": "policy",
            "retry": "retry",
            "sip": "sip",
        },
    )
    class HealthCheckConfigProperty:
        def __init__(
            self,
            *,
            dip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            enable: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            interval: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            retry: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            sip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param dip: 
            :param enable: 
            :param interval: 
            :param policy: 
            :param retry: 
            :param sip: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__11e27258538d4521e8893524ee144a5d365b63aaede8154c4f1ca67fcdd29c3f)
                check_type(argname="argument dip", value=dip, expected_type=type_hints["dip"])
                check_type(argname="argument enable", value=enable, expected_type=type_hints["enable"])
                check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
                check_type(argname="argument policy", value=policy, expected_type=type_hints["policy"])
                check_type(argname="argument retry", value=retry, expected_type=type_hints["retry"])
                check_type(argname="argument sip", value=sip, expected_type=type_hints["sip"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if dip is not None:
                self._values["dip"] = dip
            if enable is not None:
                self._values["enable"] = enable
            if interval is not None:
                self._values["interval"] = interval
            if policy is not None:
                self._values["policy"] = policy
            if retry is not None:
                self._values["retry"] = retry
            if sip is not None:
                self._values["sip"] = sip

        @builtins.property
        def dip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: dip:
            '''
            result = self._values.get("dip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def enable(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: enable:
            '''
            result = self._values.get("enable")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def interval(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: interval:
            '''
            result = self._values.get("interval")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def policy(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: policy: Whether to revoke published routes when the health check fails.
            '''
            result = self._values.get("policy")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def retry(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: retry:
            '''
            result = self._values.get("retry")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def sip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: sip:
            '''
            result = self._values.get("sip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HealthCheckConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection.IkeConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ike_auth_alg": "ikeAuthAlg",
            "ike_enc_alg": "ikeEncAlg",
            "ike_lifetime": "ikeLifetime",
            "ike_mode": "ikeMode",
            "ike_pfs": "ikePfs",
            "ike_version": "ikeVersion",
            "local_id": "localId",
            "psk": "psk",
            "remote_id": "remoteId",
        },
    )
    class IkeConfigProperty:
        def __init__(
            self,
            *,
            ike_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            remote_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param ike_auth_alg: 
            :param ike_enc_alg: 
            :param ike_lifetime: 
            :param ike_mode: 
            :param ike_pfs: 
            :param ike_version: 
            :param local_id: 
            :param psk: 
            :param remote_id: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__17e8e6db1de3d7f27b249657fd5b566aa2240a10a6f4d4bf04b5d16e3c64210b)
                check_type(argname="argument ike_auth_alg", value=ike_auth_alg, expected_type=type_hints["ike_auth_alg"])
                check_type(argname="argument ike_enc_alg", value=ike_enc_alg, expected_type=type_hints["ike_enc_alg"])
                check_type(argname="argument ike_lifetime", value=ike_lifetime, expected_type=type_hints["ike_lifetime"])
                check_type(argname="argument ike_mode", value=ike_mode, expected_type=type_hints["ike_mode"])
                check_type(argname="argument ike_pfs", value=ike_pfs, expected_type=type_hints["ike_pfs"])
                check_type(argname="argument ike_version", value=ike_version, expected_type=type_hints["ike_version"])
                check_type(argname="argument local_id", value=local_id, expected_type=type_hints["local_id"])
                check_type(argname="argument psk", value=psk, expected_type=type_hints["psk"])
                check_type(argname="argument remote_id", value=remote_id, expected_type=type_hints["remote_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ike_auth_alg is not None:
                self._values["ike_auth_alg"] = ike_auth_alg
            if ike_enc_alg is not None:
                self._values["ike_enc_alg"] = ike_enc_alg
            if ike_lifetime is not None:
                self._values["ike_lifetime"] = ike_lifetime
            if ike_mode is not None:
                self._values["ike_mode"] = ike_mode
            if ike_pfs is not None:
                self._values["ike_pfs"] = ike_pfs
            if ike_version is not None:
                self._values["ike_version"] = ike_version
            if local_id is not None:
                self._values["local_id"] = local_id
            if psk is not None:
                self._values["psk"] = psk
            if remote_id is not None:
                self._values["remote_id"] = remote_id

        @builtins.property
        def ike_auth_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ikeAuthAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is md5|sha1|sha256|sha384|sha512, and the default value is md5.
            If the VPN gateway instance type is national secret type, The value is sm3 (default value).
            '''
            result = self._values.get("ike_auth_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_enc_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ikeEncAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is aes|aes192|aes256|des|3des, and the default value is aes.
            If the VPN gateway instance type is national secret type, The value is sm4 (default value).
            '''
            result = self._values.get("ike_enc_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_lifetime(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeLifetime: The life cycle of the SA negotiated in the first phase. The value ranges from 0 to 86400, in seconds. The default value is 86400.
            '''
            result = self._values.get("ike_lifetime")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_mode(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeMode: Negotiation mode for IKE V1. Value: main|aggressive, default: main.
            '''
            result = self._values.get("ike_mode")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_pfs(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikePfs: Diffie-Hellman key exchange algorithm used in the first phase negotiation. Value: group1|group2|group5|group14|group24, default value: group2.
            '''
            result = self._values.get("ike_pfs")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_version(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeVersion: The version of the IKE protocol. Value: ikev1|ikev2, default: ikev1.
            '''
            result = self._values.get("ike_version")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: localId: ID of the VPN gateway. The length is limited to 100 characters. The default value is the public IP address of the VPN gateway.
            '''
            result = self._values.get("local_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def psk(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: psk: Used for identity authentication between the IPsec VPN gateway and the user gateway. It is generated randomly by default, or you can specify the key manually. The length is limited to 100 characters.
            '''
            result = self._values.get("psk")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def remote_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: remoteId: ID of the user gateway. The length is limited to 100 characters. The default value is the public IP address of the user gateway.
            '''
            result = self._values.get("remote_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IkeConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection.IpsecConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ipsec_auth_alg": "ipsecAuthAlg",
            "ipsec_enc_alg": "ipsecEncAlg",
            "ipsec_lifetime": "ipsecLifetime",
            "ipsec_pfs": "ipsecPfs",
        },
    )
    class IpsecConfigProperty:
        def __init__(
            self,
            *,
            ipsec_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param ipsec_auth_alg: 
            :param ipsec_enc_alg: 
            :param ipsec_lifetime: 
            :param ipsec_pfs: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e73d2f883ca036313b49d62025580f8b7afb9c5d3c0aae0e444075c6e1b89252)
                check_type(argname="argument ipsec_auth_alg", value=ipsec_auth_alg, expected_type=type_hints["ipsec_auth_alg"])
                check_type(argname="argument ipsec_enc_alg", value=ipsec_enc_alg, expected_type=type_hints["ipsec_enc_alg"])
                check_type(argname="argument ipsec_lifetime", value=ipsec_lifetime, expected_type=type_hints["ipsec_lifetime"])
                check_type(argname="argument ipsec_pfs", value=ipsec_pfs, expected_type=type_hints["ipsec_pfs"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipsec_auth_alg is not None:
                self._values["ipsec_auth_alg"] = ipsec_auth_alg
            if ipsec_enc_alg is not None:
                self._values["ipsec_enc_alg"] = ipsec_enc_alg
            if ipsec_lifetime is not None:
                self._values["ipsec_lifetime"] = ipsec_lifetime
            if ipsec_pfs is not None:
                self._values["ipsec_pfs"] = ipsec_pfs

        @builtins.property
        def ipsec_auth_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ipsecAuthAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is md5|sha1|sha256|sha384|sha512, and the default value is md5.
            If the VPN gateway instance type is national secret type, The value is sm3 (default value).
            '''
            result = self._values.get("ipsec_auth_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_enc_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ipsecEncAlg: The authentication algorithm negotiated in the second phase.
            If the VPN gateway instance type is normal, the value is aes|aes192|aes256|des|3des, and the default value is aes.
            If the VPN gateway instance type is national secret type, The value is sm4 (default value).
            '''
            result = self._values.get("ipsec_enc_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_lifetime(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecLifetime: IpsecLifetime: The life cycle of the SA negotiated in the second phase. The value ranges from 0 to 86400, in seconds. The default value is 86400.
            '''
            result = self._values.get("ipsec_lifetime")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_pfs(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecPfs: Forwards all protocol packets. The Diffie-Hellman key exchange algorithm used in the first phase negotiation, the value: group1|group2|group5|group14|group24, default value: group2.
            '''
            result = self._values.get("ipsec_pfs")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpsecConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection.TunnelBgpConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "local_asn": "localAsn",
            "local_bgp_ip": "localBgpIp",
            "tunnel_cidr": "tunnelCidr",
        },
    )
    class TunnelBgpConfigProperty:
        def __init__(
            self,
            *,
            local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_bgp_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            tunnel_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param local_asn: 
            :param local_bgp_ip: 
            :param tunnel_cidr: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__65c691c3cb39b79d54384f064b45cdde8f8d96cc5976e4fe715b199375bb8d2b)
                check_type(argname="argument local_asn", value=local_asn, expected_type=type_hints["local_asn"])
                check_type(argname="argument local_bgp_ip", value=local_bgp_ip, expected_type=type_hints["local_bgp_ip"])
                check_type(argname="argument tunnel_cidr", value=tunnel_cidr, expected_type=type_hints["tunnel_cidr"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if local_asn is not None:
                self._values["local_asn"] = local_asn
            if local_bgp_ip is not None:
                self._values["local_bgp_ip"] = local_bgp_ip
            if tunnel_cidr is not None:
                self._values["tunnel_cidr"] = tunnel_cidr

        @builtins.property
        def local_asn(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: localAsn: the ASN on the Alibaba Cloud side. Valid values: 1 to 4294967295. Default value: 45104.
            '''
            result = self._values.get("local_asn")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_bgp_ip(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            localBgpIp: the BGP IP address on the Alibaba Cloud side.
            This IP address must fall within the CIDR block of the IPsec tunnel.
            '''
            result = self._values.get("local_bgp_ip")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def tunnel_cidr(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: tunnelCidr: the CIDR block of the IPsec tunnel. The CIDR block must fall within 169.254.0.0/16. The subnet mask of the CIDR block must be 30 bits in length.
            '''
            result = self._values.get("tunnel_cidr")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TunnelBgpConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection.TunnelIkeConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ike_auth_alg": "ikeAuthAlg",
            "ike_enc_alg": "ikeEncAlg",
            "ike_lifetime": "ikeLifetime",
            "ike_mode": "ikeMode",
            "ike_pfs": "ikePfs",
            "ike_version": "ikeVersion",
            "local_id": "localId",
            "psk": "psk",
            "remote_id": "remoteId",
        },
    )
    class TunnelIkeConfigProperty:
        def __init__(
            self,
            *,
            ike_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ike_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            local_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            remote_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param ike_auth_alg: 
            :param ike_enc_alg: 
            :param ike_lifetime: 
            :param ike_mode: 
            :param ike_pfs: 
            :param ike_version: 
            :param local_id: 
            :param psk: 
            :param remote_id: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5be189f3fe80ee84f5d7d664e3d2b255949a6ec2d6d49978932dc1b48e4e14d7)
                check_type(argname="argument ike_auth_alg", value=ike_auth_alg, expected_type=type_hints["ike_auth_alg"])
                check_type(argname="argument ike_enc_alg", value=ike_enc_alg, expected_type=type_hints["ike_enc_alg"])
                check_type(argname="argument ike_lifetime", value=ike_lifetime, expected_type=type_hints["ike_lifetime"])
                check_type(argname="argument ike_mode", value=ike_mode, expected_type=type_hints["ike_mode"])
                check_type(argname="argument ike_pfs", value=ike_pfs, expected_type=type_hints["ike_pfs"])
                check_type(argname="argument ike_version", value=ike_version, expected_type=type_hints["ike_version"])
                check_type(argname="argument local_id", value=local_id, expected_type=type_hints["local_id"])
                check_type(argname="argument psk", value=psk, expected_type=type_hints["psk"])
                check_type(argname="argument remote_id", value=remote_id, expected_type=type_hints["remote_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ike_auth_alg is not None:
                self._values["ike_auth_alg"] = ike_auth_alg
            if ike_enc_alg is not None:
                self._values["ike_enc_alg"] = ike_enc_alg
            if ike_lifetime is not None:
                self._values["ike_lifetime"] = ike_lifetime
            if ike_mode is not None:
                self._values["ike_mode"] = ike_mode
            if ike_pfs is not None:
                self._values["ike_pfs"] = ike_pfs
            if ike_version is not None:
                self._values["ike_version"] = ike_version
            if local_id is not None:
                self._values["local_id"] = local_id
            if psk is not None:
                self._values["psk"] = psk
            if remote_id is not None:
                self._values["remote_id"] = remote_id

        @builtins.property
        def ike_auth_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ikeAuthAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is md5|sha1|sha256|sha384|sha512, and the default value is md5.
            If the VPN gateway instance type is national secret type, The value is sm3 (default value).
            '''
            result = self._values.get("ike_auth_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_enc_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ikeEncAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is aes|aes192|aes256|des|3des, and the default value is aes.
            If the VPN gateway instance type is national secret type, The value is sm4 (default value).
            '''
            result = self._values.get("ike_enc_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_lifetime(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeLifetime: The life cycle of the SA negotiated in the first phase. The value ranges from 0 to 86400, in seconds. The default value is 86400.
            '''
            result = self._values.get("ike_lifetime")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_mode(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeMode: Negotiation mode for IKE V1. Value: main|aggressive, default: main.
            '''
            result = self._values.get("ike_mode")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_pfs(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikePfs: Diffie-Hellman key exchange algorithm used in the first phase negotiation. Value: group1|group2|group5|group14|group24, default value: group2.
            '''
            result = self._values.get("ike_pfs")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ike_version(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ikeVersion: The version of the IKE protocol. Value: ikev1|ikev2, default: ikev1.
            '''
            result = self._values.get("ike_version")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def local_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: localId: ID of the VPN gateway. The length is limited to 100 characters. The default value is the public IP address of the VPN gateway.
            '''
            result = self._values.get("local_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def psk(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: psk: Used for identity authentication between the IPsec VPN gateway and the user gateway. It is generated randomly by default, or you can specify the key manually. The length is limited to 100 characters.
            '''
            result = self._values.get("psk")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def remote_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: remoteId: ID of the user gateway. The length is limited to 100 characters. The default value is the public IP address of the user gateway.
            '''
            result = self._values.get("remote_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TunnelIkeConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection.TunnelIpsecConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ipsec_auth_alg": "ipsecAuthAlg",
            "ipsec_enc_alg": "ipsecEncAlg",
            "ipsec_lifetime": "ipsecLifetime",
            "ipsec_pfs": "ipsecPfs",
        },
    )
    class TunnelIpsecConfigProperty:
        def __init__(
            self,
            *,
            ipsec_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            ipsec_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param ipsec_auth_alg: 
            :param ipsec_enc_alg: 
            :param ipsec_lifetime: 
            :param ipsec_pfs: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4dcda3daa979b3e284b50ebd2a5371fb829e454309b6d4dc9768d41a425527ec)
                check_type(argname="argument ipsec_auth_alg", value=ipsec_auth_alg, expected_type=type_hints["ipsec_auth_alg"])
                check_type(argname="argument ipsec_enc_alg", value=ipsec_enc_alg, expected_type=type_hints["ipsec_enc_alg"])
                check_type(argname="argument ipsec_lifetime", value=ipsec_lifetime, expected_type=type_hints["ipsec_lifetime"])
                check_type(argname="argument ipsec_pfs", value=ipsec_pfs, expected_type=type_hints["ipsec_pfs"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipsec_auth_alg is not None:
                self._values["ipsec_auth_alg"] = ipsec_auth_alg
            if ipsec_enc_alg is not None:
                self._values["ipsec_enc_alg"] = ipsec_enc_alg
            if ipsec_lifetime is not None:
                self._values["ipsec_lifetime"] = ipsec_lifetime
            if ipsec_pfs is not None:
                self._values["ipsec_pfs"] = ipsec_pfs

        @builtins.property
        def ipsec_auth_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ipsecAuthAlg: The authentication algorithm negotiated in the first phase.
            If the VPN gateway instance type is normal, the value is md5|sha1|sha256|sha384|sha512, and the default value is md5.
            If the VPN gateway instance type is national secret type, The value is sm3 (default value).
            '''
            result = self._values.get("ipsec_auth_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_enc_alg(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            ipsecEncAlg: The authentication algorithm negotiated in the second phase.
            If the VPN gateway instance type is normal, the value is aes|aes192|aes256|des|3des, and the default value is aes.
            If the VPN gateway instance type is national secret type, The value is sm4 (default value).
            '''
            result = self._values.get("ipsec_enc_alg")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_lifetime(
            self,
        ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecLifetime: IpsecLifetime: The life cycle of the SA negotiated in the second phase. The value ranges from 0 to 86400, in seconds. The default value is 86400.
            '''
            result = self._values.get("ipsec_lifetime")
            return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def ipsec_pfs(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: ipsecPfs: Forwards all protocol packets. The Diffie-Hellman key exchange algorithm used in the first phase negotiation, the value: group1|group2|group5|group14|group24, default value: group2.
            '''
            result = self._values.get("ipsec_pfs")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TunnelIpsecConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnection.TunnelOptionsSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "customer_gateway_id": "customerGatewayId",
            "enable_dpd": "enableDpd",
            "enable_nat_traversal": "enableNatTraversal",
            "remote_ca_certificate": "remoteCaCertificate",
            "role": "role",
            "tunnel_bgp_config": "tunnelBgpConfig",
            "tunnel_ike_config": "tunnelIkeConfig",
            "tunnel_ipsec_config": "tunnelIpsecConfig",
        },
    )
    class TunnelOptionsSpecificationProperty:
        def __init__(
            self,
            *,
            customer_gateway_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            remote_ca_certificate: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            role: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
            tunnel_bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosVpnConnection.TunnelBgpConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            tunnel_ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosVpnConnection.TunnelIkeConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            tunnel_ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union["RosVpnConnection.TunnelIpsecConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''
            :param customer_gateway_id: 
            :param enable_dpd: 
            :param enable_nat_traversal: 
            :param remote_ca_certificate: 
            :param role: 
            :param tunnel_bgp_config: 
            :param tunnel_ike_config: 
            :param tunnel_ipsec_config: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__afc0b8cc0b749a73a090cae9d79228363d15a65b26b149e7c6c6906eb4ba3919)
                check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
                check_type(argname="argument enable_dpd", value=enable_dpd, expected_type=type_hints["enable_dpd"])
                check_type(argname="argument enable_nat_traversal", value=enable_nat_traversal, expected_type=type_hints["enable_nat_traversal"])
                check_type(argname="argument remote_ca_certificate", value=remote_ca_certificate, expected_type=type_hints["remote_ca_certificate"])
                check_type(argname="argument role", value=role, expected_type=type_hints["role"])
                check_type(argname="argument tunnel_bgp_config", value=tunnel_bgp_config, expected_type=type_hints["tunnel_bgp_config"])
                check_type(argname="argument tunnel_ike_config", value=tunnel_ike_config, expected_type=type_hints["tunnel_ike_config"])
                check_type(argname="argument tunnel_ipsec_config", value=tunnel_ipsec_config, expected_type=type_hints["tunnel_ipsec_config"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if customer_gateway_id is not None:
                self._values["customer_gateway_id"] = customer_gateway_id
            if enable_dpd is not None:
                self._values["enable_dpd"] = enable_dpd
            if enable_nat_traversal is not None:
                self._values["enable_nat_traversal"] = enable_nat_traversal
            if remote_ca_certificate is not None:
                self._values["remote_ca_certificate"] = remote_ca_certificate
            if role is not None:
                self._values["role"] = role
            if tunnel_bgp_config is not None:
                self._values["tunnel_bgp_config"] = tunnel_bgp_config
            if tunnel_ike_config is not None:
                self._values["tunnel_ike_config"] = tunnel_ike_config
            if tunnel_ipsec_config is not None:
                self._values["tunnel_ipsec_config"] = tunnel_ipsec_config

        @builtins.property
        def customer_gateway_id(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: customerGatewayId: The ID of the customer gateway.
            '''
            result = self._values.get("customer_gateway_id")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def enable_dpd(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            enableDpd: Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
            true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
            false: disables DPD. The IPsec initiator does not send DPD packets.
            '''
            result = self._values.get("enable_dpd")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def enable_nat_traversal(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            enableNatTraversal: Specifies whether to enable NAT traversal. Valid values:
            true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
            false
            '''
            result = self._values.get("enable_nat_traversal")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def remote_ca_certificate(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property:

            remoteCaCertificate: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.
            This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
            You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
            '''
            result = self._values.get("remote_ca_certificate")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def role(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: role: The tunnel role. Valid values: master|slave
            '''
            result = self._values.get("role")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        @builtins.property
        def tunnel_bgp_config(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelBgpConfigProperty"]]:
            '''
            :Property: tunnelBgpConfig: The BGP configurations.
            '''
            result = self._values.get("tunnel_bgp_config")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelBgpConfigProperty"]], result)

        @builtins.property
        def tunnel_ike_config(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelIkeConfigProperty"]]:
            '''
            :Property: tunnelIkeConfig: Configuration information for the first phase of negotiation.
            '''
            result = self._values.get("tunnel_ike_config")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelIkeConfigProperty"]], result)

        @builtins.property
        def tunnel_ipsec_config(
            self,
        ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelIpsecConfigProperty"]]:
            '''
            :Property: tunnelIpsecConfig: The configuration of Phase 2 negotiations.
            '''
            result = self._values.get("tunnel_ipsec_config")
            return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, "RosVpnConnection.TunnelIpsecConfigProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TunnelOptionsSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnConnectionProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_subnet": "localSubnet",
        "remote_subnet": "remoteSubnet",
        "vpn_gateway_id": "vpnGatewayId",
        "auto_config_route": "autoConfigRoute",
        "bgp_config": "bgpConfig",
        "customer_gateway_id": "customerGatewayId",
        "effect_immediately": "effectImmediately",
        "enable_dpd": "enableDpd",
        "enable_nat_traversal": "enableNatTraversal",
        "enable_tunnels_bgp": "enableTunnelsBgp",
        "health_check_config": "healthCheckConfig",
        "ike_config": "ikeConfig",
        "ipsec_config": "ipsecConfig",
        "name": "name",
        "remote_ca_certificate": "remoteCaCertificate",
        "tunnel_options_specification": "tunnelOptionsSpecification",
    },
)
class RosVpnConnectionProps:
    def __init__(
        self,
        *,
        local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        remote_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auto_config_route: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.BgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        customer_gateway_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_tunnels_bgp: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.HealthCheckConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        remote_ca_certificate: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tunnel_options_specification: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.TunnelOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''Properties for defining a ``RosVpnConnection``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnconnection

        :param local_subnet: 
        :param remote_subnet: 
        :param vpn_gateway_id: 
        :param auto_config_route: 
        :param bgp_config: 
        :param customer_gateway_id: 
        :param effect_immediately: 
        :param enable_dpd: 
        :param enable_nat_traversal: 
        :param enable_tunnels_bgp: 
        :param health_check_config: 
        :param ike_config: 
        :param ipsec_config: 
        :param name: 
        :param remote_ca_certificate: 
        :param tunnel_options_specification: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c07bef2a455b4ff902f477c74e0847a5fc2f67524dbdf5ad4fb6dc4a142ab8d2)
            check_type(argname="argument local_subnet", value=local_subnet, expected_type=type_hints["local_subnet"])
            check_type(argname="argument remote_subnet", value=remote_subnet, expected_type=type_hints["remote_subnet"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument auto_config_route", value=auto_config_route, expected_type=type_hints["auto_config_route"])
            check_type(argname="argument bgp_config", value=bgp_config, expected_type=type_hints["bgp_config"])
            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
            check_type(argname="argument effect_immediately", value=effect_immediately, expected_type=type_hints["effect_immediately"])
            check_type(argname="argument enable_dpd", value=enable_dpd, expected_type=type_hints["enable_dpd"])
            check_type(argname="argument enable_nat_traversal", value=enable_nat_traversal, expected_type=type_hints["enable_nat_traversal"])
            check_type(argname="argument enable_tunnels_bgp", value=enable_tunnels_bgp, expected_type=type_hints["enable_tunnels_bgp"])
            check_type(argname="argument health_check_config", value=health_check_config, expected_type=type_hints["health_check_config"])
            check_type(argname="argument ike_config", value=ike_config, expected_type=type_hints["ike_config"])
            check_type(argname="argument ipsec_config", value=ipsec_config, expected_type=type_hints["ipsec_config"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument remote_ca_certificate", value=remote_ca_certificate, expected_type=type_hints["remote_ca_certificate"])
            check_type(argname="argument tunnel_options_specification", value=tunnel_options_specification, expected_type=type_hints["tunnel_options_specification"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "local_subnet": local_subnet,
            "remote_subnet": remote_subnet,
            "vpn_gateway_id": vpn_gateway_id,
        }
        if auto_config_route is not None:
            self._values["auto_config_route"] = auto_config_route
        if bgp_config is not None:
            self._values["bgp_config"] = bgp_config
        if customer_gateway_id is not None:
            self._values["customer_gateway_id"] = customer_gateway_id
        if effect_immediately is not None:
            self._values["effect_immediately"] = effect_immediately
        if enable_dpd is not None:
            self._values["enable_dpd"] = enable_dpd
        if enable_nat_traversal is not None:
            self._values["enable_nat_traversal"] = enable_nat_traversal
        if enable_tunnels_bgp is not None:
            self._values["enable_tunnels_bgp"] = enable_tunnels_bgp
        if health_check_config is not None:
            self._values["health_check_config"] = health_check_config
        if ike_config is not None:
            self._values["ike_config"] = ike_config
        if ipsec_config is not None:
            self._values["ipsec_config"] = ipsec_config
        if name is not None:
            self._values["name"] = name
        if remote_ca_certificate is not None:
            self._values["remote_ca_certificate"] = remote_ca_certificate
        if tunnel_options_specification is not None:
            self._values["tunnel_options_specification"] = tunnel_options_specification

    @builtins.property
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        localSubnet: A network segment on the VPC side that needs to be interconnected with the local IDC for the second phase negotiation.
        Multiple network segments are separated by commas, for example: 192.168.1.0/24, 192.168.2.0/24.
        '''
        result = self._values.get("local_subnet")
        assert result is not None, "Required property 'local_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def remote_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        remoteSubnet: The network segment of the local IDC is used for the second phase negotiation.
        Multiple network segments are separated by commas, for example: 192.168.3.0/24, 192.168.4.0/24.
        '''
        result = self._values.get("remote_subnet")
        assert result is not None, "Required property 'remote_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: ID of the VPN gateway.
        '''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auto_config_route(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoConfigRoute: Specifies whether to automatically configure routes. Valid values:
        true (default)
        false
        '''
        result = self._values.get("auto_config_route")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def bgp_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.BgpConfigProperty]]:
        '''
        :Property:

        bgpConfig: The Border Gateway Protocol (BGP) configuration.
        This parameter is required when the VPN gateway has dynamic BGP enabled.
        Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see VPN Gateway supports BGP dynamic routing.
        We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP.
        Refer to the relevant documentation for the private ASN range.
        '''
        result = self._values.get("bgp_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.BgpConfigProperty]], result)

    @builtins.property
    def customer_gateway_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: customerGatewayId: The ID of the user gateway.
        '''
        result = self._values.get("customer_gateway_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        effectImmediately: Whether to delete the currently negotiated IPsec tunnel and re-initiate the negotiation. Value:
        True: Negotiate immediately after the configuration is complete.
        False (default): Negotiate when traffic enters.
        '''
        result = self._values.get("effect_immediately")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_dpd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableDpd: Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
        true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
        false: disables DPD. The IPsec initiator does not send DPD packets.
        '''
        result = self._values.get("enable_dpd")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_nat_traversal(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableNatTraversal: Specifies whether to enable NAT traversal. Valid values:
        true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
        false
        '''
        result = self._values.get("enable_nat_traversal")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_tunnels_bgp(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableTunnelsBgp: Specifies whether to enable the BGP feature for the tunnel.
        Valid values: true and false. Default value: false.
        '''
        result = self._values.get("enable_tunnels_bgp")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.HealthCheckConfigProperty]]:
        '''
        :Property: healthCheckConfig: Whether to enable the health check configuration.
        '''
        result = self._values.get("health_check_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.HealthCheckConfigProperty]], result)

    @builtins.property
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IkeConfigProperty]]:
        '''
        :Property: ikeConfig: Configuration information for the first phase of negotiation.
        '''
        result = self._values.get("ike_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IkeConfigProperty]], result)

    @builtins.property
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IpsecConfigProperty]]:
        '''
        :Property: ipsecConfig: Configuration information for the second phase negotiation.
        '''
        result = self._values.get("ipsec_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IpsecConfigProperty]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: The name of the IPsec connection.
        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_) and dashes (-), but cannot start with http:// or https:// .
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def remote_ca_certificate(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        remoteCaCertificate: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.
        This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
        You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
        '''
        result = self._values.get("remote_ca_certificate")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tunnel_options_specification(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.TunnelOptionsSpecificationProperty]]]]:
        '''
        :Property:

        tunnelOptionsSpecification: TunnelOptionsSpecification parameters are supported by dual-tunnel IPsec-VPN gateways.
        You can modify both the active and standby tunnels of the IPsec-VPN connection.
        '''
        result = self._values.get("tunnel_options_specification")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.TunnelOptionsSpecificationProperty]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVpnConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVpnGateway(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnGateway",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::VpnGateway``, which is used to create a VPN gateway.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``VpnGateway`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpngateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosVpnGatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eae9f315680ca0399bec18869bd126d5aed6d544e5454fd2608e96001039ef08)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ed6b67ec4fd4a2a5429c07998e0d4d48e8b0e048e31394c3e470da382c25529)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDisasterRecoveryInternetIp")
    def attr_disaster_recovery_internet_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: DisasterRecoveryInternetIp: The second IP address assigned by the system to create an IPsec-VPN connection.This attribute is returned only when the VPN gateway supports the dual-tunnel mode.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDisasterRecoveryInternetIp"))

    @builtins.property
    @jsii.member(jsii_name="attrDisasterRecoveryVSwitchId")
    def attr_disaster_recovery_v_switch_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: DisasterRecoveryVSwitchId: The ID of the second vSwitch associated with the VPN gateway.This attribute is returned only when the VPN gateway supports the dual-tunnel mode.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDisasterRecoveryVSwitchId"))

    @builtins.property
    @jsii.member(jsii_name="attrInternetIp")
    def attr_internet_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: InternetIp: The public IP address of the VPN gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInternetIp"))

    @builtins.property
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: OrderId: The order ID.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOrderId"))

    @builtins.property
    @jsii.member(jsii_name="attrSpec")
    def attr_spec(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: Spec: The specification of the VPN gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSpec"))

    @builtins.property
    @jsii.member(jsii_name="attrSslMaxConnections")
    def attr_ssl_max_connections(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: SslMaxConnections: The maximum number of concurrent SSL-VPN connections.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSslMaxConnections"))

    @builtins.property
    @jsii.member(jsii_name="attrSslVpnInternetIp")
    def attr_ssl_vpn_internet_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: SslVpnInternetIp: The IP address of the SSL-VPN connection.This attribute is returned only when the VPN gateway is a public VPN gateway and supports only the single-tunnel mode. In addition, the VPN gateway must have the SSL-VPN feature enabled.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSslVpnInternetIp"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpcId: The ID of the virtual private cloud (VPC) to which the VPN gateway belongs.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpcId"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnGatewayId")
    def attr_vpn_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpnGatewayId: ID of the VPN gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnGatewayId"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnType")
    def attr_vpn_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpnType: The type of the VPN gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnType"))

    @builtins.property
    @jsii.member(jsii_name="attrVSwitchId")
    def attr_v_switch_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VSwitchId: The ID of the vSwitch to which the VPN gateway belongs.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVSwitchId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="bandwidth")
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        bandwidth: The public network bandwidth of the VPN gateway, in Mbps.
        Value: 5|10|20|50|100|200.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "bandwidth"))

    @bandwidth.setter
    def bandwidth(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5239a3d8cbb8901c021c5adadc37a40928f8d2a1df989415ef9d97ae8b5fe08e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bandwidth", value)

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e66efcc2afd6381bf5623ea53a4a514a0ff194a3af2a816841d17dec0efe121)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: VPC ID to which the VPN gateway belongs.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b586949fdfc77a17811a7ae35e6b0846dbb5adbffb2ed700c7ab9e36c52d93e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcId", value)

    @builtins.property
    @jsii.member(jsii_name="autoPay")
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoPay: Whether to automatically pay the bill of the VPN gateway, the value:
        true: Automatically pays the bill for the VPN gateway.
        false: Does not automatically pay the bill for the VPN gateway.
        Default true.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "autoPay"))

    @auto_pay.setter
    def auto_pay(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c054eb0f4c3716a4ee8dc0032356696bc7598242b45ecf8e10cfc2f19789243)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoPay", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: Description of the VPN gateway.
        The length is 2-256 characters and must start with a letter or Chinese, but cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08850d626b6428d0bc1f3ce1e7e6551faf5b0ad8bc257fc193c28028a3e1f7f9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="disasterRecoveryVSwitchId")
    def disaster_recovery_v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        disasterRecoveryVSwitchId: The second vSwitch with which you want to associate the VPN gateway.
        If you call this operation in a region that supports the dual-tunnel mode, this parameter is required.
        You need to specify two vSwitches in different zones from the VPC associated with the VPN gateway to implement disaster recovery across zones.
        For a region that supports only one zone, disaster recovery across zones is not supported. We recommend that you specify two vSwitches in the zone to implement high availability. You can specify the same vSwitch.
        For more information about the regions and zones that support the dual-tunnel mode, see Upgrade a VPN gateway to enable the dual-tunnel mode.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "disasterRecoveryVSwitchId"))

    @disaster_recovery_v_switch_id.setter
    def disaster_recovery_v_switch_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e028c466fdc142342f42bbcb6854a7c9cc3ec2a24f066b50113963312c2aa5b9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disasterRecoveryVSwitchId", value)

    @builtins.property
    @jsii.member(jsii_name="enableIpsec")
    def enable_ipsec(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableIpsec: Whether to enable IPsec-VPN. The IPsec-VPN feature provides a site-to-site connection. You can securely connect your local data center network to a private network or two proprietary networks by creating an IPsec tunnel. Value:
        True (default): Enables the IPsec-VPN feature.
        False: The IPsec-VPN function is not enabled.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enableIpsec"))

    @enable_ipsec.setter
    def enable_ipsec(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db95aba88ee7f0e233942ecc8de5246c84ec8a5601836d632cca871845a9aa6b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIpsec", value)

    @builtins.property
    @jsii.member(jsii_name="enableSsl")
    def enable_ssl(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableSsl: Enable the SSL-VPN function. Provide point-to-site VPN connection, no need to configure customer gateway, terminal directly access. Value:
        True: Enable SSL-VPN.
        False (default): Does not enable SSL-VPN.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "enableSsl"))

    @enable_ssl.setter
    def enable_ssl(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb89515c21a65a687a37e5b6623748411b971c4f458d55e8ae59f3c45c501f5d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableSsl", value)

    @builtins.property
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        instanceChargeType: Accounting type of the VPN gateway, the value is:
        PREPAY, POSTPAY
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "instanceChargeType"))

    @instance_charge_type.setter
    def instance_charge_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17899c0c049da93f1f50a7744bdb86e01ebb8933ebe593e40293c039300f1cbf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceChargeType", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: Name of the VPN gateway. The default value is the ID of the VPN gateway.
        The length is 2~100 English or Chinese characters. It must start with a large or small letter or Chinese. It can contain numbers, underscores (_) and dashes (-). It cannot start with http:// or https://.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "name"))

    @name.setter
    def name(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf64680a92a2cc91db69dc066aee3723d13a39b8a6891c544cb5cbb4dccac5cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="networkType")
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: networkType: The network type of the VPN gateway. Valid values: public|private
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "networkType"))

    @network_type.setter
    def network_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c067d28bcf9e11ddf4031fe88638fc179b34deb031364a47a4a4f341fe02a95d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "networkType", value)

    @builtins.property
    @jsii.member(jsii_name="period")
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        period: Purchase time, value: 1~9|12|24|36.
        When the value of the InstanceChargeType parameter is PREPAY, this parameter is mandatory.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "period"))

    @period.setter
    def period(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34878d3a3ab1359bc1ef1853a872a70f6c4fbc99a18c59f6b08b5242e55ed02d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "period", value)

    @builtins.property
    @jsii.member(jsii_name="sslConnections")
    def ssl_connections(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: sslConnections: The maximum number of clients allowed to connect at the same time.
        '''
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "sslConnections"))

    @ssl_connections.setter
    def ssl_connections(
        self,
        value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed2dafc0e095edfeab1826510b32decbff57f751ed5ad159efa87e7c2c9cf422)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sslConnections", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["RosVpnGateway.TagsProperty"]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        return typing.cast(typing.Optional[typing.List["RosVpnGateway.TagsProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["RosVpnGateway.TagsProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f52211f3220057e51420e549ee27c885653e1c01cd4aebaaced0ff04566ddcf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @builtins.property
    @jsii.member(jsii_name="vpnType")
    def vpn_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: vpnType: VPN gateway type.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "vpnType"))

    @vpn_type.setter
    def vpn_type(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__633678c40138fcd0239f1887fdccc815e6a7118ce9f6d7470c4d292f90d4312b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpnType", value)

    @builtins.property
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: vSwitchId: The ID of the VSwitch to which the VPN gateway belongs.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "vSwitchId"))

    @v_switch_id.setter
    def v_switch_id(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf77ccf1bb76a0b2ff9eb01980aeaa3a4c172d3ba972abf8785c0ce012115a11)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vSwitchId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-vpc.RosVpnGateway.TagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagsProperty:
        def __init__(
            self,
            *,
            key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
            value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ) -> None:
            '''
            :param key: 
            :param value: 
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__12f9b4838b0f14300ae2b6516d930f4e2970a83dc5e8677351a0d10c15785565)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
            }
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
            '''
            :Property: key: undefined
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
            '''
            :Property: value: undefined
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "vpc_id": "vpcId",
        "auto_pay": "autoPay",
        "description": "description",
        "disaster_recovery_v_switch_id": "disasterRecoveryVSwitchId",
        "enable_ipsec": "enableIpsec",
        "enable_ssl": "enableSsl",
        "instance_charge_type": "instanceChargeType",
        "name": "name",
        "network_type": "networkType",
        "period": "period",
        "ssl_connections": "sslConnections",
        "tags": "tags",
        "vpn_type": "vpnType",
        "v_switch_id": "vSwitchId",
    },
)
class RosVpnGatewayProps:
    def __init__(
        self,
        *,
        bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        disaster_recovery_v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_ipsec: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_ssl: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ssl_connections: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosVpnGateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        vpn_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosVpnGateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpngateway

        :param bandwidth: 
        :param vpc_id: 
        :param auto_pay: 
        :param description: 
        :param disaster_recovery_v_switch_id: 
        :param enable_ipsec: 
        :param enable_ssl: 
        :param instance_charge_type: 
        :param name: 
        :param network_type: 
        :param period: 
        :param ssl_connections: 
        :param tags: 
        :param vpn_type: 
        :param v_switch_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49087521e8677b8a339e79a6db272ebf17ae80b7afe23f5620af413f04696307)
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument disaster_recovery_v_switch_id", value=disaster_recovery_v_switch_id, expected_type=type_hints["disaster_recovery_v_switch_id"])
            check_type(argname="argument enable_ipsec", value=enable_ipsec, expected_type=type_hints["enable_ipsec"])
            check_type(argname="argument enable_ssl", value=enable_ssl, expected_type=type_hints["enable_ssl"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument network_type", value=network_type, expected_type=type_hints["network_type"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument ssl_connections", value=ssl_connections, expected_type=type_hints["ssl_connections"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpn_type", value=vpn_type, expected_type=type_hints["vpn_type"])
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bandwidth": bandwidth,
            "vpc_id": vpc_id,
        }
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if description is not None:
            self._values["description"] = description
        if disaster_recovery_v_switch_id is not None:
            self._values["disaster_recovery_v_switch_id"] = disaster_recovery_v_switch_id
        if enable_ipsec is not None:
            self._values["enable_ipsec"] = enable_ipsec
        if enable_ssl is not None:
            self._values["enable_ssl"] = enable_ssl
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if name is not None:
            self._values["name"] = name
        if network_type is not None:
            self._values["network_type"] = network_type
        if period is not None:
            self._values["period"] = period
        if ssl_connections is not None:
            self._values["ssl_connections"] = ssl_connections
        if tags is not None:
            self._values["tags"] = tags
        if vpn_type is not None:
            self._values["vpn_type"] = vpn_type
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        bandwidth: The public network bandwidth of the VPN gateway, in Mbps.
        Value: 5|10|20|50|100|200.
        '''
        result = self._values.get("bandwidth")
        assert result is not None, "Required property 'bandwidth' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpcId: VPC ID to which the VPN gateway belongs.
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        autoPay: Whether to automatically pay the bill of the VPN gateway, the value:
        true: Automatically pays the bill for the VPN gateway.
        false: Does not automatically pay the bill for the VPN gateway.
        Default true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        description: Description of the VPN gateway.
        The length is 2-256 characters and must start with a letter or Chinese, but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def disaster_recovery_v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        disasterRecoveryVSwitchId: The second vSwitch with which you want to associate the VPN gateway.
        If you call this operation in a region that supports the dual-tunnel mode, this parameter is required.
        You need to specify two vSwitches in different zones from the VPC associated with the VPN gateway to implement disaster recovery across zones.
        For a region that supports only one zone, disaster recovery across zones is not supported. We recommend that you specify two vSwitches in the zone to implement high availability. You can specify the same vSwitch.
        For more information about the regions and zones that support the dual-tunnel mode, see Upgrade a VPN gateway to enable the dual-tunnel mode.
        '''
        result = self._values.get("disaster_recovery_v_switch_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_ipsec(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableIpsec: Whether to enable IPsec-VPN. The IPsec-VPN feature provides a site-to-site connection. You can securely connect your local data center network to a private network or two proprietary networks by creating an IPsec tunnel. Value:
        True (default): Enables the IPsec-VPN feature.
        False: The IPsec-VPN function is not enabled.
        '''
        result = self._values.get("enable_ipsec")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_ssl(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        enableSsl: Enable the SSL-VPN function. Provide point-to-site VPN connection, no need to configure customer gateway, terminal directly access. Value:
        True: Enable SSL-VPN.
        False (default): Does not enable SSL-VPN.
        '''
        result = self._values.get("enable_ssl")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        instanceChargeType: Accounting type of the VPN gateway, the value is:
        PREPAY, POSTPAY
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        name: Name of the VPN gateway. The default value is the ID of the VPN gateway.
        The length is 2~100 English or Chinese characters. It must start with a large or small letter or Chinese. It can contain numbers, underscores (_) and dashes (-). It cannot start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: networkType: The network type of the VPN gateway. Valid values: public|private
        '''
        result = self._values.get("network_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property:

        period: Purchase time, value: 1~9|12|24|36.
        When the value of the InstanceChargeType parameter is PREPAY, this parameter is mandatory.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ssl_connections(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: sslConnections: The maximum number of clients allowed to connect at the same time.
        '''
        result = self._values.get("ssl_connections")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosVpnGateway.TagsProperty]]:
        '''
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosVpnGateway.TagsProperty]], result)

    @builtins.property
    def vpn_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: vpnType: VPN gateway type.
        '''
        result = self._values.get("vpn_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: vSwitchId: The ID of the VSwitch to which the VPN gateway belongs.
        '''
        result = self._values.get("v_switch_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVpnGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVpnPbrRouteEntry(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnPbrRouteEntry",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::VpnPbrRouteEntry``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``VpnPbrRouteEntry`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnpbrrouteentry
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosVpnPbrRouteEntryProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f60ef5946d39284f5a749bbdf04dcab02d4d222b31dd6a0ddcfbbc0e1011417b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48ac0b1c736f73135f5286c3ca5f8b422606d13207cce639aba2b5d56363c233)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrNextHop")
    def attr_next_hop(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: NextHop: The next hop of the destination route entry.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNextHop"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteDest")
    def attr_route_dest(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouteDest: The destination CIDR block of the destination route.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteDest"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteSource")
    def attr_route_source(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouteSource: The destination CIDR block of the policy-based route.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteSource"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnGatewayId")
    def attr_vpn_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpnGatewayId: The ID of the VPN Gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnGatewayId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f6a74d988b9841bbee473590b82bd56f4582195df0e931d1334603f05c8fe5b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="nextHop")
    def next_hop(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: nextHop: The next hop of the destination route entry.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "nextHop"))

    @next_hop.setter
    def next_hop(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ada0c9fede2ec8c7bbf156065e01030c4b92b921f0b5697663aecbac5c130b1c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nextHop", value)

    @builtins.property
    @jsii.member(jsii_name="publishVpc")
    def publish_vpc(
        self,
    ) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        publishVpc: Indicates whether to publish the destination route to the VPC. Valid values:
        true: Publish the destination route to the VPC.
        false: Do not publish the destination route to the VPC.
        '''
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "publishVpc"))

    @publish_vpc.setter
    def publish_vpc(
        self,
        value: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf0dcf7fa8b983f4c33a90ef57936fec7b0ecc3628db3cef44a2183ffbe5d849)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "publishVpc", value)

    @builtins.property
    @jsii.member(jsii_name="routeDest")
    def route_dest(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routeDest: The destination CIDR block of the destination route.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routeDest"))

    @route_dest.setter
    def route_dest(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e831304443517a8cae3dc13e3da5f9250fd39ffe72a99aaba1c9ff49dd17da39)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routeDest", value)

    @builtins.property
    @jsii.member(jsii_name="routeSource")
    def route_source(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routeSource: The source CIDR block of the policy-based route.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routeSource"))

    @route_source.setter
    def route_source(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcb5999c4d4d50a7e71f66f4196aa648cfdddf9b9252c5437e6aec39c7876ae9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routeSource", value)

    @builtins.property
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: The ID of the VPN Gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpnGatewayId"))

    @vpn_gateway_id.setter
    def vpn_gateway_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ddbd6887f84815e97d404ed58e7a9beb3e977e6169e412e75f55a85e8e5cba6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpnGatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="weight")
    def weight(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: weight: The weight of the destination route. Valid values: 0|100.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "weight"))

    @weight.setter
    def weight(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c7ea2cdc0fee6efe2654cc661914cf91c77a55846ff272676a827b9e00ab419)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "weight", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: The description of the VPN destination route.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d46029aad4b7d51297604a6bd456d2b75ea23e53e8efdd76ef1f5d2be67245c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="overlayMode")
    def overlay_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: overlayMode: The overlay mode.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "overlayMode"))

    @overlay_mode.setter
    def overlay_mode(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f206a887e99412d2d86aa158b639050676b54df314c2f805961ecaa6d2a41ae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "overlayMode", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnPbrRouteEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "next_hop": "nextHop",
        "publish_vpc": "publishVpc",
        "route_dest": "routeDest",
        "route_source": "routeSource",
        "vpn_gateway_id": "vpnGatewayId",
        "weight": "weight",
        "description": "description",
        "overlay_mode": "overlayMode",
    },
)
class RosVpnPbrRouteEntryProps:
    def __init__(
        self,
        *,
        next_hop: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        publish_vpc: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
        route_dest: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        route_source: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        overlay_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosVpnPbrRouteEntry``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnpbrrouteentry

        :param next_hop: 
        :param publish_vpc: 
        :param route_dest: 
        :param route_source: 
        :param vpn_gateway_id: 
        :param weight: 
        :param description: 
        :param overlay_mode: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5519821cb9d1d2d9718681a376f572c31eea94be850661959f6bfc926c1fd017)
            check_type(argname="argument next_hop", value=next_hop, expected_type=type_hints["next_hop"])
            check_type(argname="argument publish_vpc", value=publish_vpc, expected_type=type_hints["publish_vpc"])
            check_type(argname="argument route_dest", value=route_dest, expected_type=type_hints["route_dest"])
            check_type(argname="argument route_source", value=route_source, expected_type=type_hints["route_source"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument overlay_mode", value=overlay_mode, expected_type=type_hints["overlay_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "next_hop": next_hop,
            "publish_vpc": publish_vpc,
            "route_dest": route_dest,
            "route_source": route_source,
            "vpn_gateway_id": vpn_gateway_id,
            "weight": weight,
        }
        if description is not None:
            self._values["description"] = description
        if overlay_mode is not None:
            self._values["overlay_mode"] = overlay_mode

    @builtins.property
    def next_hop(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: nextHop: The next hop of the destination route entry.
        '''
        result = self._values.get("next_hop")
        assert result is not None, "Required property 'next_hop' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def publish_vpc(
        self,
    ) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        publishVpc: Indicates whether to publish the destination route to the VPC. Valid values:
        true: Publish the destination route to the VPC.
        false: Do not publish the destination route to the VPC.
        '''
        result = self._values.get("publish_vpc")
        assert result is not None, "Required property 'publish_vpc' is missing"
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def route_dest(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routeDest: The destination CIDR block of the destination route.
        '''
        result = self._values.get("route_dest")
        assert result is not None, "Required property 'route_dest' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def route_source(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routeSource: The source CIDR block of the policy-based route.
        '''
        result = self._values.get("route_source")
        assert result is not None, "Required property 'route_source' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: The ID of the VPN Gateway.
        '''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def weight(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: weight: The weight of the destination route. Valid values: 0|100.
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: The description of the VPN destination route.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def overlay_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: overlayMode: The overlay mode.
        '''
        result = self._values.get("overlay_mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVpnPbrRouteEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVpnRouteEntry(
    _ros_cdk_core_7adfd82f.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnRouteEntry",
):
    '''This class is a base encapsulation around the ROS resource type ``ALIYUN::VPC::VpnRouteEntry``.

    :Note:

    This class does not contain additional functions, so it is recommended to use the ``VpnRouteEntry`` class instead of this class for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnrouteentry
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RosVpnRouteEntryProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        '''
        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af64cb9f65030562a4f6593525f5efc726c6a90340cf97c0214598735669f05f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__870e2556605fd5725a2ebd352de6cd9eca2b620f552dbb4f7f5ba2cb669c244b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrNextHop")
    def attr_next_hop(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: NextHop: The next hop of the destination route entry.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNextHop"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteDest")
    def attr_route_dest(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: RouteDest: The destination CIDR block of the destination route.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteDest"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnGatewayId")
    def attr_vpn_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''
        :Attribute: VpnGatewayId: The ID of the VPN Gateway.
        '''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnGatewayId"))

    @builtins.property
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "rosProperties"))

    @builtins.property
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableResourcePropertyConstraint"))

    @enable_resource_property_constraint.setter
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a897a0346327529e6903dd3fd63b9185d458c55247a03308abdff636e244cb2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property
    @jsii.member(jsii_name="nextHop")
    def next_hop(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: nextHop: The next hop of the destination route entry.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "nextHop"))

    @next_hop.setter
    def next_hop(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a400b8e9bf17386b005ef88317de4d5d53dddf70c9453ee61fee2fdc91322b24)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nextHop", value)

    @builtins.property
    @jsii.member(jsii_name="publishVpc")
    def publish_vpc(
        self,
    ) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        publishVpc: Indicates whether to publish the destination route to the VPC. Valid values:
        true: Publish the destination route to the VPC.
        false: Do not publish the destination route to the VPC.
        '''
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "publishVpc"))

    @publish_vpc.setter
    def publish_vpc(
        self,
        value: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5320b2dad33664e7f217a76593b3e1b8950b3aae25fbd44a50d0199871ed1540)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "publishVpc", value)

    @builtins.property
    @jsii.member(jsii_name="routeDest")
    def route_dest(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routeDest: The destination CIDR block of the destination route.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "routeDest"))

    @route_dest.setter
    def route_dest(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b445b952a122ccfcd97c7019d2d5b9be77230acf5abfa5d0d82036b723c2f3e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "routeDest", value)

    @builtins.property
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: The ID of the VPN Gateway.
        '''
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "vpnGatewayId"))

    @vpn_gateway_id.setter
    def vpn_gateway_id(
        self,
        value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e85a37d48307082907d2bac1ccaecf110b5856e9c41f3997580482594d62e766)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpnGatewayId", value)

    @builtins.property
    @jsii.member(jsii_name="weight")
    def weight(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: weight: The weight of the destination route. Valid values: 0|100.
        '''
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], jsii.get(self, "weight"))

    @weight.setter
    def weight(
        self,
        value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee91327a98143c8678529d1e0cfc6643087133479be4d12dc210c4947fca62e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "weight", value)

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: The description of the VPN destination route.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "description"))

    @description.setter
    def description(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f329241f84df0f125821cebd89bd53e3499596c79f281d3c76bd2af0c67f923)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="overlayMode")
    def overlay_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: overlayMode: The overlay mode.
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], jsii.get(self, "overlayMode"))

    @overlay_mode.setter
    def overlay_mode(
        self,
        value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f645d5afa84fd628815418df8bdc923aa36164a6710464b0eb47321ca8d339b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "overlayMode", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RosVpnRouteEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "next_hop": "nextHop",
        "publish_vpc": "publishVpc",
        "route_dest": "routeDest",
        "vpn_gateway_id": "vpnGatewayId",
        "weight": "weight",
        "description": "description",
        "overlay_mode": "overlayMode",
    },
)
class RosVpnRouteEntryProps:
    def __init__(
        self,
        *,
        next_hop: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        publish_vpc: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
        route_dest: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        overlay_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RosVpnRouteEntry``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnrouteentry

        :param next_hop: 
        :param publish_vpc: 
        :param route_dest: 
        :param vpn_gateway_id: 
        :param weight: 
        :param description: 
        :param overlay_mode: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2dbfd9e82e97612ee14d4d6934d9b7946e9eed4d3dfc0ca778938deb91a5139)
            check_type(argname="argument next_hop", value=next_hop, expected_type=type_hints["next_hop"])
            check_type(argname="argument publish_vpc", value=publish_vpc, expected_type=type_hints["publish_vpc"])
            check_type(argname="argument route_dest", value=route_dest, expected_type=type_hints["route_dest"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument overlay_mode", value=overlay_mode, expected_type=type_hints["overlay_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "next_hop": next_hop,
            "publish_vpc": publish_vpc,
            "route_dest": route_dest,
            "vpn_gateway_id": vpn_gateway_id,
            "weight": weight,
        }
        if description is not None:
            self._values["description"] = description
        if overlay_mode is not None:
            self._values["overlay_mode"] = overlay_mode

    @builtins.property
    def next_hop(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: nextHop: The next hop of the destination route entry.
        '''
        result = self._values.get("next_hop")
        assert result is not None, "Required property 'next_hop' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def publish_vpc(
        self,
    ) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property:

        publishVpc: Indicates whether to publish the destination route to the VPC. Valid values:
        true: Publish the destination route to the VPC.
        false: Do not publish the destination route to the VPC.
        '''
        result = self._values.get("publish_vpc")
        assert result is not None, "Required property 'publish_vpc' is missing"
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def route_dest(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: routeDest: The destination CIDR block of the destination route.
        '''
        result = self._values.get("route_dest")
        assert result is not None, "Required property 'route_dest' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: vpnGatewayId: The ID of the VPN Gateway.
        '''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def weight(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''
        :Property: weight: The weight of the destination route. Valid values: 0|100.
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: description: The description of the VPN destination route.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def overlay_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''
        :Property: overlayMode: The overlay mode.
        '''
        result = self._values.get("overlay_mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVpnRouteEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RouteTable(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RouteTable",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::RouteTable``, which is used to create a custom route table.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosRouteTable``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routetable
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RouteTableProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb8b046bb81ab7b694dce08c22c1db0c63932b94cb42cb58be18bb0070756dae)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouteTableId: The ID of the route table.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableName")
    def attr_route_table_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouteTableName: The name of the route table.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableName"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableType")
    def attr_route_table_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouteTableType: The type of the route table.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableType"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpcId: The ID of the VRouter to which the route table belongs.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpcId"))

    @builtins.property
    @jsii.member(jsii_name="attrVSwitchIds")
    def attr_v_switch_ids(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VSwitchIds: A list of VSwitches under the VPC.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVSwitchIds"))


class RouteTableAssociation(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RouteTableAssociation",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::RouteTableAssociation``, which is used to associate a custom routing table with a vSwitch in the same VPC.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosRouteTableAssociation``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routetableassociation
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RouteTableAssociationProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74db829651664507a05f08feba454dfaf152a8b9750f543f6d309a8ab5eb47a3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouteTableId: The ID of the route table.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrVSwitchId")
    def attr_v_switch_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VSwitchId: The VSwitch ID which the route table associated with.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVSwitchId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RouteTableAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"route_table_id": "routeTableId", "v_switch_id": "vSwitchId"},
)
class RouteTableAssociationProps:
    def __init__(
        self,
        *,
        route_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ) -> None:
        '''Properties for defining a ``RouteTableAssociation``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routetableassociation

        :param route_table_id: Property routeTableId: The ID of the route table.
        :param v_switch_id: Property vSwitchId: The ID of the VSwitch.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce1626791de7922aa0b909e8d14703c6bb04025f3ae5459e7accad7df40b7a6c)
            check_type(argname="argument route_table_id", value=route_table_id, expected_type=type_hints["route_table_id"])
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "route_table_id": route_table_id,
            "v_switch_id": v_switch_id,
        }

    @builtins.property
    def route_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routeTableId: The ID of the route table.'''
        result = self._values.get("route_table_id")
        assert result is not None, "Required property 'route_table_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vSwitchId: The ID of the VSwitch.'''
        result = self._values.get("v_switch_id")
        assert result is not None, "Required property 'v_switch_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RouteTableAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RouteTableProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "description": "description",
        "route_table_name": "routeTableName",
        "tags": "tags",
    },
)
class RouteTableProps:
    def __init__(
        self,
        *,
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        route_table_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosRouteTable.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``RouteTable``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routetable

        :param vpc_id: Property vpcId: The ID of the VPC to which the custom route table belongs.
        :param description: Property description: The description of the route table. The description must be 2 to 256 characters in length. The description must start with a letter, but cannot start with http:// or https://.
        :param route_table_name: Property routeTableName: The name of the route table. The name must be 2 to 128 characters in length. It can contain letters, numbers, periods (.), underscores (_), and hyphens (-). It must start with a letter and cannot start with http:// or https://.
        :param tags: Property tags: Tags to attach to routetable. Max support 20 tags to add during create routetable. Each tag with two properties Key and Value, and Key is required.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73fb5aecbf0881d7d9fbc1f39716c439c1c061229ef717da1b203c297d60e089)
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument route_table_name", value=route_table_name, expected_type=type_hints["route_table_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if description is not None:
            self._values["description"] = description
        if route_table_name is not None:
            self._values["route_table_name"] = route_table_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpcId: The ID of the VPC to which the custom route table belongs.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the route table.

        The description must be 2 to 256 characters in length. The description must start with a letter, but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def route_table_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property routeTableName: The name of the route table.

        The name must be 2 to 128 characters in length. It can contain letters, numbers, periods (.), underscores (_), and hyphens (-). It must start with a letter and cannot start with http:// or https://.
        '''
        result = self._values.get("route_table_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosRouteTable.TagsProperty]]:
        '''Property tags: Tags to attach to routetable.

        Max support 20 tags to add during create routetable. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosRouteTable.TagsProperty]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RouteTableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RouterInterface(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.RouterInterface",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::RouterInterface``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosRouterInterface``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routerinterface
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["RouterInterfaceProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d88edaf8524326b6f60accf31a58b82e12acb2d8810bb58de8002682777e378c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrRouterInterfaceId")
    def attr_router_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouterInterfaceId: The ID of created RouterInterface.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouterInterfaceId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.RouterInterfaceProps",
    jsii_struct_bases=[],
    name_mapping={
        "role": "role",
        "router_id": "routerId",
        "access_point_id": "accessPointId",
        "auto_pay": "autoPay",
        "description": "description",
        "health_check_source_ip": "healthCheckSourceIp",
        "health_check_target_ip": "healthCheckTargetIp",
        "instance_charge_type": "instanceChargeType",
        "name": "name",
        "opposite_access_point_id": "oppositeAccessPointId",
        "opposite_interface_id": "oppositeInterfaceId",
        "opposite_interface_owner_id": "oppositeInterfaceOwnerId",
        "opposite_region_id": "oppositeRegionId",
        "opposite_router_id": "oppositeRouterId",
        "opposite_router_type": "oppositeRouterType",
        "period": "period",
        "pricing_cycle": "pricingCycle",
        "router_type": "routerType",
        "spec": "spec",
    },
)
class RouterInterfaceProps:
    def __init__(
        self,
        *,
        role: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        access_point_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_source_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_target_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_access_point_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_interface_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_interface_owner_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_router_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        opposite_router_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        router_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        spec: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``RouterInterface``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-routerinterface

        :param role: Property role: RouterInterface role. Now support 'InitiatingSide|AcceptingSide'.
        :param router_id: Property routerId: The router ID to create RouterInterface.
        :param access_point_id: Property accessPointId: Access point ID. If 'RouterType' is specified as 'VBR', the value is required.
        :param auto_pay: Property autoPay: Indicates whether automatic payment is enabled. Valid values: false: Automatic payment is disabled. You need to go to Orders to make the payment once an order is generated. true: Automatic payment is enabled. The payment is automatically made. Default: true.
        :param description: Property description: Custom description of the RouterInterface, [2, 256] characters. Don't fill or empty, the default is empty.
        :param health_check_source_ip: Property healthCheckSourceIp: Source IP address of the packet for leased line HealthCheck in leased line disaster tolerance and ECMP scenarios. It is valid only for a VRouter RouterInterface with a peer on a VBR. The source IP address must be in the VPC of the local VRouter and is not used. HealthCheckSourceIp and HealthCheckTargetIp parameters must be both specified or left unspecified.
        :param health_check_target_ip: Property healthCheckTargetIp: Target IP address of the packet for leased line HealthCheck in leased line disaster tolerance and ECMP scenarios. It is valid only for a VRouter RouterInterface with a peer on a VBR. Usually you can use the CPE IP address of the leased line user's client (that is, the PeerGatewayIP on the VBR of the peer RouterInterface), you can also specify another IP address of the leased line user's client as the HealthCheck target IP address. HealthCheckSourceIp and HealthCheckTargetIp parameters must be both specified or left unspecified.
        :param instance_charge_type: Property instanceChargeType: The billing method of the router interface. Valid values: PrePaid (Subscription), PostPaid (default, Pay-As-You-Go)
        :param name: Property name: Custom name of the RouterInterface, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
        :param opposite_access_point_id: Property oppositeAccessPointId: Access point ID of the connection peer RouterInterface. If 'OppositeRouterType' is specified as 'VBR', the value is required.
        :param opposite_interface_id: Property oppositeInterfaceId: The ID of the peer router interface.
        :param opposite_interface_owner_id: Property oppositeInterfaceOwnerId: Owner account ID of the connection peer RouterInterface. The default value is current user Id.
        :param opposite_region_id: Property oppositeRegionId: The region where the connection peer RouterInterface locates. The default value is region where stack is created.
        :param opposite_router_id: Property oppositeRouterId: The router ID of the connection peer RouterInterface.
        :param opposite_router_type: Property oppositeRouterType: Router type of the connection peer router. Now support 'VRouter|VBR'. If 'RouterType' is specified as 'VBR', the value must be 'VRouter'.
        :param period: Property period: Prepaid time period. It could be from 1 to 9 when PricingCycle is Month, or 1 to 3 when PricingCycle is Year.
        :param pricing_cycle: Property pricingCycle: Unit of the payment cycle. It could be Month (default) or Year.
        :param router_type: Property routerType: Router type. Now support 'VRouter|VBR'
        :param spec: Property spec: RouterInterface specification. If 'Role' is specified as 'InitiatingSide', the value is required. If 'Role' is specified as 'AcceptingSide', the value is set as 'Negative' by default.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd832dfc2d796baac3ce4d5cf992add1f084dac326049841fd8002bd78415d89)
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument router_id", value=router_id, expected_type=type_hints["router_id"])
            check_type(argname="argument access_point_id", value=access_point_id, expected_type=type_hints["access_point_id"])
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument health_check_source_ip", value=health_check_source_ip, expected_type=type_hints["health_check_source_ip"])
            check_type(argname="argument health_check_target_ip", value=health_check_target_ip, expected_type=type_hints["health_check_target_ip"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument opposite_access_point_id", value=opposite_access_point_id, expected_type=type_hints["opposite_access_point_id"])
            check_type(argname="argument opposite_interface_id", value=opposite_interface_id, expected_type=type_hints["opposite_interface_id"])
            check_type(argname="argument opposite_interface_owner_id", value=opposite_interface_owner_id, expected_type=type_hints["opposite_interface_owner_id"])
            check_type(argname="argument opposite_region_id", value=opposite_region_id, expected_type=type_hints["opposite_region_id"])
            check_type(argname="argument opposite_router_id", value=opposite_router_id, expected_type=type_hints["opposite_router_id"])
            check_type(argname="argument opposite_router_type", value=opposite_router_type, expected_type=type_hints["opposite_router_type"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument pricing_cycle", value=pricing_cycle, expected_type=type_hints["pricing_cycle"])
            check_type(argname="argument router_type", value=router_type, expected_type=type_hints["router_type"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "role": role,
            "router_id": router_id,
        }
        if access_point_id is not None:
            self._values["access_point_id"] = access_point_id
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if description is not None:
            self._values["description"] = description
        if health_check_source_ip is not None:
            self._values["health_check_source_ip"] = health_check_source_ip
        if health_check_target_ip is not None:
            self._values["health_check_target_ip"] = health_check_target_ip
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if name is not None:
            self._values["name"] = name
        if opposite_access_point_id is not None:
            self._values["opposite_access_point_id"] = opposite_access_point_id
        if opposite_interface_id is not None:
            self._values["opposite_interface_id"] = opposite_interface_id
        if opposite_interface_owner_id is not None:
            self._values["opposite_interface_owner_id"] = opposite_interface_owner_id
        if opposite_region_id is not None:
            self._values["opposite_region_id"] = opposite_region_id
        if opposite_router_id is not None:
            self._values["opposite_router_id"] = opposite_router_id
        if opposite_router_type is not None:
            self._values["opposite_router_type"] = opposite_router_type
        if period is not None:
            self._values["period"] = period
        if pricing_cycle is not None:
            self._values["pricing_cycle"] = pricing_cycle
        if router_type is not None:
            self._values["router_type"] = router_type
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def role(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property role: RouterInterface role.

        Now support 'InitiatingSide|AcceptingSide'.
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def router_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routerId: The router ID to create RouterInterface.'''
        result = self._values.get("router_id")
        assert result is not None, "Required property 'router_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def access_point_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property accessPointId: Access point ID.

        If 'RouterType' is specified as 'VBR', the value is required.
        '''
        result = self._values.get("access_point_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoPay: Indicates whether automatic payment is enabled.

        Valid values:
        false: Automatic payment is disabled. You need to go to Orders to make the payment once an order is generated.
        true: Automatic payment is enabled. The payment is automatically made.
        Default: true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Custom description of the RouterInterface, [2, 256] characters.

        Don't fill or empty, the default is empty.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_source_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property healthCheckSourceIp: Source IP address of the packet for leased line HealthCheck in leased line disaster tolerance and ECMP scenarios.

        It is valid only for a VRouter RouterInterface with a peer on a VBR. The source IP address must be in the VPC of the local VRouter and is not used. HealthCheckSourceIp and HealthCheckTargetIp parameters must be both specified or left unspecified.
        '''
        result = self._values.get("health_check_source_ip")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_target_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property healthCheckTargetIp: Target IP address of the packet for leased line HealthCheck in leased line disaster tolerance and ECMP scenarios.

        It is valid only for a VRouter RouterInterface with a peer on a VBR. Usually you can use the CPE IP address of the leased line user's client (that is, the PeerGatewayIP on the VBR of the peer RouterInterface), you can also specify another IP address of the leased line user's client as the HealthCheck target IP address. HealthCheckSourceIp and HealthCheckTargetIp parameters must be both specified or left unspecified.
        '''
        result = self._values.get("health_check_target_ip")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceChargeType: The billing method of the router interface.

        Valid values: PrePaid (Subscription), PostPaid (default, Pay-As-You-Go)
        '''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: Custom name of the RouterInterface, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_access_point_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property oppositeAccessPointId: Access point ID of the connection peer RouterInterface.

        If 'OppositeRouterType' is specified as 'VBR', the value is required.
        '''
        result = self._values.get("opposite_access_point_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_interface_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property oppositeInterfaceId: The ID of the peer router interface.'''
        result = self._values.get("opposite_interface_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_interface_owner_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property oppositeInterfaceOwnerId: Owner account ID of the connection peer RouterInterface.

        The default value is current user Id.
        '''
        result = self._values.get("opposite_interface_owner_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_region_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property oppositeRegionId: The region where the connection peer RouterInterface locates.

        The default value is region where stack is created.
        '''
        result = self._values.get("opposite_region_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_router_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property oppositeRouterId: The router ID of the connection peer RouterInterface.'''
        result = self._values.get("opposite_router_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def opposite_router_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property oppositeRouterType: Router type of the connection peer router.

        Now support 'VRouter|VBR'. If 'RouterType' is specified as 'VBR', the value must be 'VRouter'.
        '''
        result = self._values.get("opposite_router_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property period: Prepaid time period.

        It could be from 1 to 9 when PricingCycle is Month, or 1 to 3 when PricingCycle is Year.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def pricing_cycle(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property pricingCycle: Unit of the payment cycle.

        It could be Month (default) or Year.
        '''
        result = self._values.get("pricing_cycle")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def router_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property routerType: Router type.

        Now support 'VRouter|VBR'
        '''
        result = self._values.get("router_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def spec(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property spec: RouterInterface specification.

        If 'Role' is specified as 'InitiatingSide', the value is required. If 'Role' is specified as 'AcceptingSide', the value is set as 'Negative' by default.
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RouterInterfaceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnatEntry(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.SnatEntry",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::SnatEntry``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosSnatEntry``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-snatentry
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["SnatEntryProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b3b3d8999976f00e35e33034605972fd400f901709cd21a14b642134ca0ee5a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrSnatEntryIds")
    def attr_snat_entry_ids(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute SnatEntryIds: The IDS of the SNAT entry.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSnatEntryIds"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.SnatEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "snat_ip": "snatIp",
        "snat_table_id": "snatTableId",
        "eip_affinity": "eipAffinity",
        "snat_entry_name": "snatEntryName",
        "source_cidr": "sourceCidr",
        "source_v_switch_ids": "sourceVSwitchIds",
    },
)
class SnatEntryProps:
    def __init__(
        self,
        *,
        snat_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        snat_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        eip_affinity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        snat_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        source_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        source_v_switch_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    ) -> None:
        '''Properties for defining a ``SnatEntry``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-snatentry

        :param snat_ip: Property snatIp: The public IP address. Separate multiple EIPs with commas.
        :param snat_table_id: Property snatTableId: The ID of the SNAT table.
        :param eip_affinity: Property eipAffinity: Specifies whether to enable EIP affinity. Valid values: 0: no 1: yes If EIP affinity is enabled and the SNAT entry is associated with multiple EIPs, a client uses the same EIP to access the Internet. Otherwise, the client uses an EIP selected from the associated EIPs to access the Internet.
        :param snat_entry_name: Property snatEntryName: he name of the SNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        :param source_cidr: Property sourceCidr: Specifies the network segment of the switch. For example, 10.0.0.1/24. This parameter and the SourceVSwtichId parameter are mutually exclusive and cannot appear at the same time.
        :param source_v_switch_ids: Property sourceVSwitchIds: The ID of the VSwitch to access the Internet.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20c3a4ca9985f5a91cd47462b0da2510489cf5937cebd61309ba6ed25bec5233)
            check_type(argname="argument snat_ip", value=snat_ip, expected_type=type_hints["snat_ip"])
            check_type(argname="argument snat_table_id", value=snat_table_id, expected_type=type_hints["snat_table_id"])
            check_type(argname="argument eip_affinity", value=eip_affinity, expected_type=type_hints["eip_affinity"])
            check_type(argname="argument snat_entry_name", value=snat_entry_name, expected_type=type_hints["snat_entry_name"])
            check_type(argname="argument source_cidr", value=source_cidr, expected_type=type_hints["source_cidr"])
            check_type(argname="argument source_v_switch_ids", value=source_v_switch_ids, expected_type=type_hints["source_v_switch_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "snat_ip": snat_ip,
            "snat_table_id": snat_table_id,
        }
        if eip_affinity is not None:
            self._values["eip_affinity"] = eip_affinity
        if snat_entry_name is not None:
            self._values["snat_entry_name"] = snat_entry_name
        if source_cidr is not None:
            self._values["source_cidr"] = source_cidr
        if source_v_switch_ids is not None:
            self._values["source_v_switch_ids"] = source_v_switch_ids

    @builtins.property
    def snat_ip(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property snatIp: The public IP address.

        Separate multiple EIPs with commas.
        '''
        result = self._values.get("snat_ip")
        assert result is not None, "Required property 'snat_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def snat_table_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property snatTableId: The ID of the SNAT table.'''
        result = self._values.get("snat_table_id")
        assert result is not None, "Required property 'snat_table_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def eip_affinity(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property eipAffinity: Specifies whether to enable EIP affinity.

        Valid values:
        0: no
        1: yes
        If EIP affinity is enabled and the SNAT entry is associated with multiple EIPs, a client uses the same EIP to access the Internet. Otherwise, the client uses an EIP selected from the associated EIPs to access the Internet.
        '''
        result = self._values.get("eip_affinity")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def snat_entry_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property snatEntryName: he name of the SNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.'''
        result = self._values.get("snat_entry_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def source_cidr(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property sourceCidr: Specifies the network segment of the switch.

        For example, 10.0.0.1/24. This parameter and the SourceVSwtichId parameter are mutually exclusive and cannot appear at the same time.
        '''
        result = self._values.get("source_cidr")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def source_v_switch_ids(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]]:
        '''Property sourceVSwitchIds: The ID of the VSwitch to access the Internet.'''
        result = self._values.get("source_v_switch_ids")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnatEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SslVpnClientCert(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.SslVpnClientCert",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::SslVpnClientCert``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosSslVpnClientCert``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-sslvpnclientcert
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["SslVpnClientCertProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a76526b36f8928eac8ea09df6cb1ce761a5ee0bcb98f63cc329d7c1e5821594c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrSslVpnClientCertId")
    def attr_ssl_vpn_client_cert_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute SslVpnClientCertId: The ID of the client certificate.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSslVpnClientCertId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.SslVpnClientCertProps",
    jsii_struct_bases=[],
    name_mapping={"ssl_vpn_server_id": "sslVpnServerId", "name": "name"},
)
class SslVpnClientCertProps:
    def __init__(
        self,
        *,
        ssl_vpn_server_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``SslVpnClientCert``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-sslvpnclientcert

        :param ssl_vpn_server_id: Property sslVpnServerId: ID of the SSL-VPN server.
        :param name: Property name: The name of the client certificate. The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__546c17972d2a848da46028938b25b0080c7aeaeb17f2c75f5827fda2222a63c9)
            check_type(argname="argument ssl_vpn_server_id", value=ssl_vpn_server_id, expected_type=type_hints["ssl_vpn_server_id"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ssl_vpn_server_id": ssl_vpn_server_id,
        }
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def ssl_vpn_server_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property sslVpnServerId: ID of the SSL-VPN server.'''
        result = self._values.get("ssl_vpn_server_id")
        assert result is not None, "Required property 'ssl_vpn_server_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the client certificate.

        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SslVpnClientCertProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SslVpnServer(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.SslVpnServer",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::SslVpnServer``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosSslVpnServer``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-sslvpnserver
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["SslVpnServerProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7a434ddbc4ef2be51f5c635c78257a1bc63a5cdc584413d37a134215352be78)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrSslVpnServerId")
    def attr_ssl_vpn_server_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute SslVpnServerId: ID of the SSL-VPN server.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSslVpnServerId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.SslVpnServerProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_ip_pool": "clientIpPool",
        "local_subnet": "localSubnet",
        "vpn_gateway_id": "vpnGatewayId",
        "cipher": "cipher",
        "compress": "compress",
        "name": "name",
        "port": "port",
        "proto": "proto",
    },
)
class SslVpnServerProps:
    def __init__(
        self,
        *,
        client_ip_pool: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        cipher: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        compress: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        proto: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``SslVpnServer``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-sslvpnserver

        :param client_ip_pool: Property clientIpPool: It is the address segment that assigns the access address to the client virtual NIC. It does not refer to the existing intranet segment of the client. When the client accesses the local end through an SSL-VPN connection, the VPN gateway allocates an IP address to the client from the specified client network segment. The network segment cannot conflict with the LocalSubnet address segment.
        :param local_subnet: Property localSubnet: Is the address segment that the client wants to access through an SSL-VPN connection. The local network segment can be the network segment of the VPC, the network segment of the switch, the network segment of the IDC interconnected by the leased line and the VPC, and the network segment of the cloud service such as RDS/OSS.
        :param vpn_gateway_id: Property vpnGatewayId: ID of the VPN gateway.
        :param cipher: Property cipher: The encryption algorithm used by SSL-VPN. Value: AES-128-CBC (default) | AES-192-CBC | AES-256-CBC | none
        :param compress: Property compress: Whether it is compressed.
        :param name: Property name: The name of the SSL-VPN server. The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-). But it can't start with http:// or https://.
        :param port: Property port: The port used by the SSL-VPN server. The default value is 1194. Cannot use the following ports: 22, 2222, 22222, 9000, 9001, 9002, 7505, 80, 443, 53, 68, 123, 4510, 4560, 500, 4500
        :param proto: Property proto: The protocol used by the SSL-VPN server. Allowed values: UDP (default) | TCP.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51cdd9a696ae9679f9bd22e1edbf7bdd165b6336794fa196a29126667b6cf20c)
            check_type(argname="argument client_ip_pool", value=client_ip_pool, expected_type=type_hints["client_ip_pool"])
            check_type(argname="argument local_subnet", value=local_subnet, expected_type=type_hints["local_subnet"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument cipher", value=cipher, expected_type=type_hints["cipher"])
            check_type(argname="argument compress", value=compress, expected_type=type_hints["compress"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument proto", value=proto, expected_type=type_hints["proto"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_ip_pool": client_ip_pool,
            "local_subnet": local_subnet,
            "vpn_gateway_id": vpn_gateway_id,
        }
        if cipher is not None:
            self._values["cipher"] = cipher
        if compress is not None:
            self._values["compress"] = compress
        if name is not None:
            self._values["name"] = name
        if port is not None:
            self._values["port"] = port
        if proto is not None:
            self._values["proto"] = proto

    @builtins.property
    def client_ip_pool(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property clientIpPool: It is the address segment that assigns the access address to the client virtual NIC.

        It does not refer to the existing intranet segment of the client.
        When the client accesses the local end through an SSL-VPN connection, the VPN gateway allocates an IP address to the client from the specified client network segment.
        The network segment cannot conflict with the LocalSubnet address segment.
        '''
        result = self._values.get("client_ip_pool")
        assert result is not None, "Required property 'client_ip_pool' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property localSubnet: Is the address segment that the client wants to access through an SSL-VPN connection.

        The local network segment can be the network segment of the VPC, the network segment of the switch, the network segment of the IDC interconnected by the leased line and the VPC, and the network segment of the cloud service such as RDS/OSS.
        '''
        result = self._values.get("local_subnet")
        assert result is not None, "Required property 'local_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpnGatewayId: ID of the VPN gateway.'''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def cipher(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property cipher: The encryption algorithm used by SSL-VPN.

        Value:
        AES-128-CBC (default) | AES-192-CBC | AES-256-CBC | none
        '''
        result = self._values.get("cipher")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def compress(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property compress: Whether it is compressed.'''
        result = self._values.get("compress")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the SSL-VPN server.

        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_), and dashes (-).
        But it can't start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def port(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property port: The port used by the SSL-VPN server.

        The default value is 1194. Cannot use the following ports:
        22, 2222, 22222, 9000, 9001, 9002, 7505, 80, 443, 53, 68, 123, 4510, 4560, 500, 4500
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def proto(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property proto: The protocol used by the SSL-VPN server.

        Allowed values: UDP (default) | TCP.
        '''
        result = self._values.get("proto")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SslVpnServerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TrafficMirrorFilter(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.TrafficMirrorFilter",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::TrafficMirrorFilter``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosTrafficMirrorFilter``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorfilter
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Optional[typing.Union["TrafficMirrorFilterProps", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__131a1e0666b2b74708f9419a064e6556a9006ebe2112822870109d7339613740)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrEgressRules")
    def attr_egress_rules(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute EgressRules: Egress rules.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrEgressRules"))

    @builtins.property
    @jsii.member(jsii_name="attrIngressRules")
    def attr_ingress_rules(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute IngressRules: Ingress rules.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrIngressRules"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficMirrorFilterDescription")
    def attr_traffic_mirror_filter_description(
        self,
    ) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute TrafficMirrorFilterDescription: The description of the filter.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficMirrorFilterDescription"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficMirrorFilterId")
    def attr_traffic_mirror_filter_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute TrafficMirrorFilterId: The ID of the filter.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficMirrorFilterId"))

    @builtins.property
    @jsii.member(jsii_name="attrTrafficMirrorFilterName")
    def attr_traffic_mirror_filter_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute TrafficMirrorFilterName: The name of the filter.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficMirrorFilterName"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.TrafficMirrorFilterProps",
    jsii_struct_bases=[],
    name_mapping={
        "egress_rules": "egressRules",
        "ingress_rules": "ingressRules",
        "traffic_mirror_filter_description": "trafficMirrorFilterDescription",
        "traffic_mirror_filter_name": "trafficMirrorFilterName",
    },
)
class TrafficMirrorFilterProps:
    def __init__(
        self,
        *,
        egress_rules: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosTrafficMirrorFilter.EgressRulesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ingress_rules: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosTrafficMirrorFilter.IngressRulesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        traffic_mirror_filter_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        traffic_mirror_filter_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``TrafficMirrorFilter``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorfilter

        :param egress_rules: Property egressRules: Egress rules.
        :param ingress_rules: Property ingressRules: Ingress rules.
        :param traffic_mirror_filter_description: Property trafficMirrorFilterDescription: The description of the filter. The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        :param traffic_mirror_filter_name: Property trafficMirrorFilterName: The name of the filter.The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b983335103beb9a9466f93a101c35c691f3d2b123e4e8ea508582bea0688e47)
            check_type(argname="argument egress_rules", value=egress_rules, expected_type=type_hints["egress_rules"])
            check_type(argname="argument ingress_rules", value=ingress_rules, expected_type=type_hints["ingress_rules"])
            check_type(argname="argument traffic_mirror_filter_description", value=traffic_mirror_filter_description, expected_type=type_hints["traffic_mirror_filter_description"])
            check_type(argname="argument traffic_mirror_filter_name", value=traffic_mirror_filter_name, expected_type=type_hints["traffic_mirror_filter_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if egress_rules is not None:
            self._values["egress_rules"] = egress_rules
        if ingress_rules is not None:
            self._values["ingress_rules"] = ingress_rules
        if traffic_mirror_filter_description is not None:
            self._values["traffic_mirror_filter_description"] = traffic_mirror_filter_description
        if traffic_mirror_filter_name is not None:
            self._values["traffic_mirror_filter_name"] = traffic_mirror_filter_name

    @builtins.property
    def egress_rules(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.EgressRulesProperty]]]]:
        '''Property egressRules: Egress rules.'''
        result = self._values.get("egress_rules")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.EgressRulesProperty]]]], result)

    @builtins.property
    def ingress_rules(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.IngressRulesProperty]]]]:
        '''Property ingressRules: Ingress rules.'''
        result = self._values.get("ingress_rules")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.IngressRulesProperty]]]], result)

    @builtins.property
    def traffic_mirror_filter_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property trafficMirrorFilterDescription: The description of the filter.

        The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("traffic_mirror_filter_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def traffic_mirror_filter_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property trafficMirrorFilterName: The name of the filter.The name must be 1 to 128 characters in length and cannot start with http:// or https://.'''
        result = self._values.get("traffic_mirror_filter_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TrafficMirrorFilterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TrafficMirrorSession(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.TrafficMirrorSession",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::TrafficMirrorSession``DATASOURCE::VPC::NatGateways is used to query NAT gateways.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosTrafficMirrorSession``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorsession
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["TrafficMirrorSessionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af7d6f8aa393f21956211608da10c118a5b54fca065de3ac6d16a19fe791b0fb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrTrafficMirrorSessionId")
    def attr_traffic_mirror_session_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute TrafficMirrorSessionId: The ID of the traffic mirror session.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrTrafficMirrorSessionId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.TrafficMirrorSessionProps",
    jsii_struct_bases=[],
    name_mapping={
        "priority": "priority",
        "traffic_mirror_filter_id": "trafficMirrorFilterId",
        "traffic_mirror_source_ids": "trafficMirrorSourceIds",
        "traffic_mirror_target_id": "trafficMirrorTargetId",
        "traffic_mirror_target_type": "trafficMirrorTargetType",
        "enabled": "enabled",
        "packet_length": "packetLength",
        "resource_group_id": "resourceGroupId",
        "tag": "tag",
        "traffic_mirror_session_description": "trafficMirrorSessionDescription",
        "traffic_mirror_session_name": "trafficMirrorSessionName",
        "virtual_network_id": "virtualNetworkId",
    },
)
class TrafficMirrorSessionProps:
    def __init__(
        self,
        *,
        priority: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_mirror_filter_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_mirror_source_ids: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
        traffic_mirror_target_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_mirror_target_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        packet_length: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tag: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[_ros_cdk_core_7adfd82f.RosTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        traffic_mirror_session_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        traffic_mirror_session_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        virtual_network_id: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``TrafficMirrorSession``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorsession

        :param priority: Property priority: The priority of the traffic mirror session. Valid values: **1 to 32766**. A smaller value indicates a higher priority. You cannot specify identical priorities for traffic mirror sessions that are created in the same region by using the same account.
        :param traffic_mirror_filter_id: Property trafficMirrorFilterId: The ID of the filter.
        :param traffic_mirror_source_ids: Property trafficMirrorSourceIds: undefined.
        :param traffic_mirror_target_id: Property trafficMirrorTargetId: The ID of the traffic mirror destination. You can specify only an elastic network interface (ENI) or a Server Load Balancer (SLB) instance as a traffic mirror destination.
        :param traffic_mirror_target_type: Property trafficMirrorTargetType: The type of the traffic mirror destination. Valid values: - **NetworkInterface**: an ENI - **SLB**: an SLB instance
        :param enabled: Property enabled: Specifies whether to enable the traffic mirror session. Valid values: - **false** (default): does not enable the traffic mirror session. - **true**: enables the traffic mirror session.
        :param packet_length: Property packetLength: The maximum transmission unit (MTU). Default value: **1500**.
        :param resource_group_id: Property resourceGroupId: The ID of the resource group to which the mirrored traffic belongs.
        :param tag: Property tag:.
        :param traffic_mirror_session_description: Property trafficMirrorSessionDescription: The description of the traffic mirror session. The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        :param traffic_mirror_session_name: Property trafficMirrorSessionName: The name of the traffic mirror session. The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        :param virtual_network_id: Property virtualNetworkId: The VXLAN network identifier (VNI). Valid values: **0 to 16777215**. You can use VNIs to identify mirrored traffic from different sessions at the traffic mirror destination. You can specify a custom VNI or use a random VNI allocated by the system. If you want the system to randomly allocate a VNI, do not enter a value.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18f1e23a81721c1ba6bf238036e7ded6bd30cf081df26d6dd7981da8fbfcf4cf)
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
            check_type(argname="argument traffic_mirror_filter_id", value=traffic_mirror_filter_id, expected_type=type_hints["traffic_mirror_filter_id"])
            check_type(argname="argument traffic_mirror_source_ids", value=traffic_mirror_source_ids, expected_type=type_hints["traffic_mirror_source_ids"])
            check_type(argname="argument traffic_mirror_target_id", value=traffic_mirror_target_id, expected_type=type_hints["traffic_mirror_target_id"])
            check_type(argname="argument traffic_mirror_target_type", value=traffic_mirror_target_type, expected_type=type_hints["traffic_mirror_target_type"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument packet_length", value=packet_length, expected_type=type_hints["packet_length"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
            check_type(argname="argument traffic_mirror_session_description", value=traffic_mirror_session_description, expected_type=type_hints["traffic_mirror_session_description"])
            check_type(argname="argument traffic_mirror_session_name", value=traffic_mirror_session_name, expected_type=type_hints["traffic_mirror_session_name"])
            check_type(argname="argument virtual_network_id", value=virtual_network_id, expected_type=type_hints["virtual_network_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "priority": priority,
            "traffic_mirror_filter_id": traffic_mirror_filter_id,
            "traffic_mirror_source_ids": traffic_mirror_source_ids,
            "traffic_mirror_target_id": traffic_mirror_target_id,
            "traffic_mirror_target_type": traffic_mirror_target_type,
        }
        if enabled is not None:
            self._values["enabled"] = enabled
        if packet_length is not None:
            self._values["packet_length"] = packet_length
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tag is not None:
            self._values["tag"] = tag
        if traffic_mirror_session_description is not None:
            self._values["traffic_mirror_session_description"] = traffic_mirror_session_description
        if traffic_mirror_session_name is not None:
            self._values["traffic_mirror_session_name"] = traffic_mirror_session_name
        if virtual_network_id is not None:
            self._values["virtual_network_id"] = virtual_network_id

    @builtins.property
    def priority(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property priority: The priority of the traffic mirror session.

        Valid values: **1 to 32766**.
        A smaller value indicates a higher priority. You cannot specify identical priorities for traffic mirror sessions that are created in the same region by using the same account.
        '''
        result = self._values.get("priority")
        assert result is not None, "Required property 'priority' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_mirror_filter_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property trafficMirrorFilterId: The ID of the filter.'''
        result = self._values.get("traffic_mirror_filter_id")
        assert result is not None, "Required property 'traffic_mirror_filter_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_mirror_source_ids(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''Property trafficMirrorSourceIds: undefined.'''
        result = self._values.get("traffic_mirror_source_ids")
        assert result is not None, "Required property 'traffic_mirror_source_ids' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], result)

    @builtins.property
    def traffic_mirror_target_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property trafficMirrorTargetId: The ID of the traffic mirror destination.

        You can specify only an elastic network interface (ENI) or a Server Load Balancer (SLB) instance as a traffic mirror destination.
        '''
        result = self._values.get("traffic_mirror_target_id")
        assert result is not None, "Required property 'traffic_mirror_target_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_mirror_target_type(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property trafficMirrorTargetType: The type of the traffic mirror destination.

        Valid values:

        - **NetworkInterface**: an ENI
        - **SLB**: an SLB instance
        '''
        result = self._values.get("traffic_mirror_target_type")
        assert result is not None, "Required property 'traffic_mirror_target_type' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enabled: Specifies whether to enable the traffic mirror session.

        Valid values:

        - **false** (default): does not enable the traffic mirror session.
        - **true**: enables the traffic mirror session.
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def packet_length(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property packetLength: The maximum transmission unit (MTU).

        Default value: **1500**.
        '''
        result = self._values.get("packet_length")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def resource_group_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property resourceGroupId: The ID of the resource group to which the mirrored traffic belongs.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tag(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, _ros_cdk_core_7adfd82f.RosTag]]]]:
        '''Property tag:.'''
        result = self._values.get("tag")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, _ros_cdk_core_7adfd82f.RosTag]]]], result)

    @builtins.property
    def traffic_mirror_session_description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property trafficMirrorSessionDescription: The description of the traffic mirror session.

        The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("traffic_mirror_session_description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def traffic_mirror_session_name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property trafficMirrorSessionName: The name of the traffic mirror session.

        The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        '''
        result = self._values.get("traffic_mirror_session_name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def virtual_network_id(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property virtualNetworkId: The VXLAN network identifier (VNI).

        Valid values: **0 to 16777215**.
        You can use VNIs to identify mirrored traffic from different sessions at the traffic mirror destination. You can specify a custom VNI or use a random VNI allocated by the system. If you want the system to randomly allocate a VNI, do not enter a value.
        '''
        result = self._values.get("virtual_network_id")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TrafficMirrorSessionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TrafficMirrorSessionSourcesAddition(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.TrafficMirrorSessionSourcesAddition",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::TrafficMirrorSessionSourcesAddition``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosTrafficMirrorSessionSourcesAddition``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorsessionsourcesaddition
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["TrafficMirrorSessionSourcesAdditionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71bb2456ecfecd1c97fb163fc54dbefe3c5dc60eabcdc8d5fda040ff2a32a18a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.TrafficMirrorSessionSourcesAdditionProps",
    jsii_struct_bases=[],
    name_mapping={
        "traffic_mirror_session_id": "trafficMirrorSessionId",
        "traffic_mirror_source_ids": "trafficMirrorSourceIds",
    },
)
class TrafficMirrorSessionSourcesAdditionProps:
    def __init__(
        self,
        *,
        traffic_mirror_session_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        traffic_mirror_source_ids: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    ) -> None:
        '''Properties for defining a ``TrafficMirrorSessionSourcesAddition``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-trafficmirrorsessionsourcesaddition

        :param traffic_mirror_session_id: Property trafficMirrorSessionId: The ID of the traffic mirror session.
        :param traffic_mirror_source_ids: Property trafficMirrorSourceIds: undefined.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c906224e0920972bf8fa4ff13596976d733ab6540185eea1d70520dc2df9dbbf)
            check_type(argname="argument traffic_mirror_session_id", value=traffic_mirror_session_id, expected_type=type_hints["traffic_mirror_session_id"])
            check_type(argname="argument traffic_mirror_source_ids", value=traffic_mirror_source_ids, expected_type=type_hints["traffic_mirror_source_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "traffic_mirror_session_id": traffic_mirror_session_id,
            "traffic_mirror_source_ids": traffic_mirror_source_ids,
        }

    @builtins.property
    def traffic_mirror_session_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property trafficMirrorSessionId: The ID of the traffic mirror session.'''
        result = self._values.get("traffic_mirror_session_id")
        assert result is not None, "Required property 'traffic_mirror_session_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def traffic_mirror_source_ids(
        self,
    ) -> typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]:
        '''Property trafficMirrorSourceIds: undefined.'''
        result = self._values.get("traffic_mirror_source_ids")
        assert result is not None, "Required property 'traffic_mirror_source_ids' is missing"
        return typing.cast(typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TrafficMirrorSessionSourcesAdditionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VirtualBorderRouter(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.VirtualBorderRouter",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::VirtualBorderRouter``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosVirtualBorderRouter``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-virtualborderrouter
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["VirtualBorderRouterProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36118df4a6bc6bf1640093498d75bf5872bf27a91fb629af283f45bc87b911bd)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrName")
    def attr_name(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Name: The name of the VBR.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrName"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouteTableId: The ID of the route table of the VBR.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteTableId"))

    @builtins.property
    @jsii.member(jsii_name="attrVbrId")
    def attr_vbr_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VbrId: The ID of the VBR.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVbrId"))

    @builtins.property
    @jsii.member(jsii_name="attrVlanInterfaceId")
    def attr_vlan_interface_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VlanInterfaceId: The ID of the VBR interface.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVlanInterfaceId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.VirtualBorderRouterProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_gateway_ip": "localGatewayIp",
        "peer_gateway_ip": "peerGatewayIp",
        "peering_subnet_mask": "peeringSubnetMask",
        "physical_connection_id": "physicalConnectionId",
        "vlan_id": "vlanId",
        "circuit_code": "circuitCode",
        "description": "description",
        "name": "name",
    },
)
class VirtualBorderRouterProps:
    def __init__(
        self,
        *,
        local_gateway_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        peer_gateway_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        peering_subnet_mask: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        physical_connection_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vlan_id: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        circuit_code: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``VirtualBorderRouter``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-virtualborderrouter

        :param local_gateway_ip: Property localGatewayIp: The IP address of the VBR on the Alibaba Cloud side.
        :param peer_gateway_ip: Property peerGatewayIp: The IP address of the peer router interface of the VBR. Only the owner of the VBR can set or modify the value. This parameter is required when you create a VBR for the owner of the physical connection. You can ignore this parameter when you create a VBR for another Alibaba Cloud account.
        :param peering_subnet_mask: Property peeringSubnetMask: The subnet mask for the IP addresses of the VBR on the Alibaba Cloud side and on the user side. The two IP addresses must fall within the same subnet.
        :param physical_connection_id: Property physicalConnectionId: The ID of the physical connection.
        :param vlan_id: Property vlanId: The VLAN ID of the VBR. Valid values: 0 to 2999. Note Only the owner of the physical connection can set this parameter. The VLAN IDs of two VBRs of the same physical connection must be different.
        :param circuit_code: Property circuitCode: The circuit code provided by the Internet service provider (ISP) for the physical connection. Note Only the owner of the physical connection can set this parameter.
        :param description: Property description: The description of the VBR. The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        :param name: Property name: The name of the VBR. The name must be 2 to 128 characters in length, and can contain, digits, periods (.), underscores (_), and hyphens (-). The name cannot start with http:// or https://.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e60407bab4403ff33b2d7c939917c4de8ebe4e6571428f7bda976a6553b1040)
            check_type(argname="argument local_gateway_ip", value=local_gateway_ip, expected_type=type_hints["local_gateway_ip"])
            check_type(argname="argument peer_gateway_ip", value=peer_gateway_ip, expected_type=type_hints["peer_gateway_ip"])
            check_type(argname="argument peering_subnet_mask", value=peering_subnet_mask, expected_type=type_hints["peering_subnet_mask"])
            check_type(argname="argument physical_connection_id", value=physical_connection_id, expected_type=type_hints["physical_connection_id"])
            check_type(argname="argument vlan_id", value=vlan_id, expected_type=type_hints["vlan_id"])
            check_type(argname="argument circuit_code", value=circuit_code, expected_type=type_hints["circuit_code"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "local_gateway_ip": local_gateway_ip,
            "peer_gateway_ip": peer_gateway_ip,
            "peering_subnet_mask": peering_subnet_mask,
            "physical_connection_id": physical_connection_id,
            "vlan_id": vlan_id,
        }
        if circuit_code is not None:
            self._values["circuit_code"] = circuit_code
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def local_gateway_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property localGatewayIp: The IP address of the VBR on the Alibaba Cloud side.'''
        result = self._values.get("local_gateway_ip")
        assert result is not None, "Required property 'local_gateway_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def peer_gateway_ip(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property peerGatewayIp: The IP address of the peer router interface of the VBR.

        Only the owner of the VBR can set or modify the value.
        This parameter is required when you create a VBR for the owner of the physical connection.
        You can ignore this parameter when you create a VBR for another Alibaba Cloud account.
        '''
        result = self._values.get("peer_gateway_ip")
        assert result is not None, "Required property 'peer_gateway_ip' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def peering_subnet_mask(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property peeringSubnetMask: The subnet mask for the IP addresses of the VBR on the Alibaba Cloud side and on the user side.

        The two IP addresses must fall within the same subnet.
        '''
        result = self._values.get("peering_subnet_mask")
        assert result is not None, "Required property 'peering_subnet_mask' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def physical_connection_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property physicalConnectionId: The ID of the physical connection.'''
        result = self._values.get("physical_connection_id")
        assert result is not None, "Required property 'physical_connection_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vlan_id(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vlanId: The VLAN ID of the VBR.

        Valid values: 0 to 2999.
        Note Only the owner of the physical connection can set this parameter. The VLAN IDs of
        two VBRs of the same physical connection must be different.
        '''
        result = self._values.get("vlan_id")
        assert result is not None, "Required property 'vlan_id' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def circuit_code(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property circuitCode: The circuit code provided by the Internet service provider (ISP) for the physical connection.

        Note Only the owner of the physical connection can set this parameter.
        '''
        result = self._values.get("circuit_code")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the VBR.

        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the VBR.

        The name must be 2 to 128 characters in length, and can contain, digits, periods (.),
        underscores (_), and hyphens (-). The name cannot start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualBorderRouterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpcPeerConnection(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.VpcPeerConnection",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::VpcPeerConnection``, which is used to create a peering connection between virtual private clouds (VPCs).

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosVpcPeerConnection``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpcpeerconnection
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["VpcPeerConnectionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51e1b7216789c8257aadc0c43669adef693505c6906acf4dc42c32bb4138f9d2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrInstanceId")
    def attr_instance_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute InstanceId: The ID of the VPC peering connection.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInstanceId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.VpcPeerConnectionProps",
    jsii_struct_bases=[],
    name_mapping={
        "accepting_vpc_id": "acceptingVpcId",
        "vpc_id": "vpcId",
        "accepting_ali_uid": "acceptingAliUid",
        "accepting_region_id": "acceptingRegionId",
        "deletion_force": "deletionForce",
        "description": "description",
        "name": "name",
    },
)
class VpcPeerConnectionProps:
    def __init__(
        self,
        *,
        accepting_vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        accepting_ali_uid: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        accepting_region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        deletion_force: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``VpcPeerConnection``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpcpeerconnection

        :param accepting_vpc_id: Property acceptingVpcId: The ID of the acceptor VPC.
        :param vpc_id: Property vpcId: The ID of the requester VPC.
        :param accepting_ali_uid: Property acceptingAliUid: The ID of the Alibaba Cloud account to which the acceptor VPC belongs. To create a VPC peering connection within your Alibaba Cloud account, enter the ID of your Alibaba Cloud account. To create a VPC peering connection between your Alibaba Cloud account and another Alibaba Cloud account, enter the ID of the peer Alibaba Cloud account. Note If the acceptor VPC belongs to a Resource Access Management (RAM) user, you must set the value of AcceptingAliUid to the ID of the corresponding Alibaba Cloud account. Default current account ID.
        :param accepting_region_id: Property acceptingRegionId: The region ID of the acceptor VPC of the VPC peering connection that you want to create. To create an intra-region VPC peering connection, enter a region ID that is the same as that of the requester VPC. To create an inter-region VPC peering connection, enter a region ID that is different from that of the requester VPC. Default current region.
        :param deletion_force: Property deletionForce: Specifies whether to forcefully delete the VPC peering connection. Valid values:false (default): notrue: yes If you forcefully delete the VPC peering connection, the system deletes the routes that point to the VPC peering connection from the VPC route table.
        :param description: Property description: The description of the VPC peering connection. The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        :param name: Property name: The name of the VPC peering connection. The name must be 2 to 128 characters in length and can contain digits, underscores (_), and hyphens (-). It must start with a letter.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7badfe3561ac697868843036dc6b16e44d4f6149d51e904cd2f9f5272efea0f2)
            check_type(argname="argument accepting_vpc_id", value=accepting_vpc_id, expected_type=type_hints["accepting_vpc_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument accepting_ali_uid", value=accepting_ali_uid, expected_type=type_hints["accepting_ali_uid"])
            check_type(argname="argument accepting_region_id", value=accepting_region_id, expected_type=type_hints["accepting_region_id"])
            check_type(argname="argument deletion_force", value=deletion_force, expected_type=type_hints["deletion_force"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "accepting_vpc_id": accepting_vpc_id,
            "vpc_id": vpc_id,
        }
        if accepting_ali_uid is not None:
            self._values["accepting_ali_uid"] = accepting_ali_uid
        if accepting_region_id is not None:
            self._values["accepting_region_id"] = accepting_region_id
        if deletion_force is not None:
            self._values["deletion_force"] = deletion_force
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def accepting_vpc_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property acceptingVpcId: The ID of the acceptor VPC.'''
        result = self._values.get("accepting_vpc_id")
        assert result is not None, "Required property 'accepting_vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpcId: The ID of the requester VPC.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def accepting_ali_uid(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property acceptingAliUid: The ID of the Alibaba Cloud account to which the acceptor VPC belongs.

        To create a VPC peering connection within your Alibaba Cloud account, enter the ID
        of your Alibaba Cloud account.
        To create a VPC peering connection between your Alibaba Cloud account and another
        Alibaba Cloud account, enter the ID of the peer Alibaba Cloud account.
        Note If the acceptor VPC belongs to a Resource Access Management (RAM) user, you must set
        the value of AcceptingAliUid to the ID of the corresponding Alibaba Cloud account.
        Default current account ID.
        '''
        result = self._values.get("accepting_ali_uid")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def accepting_region_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property acceptingRegionId: The region ID of the acceptor VPC of the VPC peering connection that you want to create.

        To create an intra-region VPC peering connection, enter a region ID that is the same
        as that of the requester VPC.
        To create an inter-region VPC peering connection, enter a region ID that is different
        from that of the requester VPC.
        Default current region.
        '''
        result = self._values.get("accepting_region_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def deletion_force(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property deletionForce: Specifies whether to forcefully delete the VPC peering connection.

        Valid values:false (default): notrue: yes If you forcefully delete the VPC peering connection, the system deletes the routes that point to the VPC peering connection from the VPC route table.
        '''
        result = self._values.get("deletion_force")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the VPC peering connection.

        The description must be 2 to 256 characters in length. It must start with a letter
        but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the VPC peering connection.

        The name must be 2 to 128 characters in length and can contain digits, underscores
        (_), and hyphens (-). It must start with a letter.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpcPeerConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpnAttachment(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.VpnAttachment",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::VpnAttachment``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosVpnAttachment``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnattachment
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["VpnAttachmentProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fb89eaec4c99fbec0442bd3d6b8a348f1f5ade3189ec7bfa685f087d927f7a8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrInternetIp")
    def attr_internet_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute InternetIp: The gateway IP address of the IPsec connection.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInternetIp"))

    @builtins.property
    @jsii.member(jsii_name="attrPeerVpnAttachmentConfig")
    def attr_peer_vpn_attachment_config(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute PeerVpnAttachmentConfig: Peer vpc Attachment config.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPeerVpnAttachmentConfig"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnAttachmentId")
    def attr_vpn_attachment_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpnAttachmentId: ID of the IPsec attachment.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnAttachmentId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.VpnAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "customer_gateway_id": "customerGatewayId",
        "local_subnet": "localSubnet",
        "remote_subnet": "remoteSubnet",
        "auto_config_route": "autoConfigRoute",
        "bgp_config": "bgpConfig",
        "effect_immediately": "effectImmediately",
        "enable_dpd": "enableDpd",
        "enable_nat_traversal": "enableNatTraversal",
        "health_check_config": "healthCheckConfig",
        "ike_config": "ikeConfig",
        "ipsec_config": "ipsecConfig",
        "name": "name",
        "network_type": "networkType",
        "remote_ca_cert": "remoteCaCert",
    },
)
class VpnAttachmentProps:
    def __init__(
        self,
        *,
        customer_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        remote_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auto_config_route: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.BgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.HealthCheckConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        remote_ca_cert: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``VpnAttachment``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnattachment

        :param customer_gateway_id: Property customerGatewayId: The ID of the user gateway.
        :param local_subnet: Property localSubnet: A network segment on the VPC side that needs to be interconnected with the local IDC for the second phase negotiation. Multiple network segments are separated by commas, for example: 192.168.1.0/24, 192.168.2.0/24.
        :param remote_subnet: Property remoteSubnet: The network segment of the local IDC is used for the second phase negotiation. Multiple network segments are separated by commas, for example: 192.168.3.0/24, 192.168.4.0/24.
        :param auto_config_route: Property autoConfigRoute: Specifies whether to automatically configure routes. Valid values: true (default) false
        :param bgp_config: Property bgpConfig: The Border Gateway Protocol (BGP) configuration. This parameter is required when the VPN gateway has dynamic BGP enabled. Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see VPN Gateway supports BGP dynamic routing. We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP. Refer to the relevant documentation for the private ASN range.
        :param effect_immediately: Property effectImmediately: Whether to delete the currently negotiated IPsec tunnel and re-initiate the negotiation. Value: True: Negotiate immediately after the configuration is complete. False (default): Negotiate when traffic enters.
        :param enable_dpd: Property enableDpd: Specifies whether to enable the dead peer detection (DPD) feature. Valid values: true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted. false: disables DPD. The IPsec initiator does not send DPD packets.
        :param enable_nat_traversal: Property enableNatTraversal: Specifies whether to enable NAT traversal. Valid values: true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel. false
        :param health_check_config: Property healthCheckConfig: Whether to enable the health check configuration.
        :param ike_config: Property ikeConfig: Configuration information for the first phase of negotiation.
        :param ipsec_config: Property ipsecConfig: Configuration information for the second phase negotiation.
        :param name: Property name: The name of the IPsec connection. The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_) and dashes (-), but cannot start with http:// or https:// .
        :param network_type: Property networkType: The network type of the IPsec connection. Value: public|private.
        :param remote_ca_cert: Property remoteCaCert: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection. This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection. You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27e399f8e7e324c722de23e12b815788ca9eed7a60893d37c0ad29a2e2f6c36f)
            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
            check_type(argname="argument local_subnet", value=local_subnet, expected_type=type_hints["local_subnet"])
            check_type(argname="argument remote_subnet", value=remote_subnet, expected_type=type_hints["remote_subnet"])
            check_type(argname="argument auto_config_route", value=auto_config_route, expected_type=type_hints["auto_config_route"])
            check_type(argname="argument bgp_config", value=bgp_config, expected_type=type_hints["bgp_config"])
            check_type(argname="argument effect_immediately", value=effect_immediately, expected_type=type_hints["effect_immediately"])
            check_type(argname="argument enable_dpd", value=enable_dpd, expected_type=type_hints["enable_dpd"])
            check_type(argname="argument enable_nat_traversal", value=enable_nat_traversal, expected_type=type_hints["enable_nat_traversal"])
            check_type(argname="argument health_check_config", value=health_check_config, expected_type=type_hints["health_check_config"])
            check_type(argname="argument ike_config", value=ike_config, expected_type=type_hints["ike_config"])
            check_type(argname="argument ipsec_config", value=ipsec_config, expected_type=type_hints["ipsec_config"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument network_type", value=network_type, expected_type=type_hints["network_type"])
            check_type(argname="argument remote_ca_cert", value=remote_ca_cert, expected_type=type_hints["remote_ca_cert"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "customer_gateway_id": customer_gateway_id,
            "local_subnet": local_subnet,
            "remote_subnet": remote_subnet,
        }
        if auto_config_route is not None:
            self._values["auto_config_route"] = auto_config_route
        if bgp_config is not None:
            self._values["bgp_config"] = bgp_config
        if effect_immediately is not None:
            self._values["effect_immediately"] = effect_immediately
        if enable_dpd is not None:
            self._values["enable_dpd"] = enable_dpd
        if enable_nat_traversal is not None:
            self._values["enable_nat_traversal"] = enable_nat_traversal
        if health_check_config is not None:
            self._values["health_check_config"] = health_check_config
        if ike_config is not None:
            self._values["ike_config"] = ike_config
        if ipsec_config is not None:
            self._values["ipsec_config"] = ipsec_config
        if name is not None:
            self._values["name"] = name
        if network_type is not None:
            self._values["network_type"] = network_type
        if remote_ca_cert is not None:
            self._values["remote_ca_cert"] = remote_ca_cert

    @builtins.property
    def customer_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property customerGatewayId: The ID of the user gateway.'''
        result = self._values.get("customer_gateway_id")
        assert result is not None, "Required property 'customer_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property localSubnet: A network segment on the VPC side that needs to be interconnected with the local IDC for the second phase negotiation.

        Multiple network segments are separated by commas, for example: 192.168.1.0/24, 192.168.2.0/24.
        '''
        result = self._values.get("local_subnet")
        assert result is not None, "Required property 'local_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def remote_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property remoteSubnet: The network segment of the local IDC is used for the second phase negotiation.

        Multiple network segments are separated by commas, for example: 192.168.3.0/24, 192.168.4.0/24.
        '''
        result = self._values.get("remote_subnet")
        assert result is not None, "Required property 'remote_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auto_config_route(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoConfigRoute: Specifies whether to automatically configure routes.

        Valid values:
        true (default)
        false
        '''
        result = self._values.get("auto_config_route")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def bgp_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.BgpConfigProperty]]:
        '''Property bgpConfig: The Border Gateway Protocol (BGP) configuration.

        This parameter is required when the VPN gateway has dynamic BGP enabled.
        Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see VPN Gateway supports BGP dynamic routing.
        We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP.
        Refer to the relevant documentation for the private ASN range.
        '''
        result = self._values.get("bgp_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.BgpConfigProperty]], result)

    @builtins.property
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property effectImmediately: Whether to delete the currently negotiated IPsec tunnel and re-initiate the negotiation.

        Value:
        True: Negotiate immediately after the configuration is complete.
        False (default): Negotiate when traffic enters.
        '''
        result = self._values.get("effect_immediately")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_dpd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enableDpd: Specifies whether to enable the dead peer detection (DPD) feature.

        Valid values:
        true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
        false: disables DPD. The IPsec initiator does not send DPD packets.
        '''
        result = self._values.get("enable_dpd")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_nat_traversal(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enableNatTraversal: Specifies whether to enable NAT traversal.

        Valid values:
        true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
        false
        '''
        result = self._values.get("enable_nat_traversal")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.HealthCheckConfigProperty]]:
        '''Property healthCheckConfig: Whether to enable the health check configuration.'''
        result = self._values.get("health_check_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.HealthCheckConfigProperty]], result)

    @builtins.property
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IkeConfigProperty]]:
        '''Property ikeConfig: Configuration information for the first phase of negotiation.'''
        result = self._values.get("ike_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IkeConfigProperty]], result)

    @builtins.property
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IpsecConfigProperty]]:
        '''Property ipsecConfig: Configuration information for the second phase negotiation.'''
        result = self._values.get("ipsec_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IpsecConfigProperty]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the IPsec connection.

        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_) and dashes (-), but cannot start with http:// or https:// .
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property networkType: The network type of the IPsec connection.

        Value: public|private.
        '''
        result = self._values.get("network_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def remote_ca_cert(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property remoteCaCert: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.

        This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
        You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
        '''
        result = self._values.get("remote_ca_cert")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpnConnection(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.VpnConnection",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::VpnConnection``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosVpnConnection``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnconnection
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["VpnConnectionProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c18b129a6121c23e9ee1a0d7ed659ed0482d734661b0b681e6e5e60e0d2ea2d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrPeerVpnConnectionConfig")
    def attr_peer_vpn_connection_config(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute PeerVpnConnectionConfig: Peer vpc connection config.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrPeerVpnConnectionConfig"))

    @builtins.property
    @jsii.member(jsii_name="attrStatus")
    def attr_status(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Status: Status of the IPsec connection.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrStatus"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnConnectionId")
    def attr_vpn_connection_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpnConnectionId: ID of the IPsec connection.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnConnectionId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.VpnConnectionProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_subnet": "localSubnet",
        "remote_subnet": "remoteSubnet",
        "vpn_gateway_id": "vpnGatewayId",
        "auto_config_route": "autoConfigRoute",
        "bgp_config": "bgpConfig",
        "customer_gateway_id": "customerGatewayId",
        "effect_immediately": "effectImmediately",
        "enable_dpd": "enableDpd",
        "enable_nat_traversal": "enableNatTraversal",
        "enable_tunnels_bgp": "enableTunnelsBgp",
        "health_check_config": "healthCheckConfig",
        "ike_config": "ikeConfig",
        "ipsec_config": "ipsecConfig",
        "name": "name",
        "remote_ca_certificate": "remoteCaCertificate",
        "tunnel_options_specification": "tunnelOptionsSpecification",
    },
)
class VpnConnectionProps:
    def __init__(
        self,
        *,
        local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        remote_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auto_config_route: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.BgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        customer_gateway_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_tunnels_bgp: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        health_check_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.HealthCheckConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        remote_ca_certificate: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tunnel_options_specification: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.TunnelOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''Properties for defining a ``VpnConnection``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnconnection

        :param local_subnet: Property localSubnet: A network segment on the VPC side that needs to be interconnected with the local IDC for the second phase negotiation. Multiple network segments are separated by commas, for example: 192.168.1.0/24, 192.168.2.0/24.
        :param remote_subnet: Property remoteSubnet: The network segment of the local IDC is used for the second phase negotiation. Multiple network segments are separated by commas, for example: 192.168.3.0/24, 192.168.4.0/24.
        :param vpn_gateway_id: Property vpnGatewayId: ID of the VPN gateway.
        :param auto_config_route: Property autoConfigRoute: Specifies whether to automatically configure routes. Valid values: true (default) false
        :param bgp_config: Property bgpConfig: The Border Gateway Protocol (BGP) configuration. This parameter is required when the VPN gateway has dynamic BGP enabled. Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see VPN Gateway supports BGP dynamic routing. We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP. Refer to the relevant documentation for the private ASN range.
        :param customer_gateway_id: Property customerGatewayId: The ID of the user gateway.
        :param effect_immediately: Property effectImmediately: Whether to delete the currently negotiated IPsec tunnel and re-initiate the negotiation. Value: True: Negotiate immediately after the configuration is complete. False (default): Negotiate when traffic enters.
        :param enable_dpd: Property enableDpd: Specifies whether to enable the dead peer detection (DPD) feature. Valid values: true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted. false: disables DPD. The IPsec initiator does not send DPD packets.
        :param enable_nat_traversal: Property enableNatTraversal: Specifies whether to enable NAT traversal. Valid values: true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel. false
        :param enable_tunnels_bgp: Property enableTunnelsBgp: Specifies whether to enable the BGP feature for the tunnel. Valid values: true and false. Default value: false.
        :param health_check_config: Property healthCheckConfig: Whether to enable the health check configuration.
        :param ike_config: Property ikeConfig: Configuration information for the first phase of negotiation.
        :param ipsec_config: Property ipsecConfig: Configuration information for the second phase negotiation.
        :param name: Property name: The name of the IPsec connection. The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_) and dashes (-), but cannot start with http:// or https:// .
        :param remote_ca_certificate: Property remoteCaCertificate: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection. This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection. You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
        :param tunnel_options_specification: Property tunnelOptionsSpecification: TunnelOptionsSpecification parameters are supported by dual-tunnel IPsec-VPN gateways. You can modify both the active and standby tunnels of the IPsec-VPN connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fddb5c172f8682726814311c1366b2b844444758c76bd1ce926173803170ee2)
            check_type(argname="argument local_subnet", value=local_subnet, expected_type=type_hints["local_subnet"])
            check_type(argname="argument remote_subnet", value=remote_subnet, expected_type=type_hints["remote_subnet"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument auto_config_route", value=auto_config_route, expected_type=type_hints["auto_config_route"])
            check_type(argname="argument bgp_config", value=bgp_config, expected_type=type_hints["bgp_config"])
            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
            check_type(argname="argument effect_immediately", value=effect_immediately, expected_type=type_hints["effect_immediately"])
            check_type(argname="argument enable_dpd", value=enable_dpd, expected_type=type_hints["enable_dpd"])
            check_type(argname="argument enable_nat_traversal", value=enable_nat_traversal, expected_type=type_hints["enable_nat_traversal"])
            check_type(argname="argument enable_tunnels_bgp", value=enable_tunnels_bgp, expected_type=type_hints["enable_tunnels_bgp"])
            check_type(argname="argument health_check_config", value=health_check_config, expected_type=type_hints["health_check_config"])
            check_type(argname="argument ike_config", value=ike_config, expected_type=type_hints["ike_config"])
            check_type(argname="argument ipsec_config", value=ipsec_config, expected_type=type_hints["ipsec_config"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument remote_ca_certificate", value=remote_ca_certificate, expected_type=type_hints["remote_ca_certificate"])
            check_type(argname="argument tunnel_options_specification", value=tunnel_options_specification, expected_type=type_hints["tunnel_options_specification"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "local_subnet": local_subnet,
            "remote_subnet": remote_subnet,
            "vpn_gateway_id": vpn_gateway_id,
        }
        if auto_config_route is not None:
            self._values["auto_config_route"] = auto_config_route
        if bgp_config is not None:
            self._values["bgp_config"] = bgp_config
        if customer_gateway_id is not None:
            self._values["customer_gateway_id"] = customer_gateway_id
        if effect_immediately is not None:
            self._values["effect_immediately"] = effect_immediately
        if enable_dpd is not None:
            self._values["enable_dpd"] = enable_dpd
        if enable_nat_traversal is not None:
            self._values["enable_nat_traversal"] = enable_nat_traversal
        if enable_tunnels_bgp is not None:
            self._values["enable_tunnels_bgp"] = enable_tunnels_bgp
        if health_check_config is not None:
            self._values["health_check_config"] = health_check_config
        if ike_config is not None:
            self._values["ike_config"] = ike_config
        if ipsec_config is not None:
            self._values["ipsec_config"] = ipsec_config
        if name is not None:
            self._values["name"] = name
        if remote_ca_certificate is not None:
            self._values["remote_ca_certificate"] = remote_ca_certificate
        if tunnel_options_specification is not None:
            self._values["tunnel_options_specification"] = tunnel_options_specification

    @builtins.property
    def local_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property localSubnet: A network segment on the VPC side that needs to be interconnected with the local IDC for the second phase negotiation.

        Multiple network segments are separated by commas, for example: 192.168.1.0/24, 192.168.2.0/24.
        '''
        result = self._values.get("local_subnet")
        assert result is not None, "Required property 'local_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def remote_subnet(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property remoteSubnet: The network segment of the local IDC is used for the second phase negotiation.

        Multiple network segments are separated by commas, for example: 192.168.3.0/24, 192.168.4.0/24.
        '''
        result = self._values.get("remote_subnet")
        assert result is not None, "Required property 'remote_subnet' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpnGatewayId: ID of the VPN gateway.'''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auto_config_route(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoConfigRoute: Specifies whether to automatically configure routes.

        Valid values:
        true (default)
        false
        '''
        result = self._values.get("auto_config_route")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def bgp_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.BgpConfigProperty]]:
        '''Property bgpConfig: The Border Gateway Protocol (BGP) configuration.

        This parameter is required when the VPN gateway has dynamic BGP enabled.
        Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see VPN Gateway supports BGP dynamic routing.
        We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP.
        Refer to the relevant documentation for the private ASN range.
        '''
        result = self._values.get("bgp_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.BgpConfigProperty]], result)

    @builtins.property
    def customer_gateway_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property customerGatewayId: The ID of the user gateway.'''
        result = self._values.get("customer_gateway_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def effect_immediately(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property effectImmediately: Whether to delete the currently negotiated IPsec tunnel and re-initiate the negotiation.

        Value:
        True: Negotiate immediately after the configuration is complete.
        False (default): Negotiate when traffic enters.
        '''
        result = self._values.get("effect_immediately")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_dpd(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enableDpd: Specifies whether to enable the dead peer detection (DPD) feature.

        Valid values:
        true (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
        false: disables DPD. The IPsec initiator does not send DPD packets.
        '''
        result = self._values.get("enable_dpd")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_nat_traversal(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enableNatTraversal: Specifies whether to enable NAT traversal.

        Valid values:
        true (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
        false
        '''
        result = self._values.get("enable_nat_traversal")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_tunnels_bgp(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enableTunnelsBgp: Specifies whether to enable the BGP feature for the tunnel.

        Valid values: true and false. Default value: false.
        '''
        result = self._values.get("enable_tunnels_bgp")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def health_check_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.HealthCheckConfigProperty]]:
        '''Property healthCheckConfig: Whether to enable the health check configuration.'''
        result = self._values.get("health_check_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.HealthCheckConfigProperty]], result)

    @builtins.property
    def ike_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IkeConfigProperty]]:
        '''Property ikeConfig: Configuration information for the first phase of negotiation.'''
        result = self._values.get("ike_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IkeConfigProperty]], result)

    @builtins.property
    def ipsec_config(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IpsecConfigProperty]]:
        '''Property ipsecConfig: Configuration information for the second phase negotiation.'''
        result = self._values.get("ipsec_config")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IpsecConfigProperty]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: The name of the IPsec connection.

        The length is 2-128 characters and must start with a letter or Chinese. It can contain numbers, periods (.), underscores (_) and dashes (-), but cannot start with http:// or https:// .
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def remote_ca_certificate(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property remoteCaCertificate: The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.

        This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
        You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
        '''
        result = self._values.get("remote_ca_certificate")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tunnel_options_specification(
        self,
    ) -> typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.TunnelOptionsSpecificationProperty]]]]:
        '''Property tunnelOptionsSpecification: TunnelOptionsSpecification parameters are supported by dual-tunnel IPsec-VPN gateways.

        You can modify both the active and standby tunnels of the IPsec-VPN connection.
        '''
        result = self._values.get("tunnel_options_specification")
        return typing.cast(typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.TunnelOptionsSpecificationProperty]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpnGateway(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.VpnGateway",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::VpnGateway``, which is used to create a VPN gateway.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosVpnGateway``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpngateway
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["VpnGatewayProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d76baaac194d14311626729070b9e922242e067a2174ed51fa16bbe0b453650c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrDisasterRecoveryInternetIp")
    def attr_disaster_recovery_internet_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute DisasterRecoveryInternetIp: The second IP address assigned by the system to create an IPsec-VPN connection.This attribute is returned only when the VPN gateway supports the dual-tunnel mode.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDisasterRecoveryInternetIp"))

    @builtins.property
    @jsii.member(jsii_name="attrDisasterRecoveryVSwitchId")
    def attr_disaster_recovery_v_switch_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute DisasterRecoveryVSwitchId: The ID of the second vSwitch associated with the VPN gateway.This attribute is returned only when the VPN gateway supports the dual-tunnel mode.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrDisasterRecoveryVSwitchId"))

    @builtins.property
    @jsii.member(jsii_name="attrInternetIp")
    def attr_internet_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute InternetIp: The public IP address of the VPN gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrInternetIp"))

    @builtins.property
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute OrderId: The order ID.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrOrderId"))

    @builtins.property
    @jsii.member(jsii_name="attrSpec")
    def attr_spec(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute Spec: The specification of the VPN gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSpec"))

    @builtins.property
    @jsii.member(jsii_name="attrSslMaxConnections")
    def attr_ssl_max_connections(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute SslMaxConnections: The maximum number of concurrent SSL-VPN connections.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSslMaxConnections"))

    @builtins.property
    @jsii.member(jsii_name="attrSslVpnInternetIp")
    def attr_ssl_vpn_internet_ip(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute SslVpnInternetIp: The IP address of the SSL-VPN connection.This attribute is returned only when the VPN gateway is a public VPN gateway and supports only the single-tunnel mode. In addition, the VPN gateway must have the SSL-VPN feature enabled.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrSslVpnInternetIp"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpcId: The ID of the virtual private cloud (VPC) to which the VPN gateway belongs.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpcId"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnGatewayId")
    def attr_vpn_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpnGatewayId: ID of the VPN gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnGatewayId"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnType")
    def attr_vpn_type(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpnType: The type of the VPN gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnType"))

    @builtins.property
    @jsii.member(jsii_name="attrVSwitchId")
    def attr_v_switch_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VSwitchId: The ID of the vSwitch to which the VPN gateway belongs.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVSwitchId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.VpnGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "vpc_id": "vpcId",
        "auto_pay": "autoPay",
        "description": "description",
        "disaster_recovery_v_switch_id": "disasterRecoveryVSwitchId",
        "enable_ipsec": "enableIpsec",
        "enable_ssl": "enableSsl",
        "instance_charge_type": "instanceChargeType",
        "name": "name",
        "network_type": "networkType",
        "period": "period",
        "ssl_connections": "sslConnections",
        "tags": "tags",
        "vpn_type": "vpnType",
        "v_switch_id": "vSwitchId",
    },
)
class VpnGatewayProps:
    def __init__(
        self,
        *,
        bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        disaster_recovery_v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_ipsec: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        enable_ssl: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        ssl_connections: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[RosVpnGateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        vpn_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``VpnGateway``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpngateway

        :param bandwidth: Property bandwidth: The public network bandwidth of the VPN gateway, in Mbps. Value: 5|10|20|50|100|200.
        :param vpc_id: Property vpcId: VPC ID to which the VPN gateway belongs.
        :param auto_pay: Property autoPay: Whether to automatically pay the bill of the VPN gateway, the value: true: Automatically pays the bill for the VPN gateway. false: Does not automatically pay the bill for the VPN gateway. Default true.
        :param description: Property description: Description of the VPN gateway. The length is 2-256 characters and must start with a letter or Chinese, but cannot start with http:// or https://.
        :param disaster_recovery_v_switch_id: Property disasterRecoveryVSwitchId: The second vSwitch with which you want to associate the VPN gateway. If you call this operation in a region that supports the dual-tunnel mode, this parameter is required. You need to specify two vSwitches in different zones from the VPC associated with the VPN gateway to implement disaster recovery across zones. For a region that supports only one zone, disaster recovery across zones is not supported. We recommend that you specify two vSwitches in the zone to implement high availability. You can specify the same vSwitch. For more information about the regions and zones that support the dual-tunnel mode, see Upgrade a VPN gateway to enable the dual-tunnel mode.
        :param enable_ipsec: Property enableIpsec: Whether to enable IPsec-VPN. The IPsec-VPN feature provides a site-to-site connection. You can securely connect your local data center network to a private network or two proprietary networks by creating an IPsec tunnel. Value: True (default): Enables the IPsec-VPN feature. False: The IPsec-VPN function is not enabled.
        :param enable_ssl: Property enableSsl: Enable the SSL-VPN function. Provide point-to-site VPN connection, no need to configure customer gateway, terminal directly access. Value: True: Enable SSL-VPN. False (default): Does not enable SSL-VPN.
        :param instance_charge_type: Property instanceChargeType: Accounting type of the VPN gateway, the value is: PREPAY, POSTPAY.
        :param name: Property name: Name of the VPN gateway. The default value is the ID of the VPN gateway. The length is 2~100 English or Chinese characters. It must start with a large or small letter or Chinese. It can contain numbers, underscores (_) and dashes (-). It cannot start with http:// or https://.
        :param network_type: Property networkType: The network type of the VPN gateway. Valid values: public|private
        :param period: Property period: Purchase time, value: 1~9|12|24|36. When the value of the InstanceChargeType parameter is PREPAY, this parameter is mandatory.
        :param ssl_connections: Property sslConnections: The maximum number of clients allowed to connect at the same time.
        :param tags: Property tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        :param vpn_type: Property vpnType: VPN gateway type.
        :param v_switch_id: Property vSwitchId: The ID of the VSwitch to which the VPN gateway belongs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__506253f5be03d08b358b5d9ed35b5ba0559f3783788e2e9390e347123b6b7a45)
            check_type(argname="argument bandwidth", value=bandwidth, expected_type=type_hints["bandwidth"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument auto_pay", value=auto_pay, expected_type=type_hints["auto_pay"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument disaster_recovery_v_switch_id", value=disaster_recovery_v_switch_id, expected_type=type_hints["disaster_recovery_v_switch_id"])
            check_type(argname="argument enable_ipsec", value=enable_ipsec, expected_type=type_hints["enable_ipsec"])
            check_type(argname="argument enable_ssl", value=enable_ssl, expected_type=type_hints["enable_ssl"])
            check_type(argname="argument instance_charge_type", value=instance_charge_type, expected_type=type_hints["instance_charge_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument network_type", value=network_type, expected_type=type_hints["network_type"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument ssl_connections", value=ssl_connections, expected_type=type_hints["ssl_connections"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpn_type", value=vpn_type, expected_type=type_hints["vpn_type"])
            check_type(argname="argument v_switch_id", value=v_switch_id, expected_type=type_hints["v_switch_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bandwidth": bandwidth,
            "vpc_id": vpc_id,
        }
        if auto_pay is not None:
            self._values["auto_pay"] = auto_pay
        if description is not None:
            self._values["description"] = description
        if disaster_recovery_v_switch_id is not None:
            self._values["disaster_recovery_v_switch_id"] = disaster_recovery_v_switch_id
        if enable_ipsec is not None:
            self._values["enable_ipsec"] = enable_ipsec
        if enable_ssl is not None:
            self._values["enable_ssl"] = enable_ssl
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if name is not None:
            self._values["name"] = name
        if network_type is not None:
            self._values["network_type"] = network_type
        if period is not None:
            self._values["period"] = period
        if ssl_connections is not None:
            self._values["ssl_connections"] = ssl_connections
        if tags is not None:
            self._values["tags"] = tags
        if vpn_type is not None:
            self._values["vpn_type"] = vpn_type
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id

    @builtins.property
    def bandwidth(
        self,
    ) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property bandwidth: The public network bandwidth of the VPN gateway, in Mbps.

        Value: 5|10|20|50|100|200.
        '''
        result = self._values.get("bandwidth")
        assert result is not None, "Required property 'bandwidth' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpc_id(self) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpcId: VPC ID to which the VPN gateway belongs.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def auto_pay(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property autoPay: Whether to automatically pay the bill of the VPN gateway, the value: true: Automatically pays the bill for the VPN gateway.

        false: Does not automatically pay the bill for the VPN gateway.
        Default true.
        '''
        result = self._values.get("auto_pay")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: Description of the VPN gateway.

        The length is 2-256 characters and must start with a letter or Chinese, but cannot start with http:// or https://.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def disaster_recovery_v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property disasterRecoveryVSwitchId: The second vSwitch with which you want to associate the VPN gateway.

        If you call this operation in a region that supports the dual-tunnel mode, this parameter is required.
        You need to specify two vSwitches in different zones from the VPC associated with the VPN gateway to implement disaster recovery across zones.
        For a region that supports only one zone, disaster recovery across zones is not supported. We recommend that you specify two vSwitches in the zone to implement high availability. You can specify the same vSwitch.
        For more information about the regions and zones that support the dual-tunnel mode, see Upgrade a VPN gateway to enable the dual-tunnel mode.
        '''
        result = self._values.get("disaster_recovery_v_switch_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_ipsec(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enableIpsec: Whether to enable IPsec-VPN.

        The IPsec-VPN feature provides a site-to-site connection. You can securely connect your local data center network to a private network or two proprietary networks by creating an IPsec tunnel. Value:
        True (default): Enables the IPsec-VPN feature.
        False: The IPsec-VPN function is not enabled.
        '''
        result = self._values.get("enable_ipsec")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def enable_ssl(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property enableSsl: Enable the SSL-VPN function.

        Provide point-to-site VPN connection, no need to configure customer gateway, terminal directly access. Value:
        True: Enable SSL-VPN.
        False (default): Does not enable SSL-VPN.
        '''
        result = self._values.get("enable_ssl")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def instance_charge_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property instanceChargeType: Accounting type of the VPN gateway, the value is: PREPAY, POSTPAY.'''
        result = self._values.get("instance_charge_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property name: Name of the VPN gateway.

        The default value is the ID of the VPN gateway.
        The length is 2~100 English or Chinese characters. It must start with a large or small letter or Chinese. It can contain numbers, underscores (_) and dashes (-). It cannot start with http:// or https://.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def network_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property networkType: The network type of the VPN gateway.

        Valid values: public|private
        '''
        result = self._values.get("network_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def period(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property period: Purchase time, value: 1~9|12|24|36.

        When the value of the InstanceChargeType parameter is PREPAY, this parameter is mandatory.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def ssl_connections(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property sslConnections: The maximum number of clients allowed to connect at the same time.'''
        result = self._values.get("ssl_connections")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[RosVpnGateway.TagsProperty]]:
        '''Property tags: Tags to attach to instance.

        Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[RosVpnGateway.TagsProperty]], result)

    @builtins.property
    def vpn_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property vpnType: VPN gateway type.'''
        result = self._values.get("vpn_type")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def v_switch_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property vSwitchId: The ID of the VSwitch to which the VPN gateway belongs.'''
        result = self._values.get("v_switch_id")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpnPbrRouteEntry(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.VpnPbrRouteEntry",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::VpnPbrRouteEntry``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosVpnPbrRouteEntry``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnpbrrouteentry
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["VpnPbrRouteEntryProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__acd29d46027824b34e026c35d0f9ad9a3d0537828a642a2f07df17f91d1ee0c2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrNextHop")
    def attr_next_hop(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute NextHop: The next hop of the destination route entry.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNextHop"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteDest")
    def attr_route_dest(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouteDest: The destination CIDR block of the destination route.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteDest"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteSource")
    def attr_route_source(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouteSource: The destination CIDR block of the policy-based route.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteSource"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnGatewayId")
    def attr_vpn_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpnGatewayId: The ID of the VPN Gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnGatewayId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.VpnPbrRouteEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "next_hop": "nextHop",
        "publish_vpc": "publishVpc",
        "route_dest": "routeDest",
        "route_source": "routeSource",
        "vpn_gateway_id": "vpnGatewayId",
        "weight": "weight",
        "description": "description",
        "overlay_mode": "overlayMode",
    },
)
class VpnPbrRouteEntryProps:
    def __init__(
        self,
        *,
        next_hop: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        publish_vpc: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
        route_dest: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        route_source: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        overlay_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``VpnPbrRouteEntry``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnpbrrouteentry

        :param next_hop: Property nextHop: The next hop of the destination route entry.
        :param publish_vpc: Property publishVpc: Indicates whether to publish the destination route to the VPC. Valid values: true: Publish the destination route to the VPC. false: Do not publish the destination route to the VPC.
        :param route_dest: Property routeDest: The destination CIDR block of the destination route.
        :param route_source: Property routeSource: The source CIDR block of the policy-based route.
        :param vpn_gateway_id: Property vpnGatewayId: The ID of the VPN Gateway.
        :param weight: Property weight: The weight of the destination route. Valid values: 0|100.
        :param description: Property description: The description of the VPN destination route.
        :param overlay_mode: Property overlayMode: The overlay mode.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50d70d0eab7c97d009eefad6e644fb052a8f617f5453426e9889903c9cb04726)
            check_type(argname="argument next_hop", value=next_hop, expected_type=type_hints["next_hop"])
            check_type(argname="argument publish_vpc", value=publish_vpc, expected_type=type_hints["publish_vpc"])
            check_type(argname="argument route_dest", value=route_dest, expected_type=type_hints["route_dest"])
            check_type(argname="argument route_source", value=route_source, expected_type=type_hints["route_source"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument overlay_mode", value=overlay_mode, expected_type=type_hints["overlay_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "next_hop": next_hop,
            "publish_vpc": publish_vpc,
            "route_dest": route_dest,
            "route_source": route_source,
            "vpn_gateway_id": vpn_gateway_id,
            "weight": weight,
        }
        if description is not None:
            self._values["description"] = description
        if overlay_mode is not None:
            self._values["overlay_mode"] = overlay_mode

    @builtins.property
    def next_hop(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property nextHop: The next hop of the destination route entry.'''
        result = self._values.get("next_hop")
        assert result is not None, "Required property 'next_hop' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def publish_vpc(
        self,
    ) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property publishVpc: Indicates whether to publish the destination route to the VPC.

        Valid values:
        true: Publish the destination route to the VPC.
        false: Do not publish the destination route to the VPC.
        '''
        result = self._values.get("publish_vpc")
        assert result is not None, "Required property 'publish_vpc' is missing"
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def route_dest(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routeDest: The destination CIDR block of the destination route.'''
        result = self._values.get("route_dest")
        assert result is not None, "Required property 'route_dest' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def route_source(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routeSource: The source CIDR block of the policy-based route.'''
        result = self._values.get("route_source")
        assert result is not None, "Required property 'route_source' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpnGatewayId: The ID of the VPN Gateway.'''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def weight(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property weight: The weight of the destination route.

        Valid values: 0|100.
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the VPN destination route.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def overlay_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property overlayMode: The overlay mode.'''
        result = self._values.get("overlay_mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnPbrRouteEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpnRouteEntry(
    _ros_cdk_core_7adfd82f.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-vpc.VpnRouteEntry",
):
    '''This class encapsulates and extends the ROS resource type ``ALIYUN::VPC::VpnRouteEntry``.

    :Note:

    This class may have some new functions to facilitate development, so it is recommended to use this class instead of ``RosVpnRouteEntry``for a more convenient development experience.
    See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnrouteentry
    '''

    def __init__(
        self,
        scope: _ros_cdk_core_7adfd82f.Construct,
        id: builtins.str,
        props: typing.Union["VpnRouteEntryProps", typing.Dict[builtins.str, typing.Any]],
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Param scope - scope in which this resource is defined Param id    - scoped id of the resource Param props - resource properties.

        :param scope: -
        :param id: -
        :param props: -
        :param enable_resource_property_constraint: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1eea84423f9a755f50cf4931757159cc2fe19b95900d6259607d2e0c53c3825)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument enable_resource_property_constraint", value=enable_resource_property_constraint, expected_type=type_hints["enable_resource_property_constraint"])
        jsii.create(self.__class__, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property
    @jsii.member(jsii_name="attrNextHop")
    def attr_next_hop(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute NextHop: The next hop of the destination route entry.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrNextHop"))

    @builtins.property
    @jsii.member(jsii_name="attrRouteDest")
    def attr_route_dest(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute RouteDest: The destination CIDR block of the destination route.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrRouteDest"))

    @builtins.property
    @jsii.member(jsii_name="attrVpnGatewayId")
    def attr_vpn_gateway_id(self) -> _ros_cdk_core_7adfd82f.IResolvable:
        '''Attribute VpnGatewayId: The ID of the VPN Gateway.'''
        return typing.cast(_ros_cdk_core_7adfd82f.IResolvable, jsii.get(self, "attrVpnGatewayId"))


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-vpc.VpnRouteEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "next_hop": "nextHop",
        "publish_vpc": "publishVpc",
        "route_dest": "routeDest",
        "vpn_gateway_id": "vpnGatewayId",
        "weight": "weight",
        "description": "description",
        "overlay_mode": "overlayMode",
    },
)
class VpnRouteEntryProps:
    def __init__(
        self,
        *,
        next_hop: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        publish_vpc: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
        route_dest: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
        weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
        description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
        overlay_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ) -> None:
        '''Properties for defining a ``VpnRouteEntry``.

        See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-vpc-vpnrouteentry

        :param next_hop: Property nextHop: The next hop of the destination route entry.
        :param publish_vpc: Property publishVpc: Indicates whether to publish the destination route to the VPC. Valid values: true: Publish the destination route to the VPC. false: Do not publish the destination route to the VPC.
        :param route_dest: Property routeDest: The destination CIDR block of the destination route.
        :param vpn_gateway_id: Property vpnGatewayId: The ID of the VPN Gateway.
        :param weight: Property weight: The weight of the destination route. Valid values: 0|100.
        :param description: Property description: The description of the VPN destination route.
        :param overlay_mode: Property overlayMode: The overlay mode.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d4eb8964dafe4266c6c6780997855fba76d9971ae0433d15c3d71823bcb8372)
            check_type(argname="argument next_hop", value=next_hop, expected_type=type_hints["next_hop"])
            check_type(argname="argument publish_vpc", value=publish_vpc, expected_type=type_hints["publish_vpc"])
            check_type(argname="argument route_dest", value=route_dest, expected_type=type_hints["route_dest"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument overlay_mode", value=overlay_mode, expected_type=type_hints["overlay_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "next_hop": next_hop,
            "publish_vpc": publish_vpc,
            "route_dest": route_dest,
            "vpn_gateway_id": vpn_gateway_id,
            "weight": weight,
        }
        if description is not None:
            self._values["description"] = description
        if overlay_mode is not None:
            self._values["overlay_mode"] = overlay_mode

    @builtins.property
    def next_hop(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property nextHop: The next hop of the destination route entry.'''
        result = self._values.get("next_hop")
        assert result is not None, "Required property 'next_hop' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def publish_vpc(
        self,
    ) -> typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property publishVpc: Indicates whether to publish the destination route to the VPC.

        Valid values:
        true: Publish the destination route to the VPC.
        false: Do not publish the destination route to the VPC.
        '''
        result = self._values.get("publish_vpc")
        assert result is not None, "Required property 'publish_vpc' is missing"
        return typing.cast(typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def route_dest(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property routeDest: The destination CIDR block of the destination route.'''
        result = self._values.get("route_dest")
        assert result is not None, "Required property 'route_dest' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def vpn_gateway_id(
        self,
    ) -> typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property vpnGatewayId: The ID of the VPN Gateway.'''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def weight(self) -> typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]:
        '''Property weight: The weight of the destination route.

        Valid values: 0|100.
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable], result)

    @builtins.property
    def description(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property description: The description of the VPN destination route.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    @builtins.property
    def overlay_mode(
        self,
    ) -> typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]:
        '''Property overlayMode: The overlay mode.'''
        result = self._values.get("overlay_mode")
        return typing.cast(typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnRouteEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "AnycastEIP",
    "AnycastEIPAssociation",
    "AnycastEIPAssociationProps",
    "AnycastEIPProps",
    "BgpGroup",
    "BgpGroupProps",
    "BgpNetwork",
    "BgpNetworkProps",
    "BgpPeer",
    "BgpPeerProps",
    "CommonBandwidthPackage",
    "CommonBandwidthPackageIp",
    "CommonBandwidthPackageIpProps",
    "CommonBandwidthPackageProps",
    "CustomerGateway",
    "CustomerGatewayProps",
    "DhcpOptionsSet",
    "DhcpOptionsSetAttachment",
    "DhcpOptionsSetAttachmentProps",
    "DhcpOptionsSetProps",
    "EIPAssociation",
    "EIPAssociationProps",
    "EIPPro",
    "EIPProProps",
    "EIPProps",
    "EIPSegment",
    "EIPSegmentProps",
    "Eip",
    "FlowLog",
    "FlowLogProps",
    "ForwardEntry",
    "ForwardEntryProps",
    "GrantInstanceToCen",
    "GrantInstanceToCenProps",
    "HaVip",
    "HaVipAssociation",
    "HaVipAssociationProps",
    "HaVipProps",
    "IpsecServer",
    "IpsecServerProps",
    "Ipv4Gateway",
    "Ipv4GatewayProps",
    "Ipv6Gateway",
    "Ipv6GatewayProps",
    "Ipv6InternetBandwidth",
    "Ipv6InternetBandwidthProps",
    "NatGateway",
    "NatGatewayProps",
    "NatIp",
    "NatIpProps",
    "NetworkAcl",
    "NetworkAclAssociation",
    "NetworkAclAssociationProps",
    "NetworkAclProps",
    "PeeringRouterInterfaceBinding",
    "PeeringRouterInterfaceBindingProps",
    "PeeringRouterInterfaceConnection",
    "PeeringRouterInterfaceConnectionProps",
    "PrefixList",
    "PrefixListProps",
    "RosAnycastEIP",
    "RosAnycastEIPAssociation",
    "RosAnycastEIPAssociationProps",
    "RosAnycastEIPProps",
    "RosBgpGroup",
    "RosBgpGroupProps",
    "RosBgpNetwork",
    "RosBgpNetworkProps",
    "RosBgpPeer",
    "RosBgpPeerProps",
    "RosCommonBandwidthPackage",
    "RosCommonBandwidthPackageIp",
    "RosCommonBandwidthPackageIpProps",
    "RosCommonBandwidthPackageProps",
    "RosCustomerGateway",
    "RosCustomerGatewayProps",
    "RosDhcpOptionsSet",
    "RosDhcpOptionsSetAttachment",
    "RosDhcpOptionsSetAttachmentProps",
    "RosDhcpOptionsSetProps",
    "RosEIP",
    "RosEIPAssociation",
    "RosEIPAssociationProps",
    "RosEIPPro",
    "RosEIPProProps",
    "RosEIPProps",
    "RosEIPSegment",
    "RosEIPSegmentProps",
    "RosFlowLog",
    "RosFlowLogProps",
    "RosForwardEntry",
    "RosForwardEntryProps",
    "RosGrantInstanceToCen",
    "RosGrantInstanceToCenProps",
    "RosHaVip",
    "RosHaVipAssociation",
    "RosHaVipAssociationProps",
    "RosHaVipProps",
    "RosIpsecServer",
    "RosIpsecServerProps",
    "RosIpv4Gateway",
    "RosIpv4GatewayProps",
    "RosIpv6Gateway",
    "RosIpv6GatewayProps",
    "RosIpv6InternetBandwidth",
    "RosIpv6InternetBandwidthProps",
    "RosNatGateway",
    "RosNatGatewayProps",
    "RosNatIp",
    "RosNatIpProps",
    "RosNetworkAcl",
    "RosNetworkAclAssociation",
    "RosNetworkAclAssociationProps",
    "RosNetworkAclProps",
    "RosPeeringRouterInterfaceBinding",
    "RosPeeringRouterInterfaceBindingProps",
    "RosPeeringRouterInterfaceConnection",
    "RosPeeringRouterInterfaceConnectionProps",
    "RosPrefixList",
    "RosPrefixListProps",
    "RosRouteTable",
    "RosRouteTableAssociation",
    "RosRouteTableAssociationProps",
    "RosRouteTableProps",
    "RosRouterInterface",
    "RosRouterInterfaceProps",
    "RosSnatEntry",
    "RosSnatEntryProps",
    "RosSslVpnClientCert",
    "RosSslVpnClientCertProps",
    "RosSslVpnServer",
    "RosSslVpnServerProps",
    "RosTrafficMirrorFilter",
    "RosTrafficMirrorFilterProps",
    "RosTrafficMirrorSession",
    "RosTrafficMirrorSessionProps",
    "RosTrafficMirrorSessionSourcesAddition",
    "RosTrafficMirrorSessionSourcesAdditionProps",
    "RosVirtualBorderRouter",
    "RosVirtualBorderRouterProps",
    "RosVpcPeerConnection",
    "RosVpcPeerConnectionProps",
    "RosVpnAttachment",
    "RosVpnAttachmentProps",
    "RosVpnConnection",
    "RosVpnConnectionProps",
    "RosVpnGateway",
    "RosVpnGatewayProps",
    "RosVpnPbrRouteEntry",
    "RosVpnPbrRouteEntryProps",
    "RosVpnRouteEntry",
    "RosVpnRouteEntryProps",
    "RouteTable",
    "RouteTableAssociation",
    "RouteTableAssociationProps",
    "RouteTableProps",
    "RouterInterface",
    "RouterInterfaceProps",
    "SnatEntry",
    "SnatEntryProps",
    "SslVpnClientCert",
    "SslVpnClientCertProps",
    "SslVpnServer",
    "SslVpnServerProps",
    "TrafficMirrorFilter",
    "TrafficMirrorFilterProps",
    "TrafficMirrorSession",
    "TrafficMirrorSessionProps",
    "TrafficMirrorSessionSourcesAddition",
    "TrafficMirrorSessionSourcesAdditionProps",
    "VirtualBorderRouter",
    "VirtualBorderRouterProps",
    "VpcPeerConnection",
    "VpcPeerConnectionProps",
    "VpnAttachment",
    "VpnAttachmentProps",
    "VpnConnection",
    "VpnConnectionProps",
    "VpnGateway",
    "VpnGatewayProps",
    "VpnPbrRouteEntry",
    "VpnPbrRouteEntryProps",
    "VpnRouteEntry",
    "VpnRouteEntryProps",
    "datasource",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import datasource

def _typecheckingstub__cebddfc9b32fc21ec059058e90be3c0bd145eb7a8d744237c9944c4cf07f2a40(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Optional[typing.Union[AnycastEIPProps, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__166fb29b693ed9ff04eb19406ca6b56101789793eb8eee09970d59231594cb70(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[AnycastEIPAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffcc3fa03387338053d8883b2d7c9c5d6d0be7b48cafdd2fec7b62123a31d067(
    *,
    anycast_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    bind_instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    bind_instance_region_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    bind_instance_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__946956441595afdf68de9841caa54233890fc8d2174245e933aa9cbd1a786564(
    *,
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    service_location: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcff6efde966e36b9b1d875ea0ddd3e0d7216a305ed3a31d9fe1ab2e80faf622(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[BgpGroupProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73091aa8c55b4a0e86a9edcb0eb8eda99974e97d356f429efd1290d7fd5aac2d(
    *,
    peer_asn: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auth_key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    is_fake_asn: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d93d9060bce31d48f154cb25b831762ce354e45fee644b12493de5511bb7fe24(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[BgpNetworkProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9b17e12d4078b2a84cff6a437840a6e7fc42b45b4c138e3435957b88f25212f(
    *,
    dst_cidr_block: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fbc510bfb9f7304a6cd946099e681dff901cc0a9c8eb555294b32f7193328529(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[BgpPeerProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__002714eae07c08393e65aa00198c0ea2ad2acfdd721d36c2022e66dd0859e2a3(
    *,
    bgp_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    enable_bfd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    peer_ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1efb5932ed1c8c005cd3aaa948b8b7e9ab4f0c0792292ef64bbd83f05f55b336(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[CommonBandwidthPackageProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__010e9e8d1c443621fc5461fdfbf4a443e7f7c53d9fc1b9377e9fcf32e9adb4b2(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[CommonBandwidthPackageIpProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c7a74b040f275773c5fc172c0d4566f200b2f1fe789ac13165ec870298116be(
    *,
    bandwidth_package_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    eips: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosCommonBandwidthPackageIp.EipsProperty, typing.Dict[builtins.str, typing.Any]]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1d20e57e8c4991e1ffad4b2e93604389444a6336dd687b379eb874a4391cc63(
    *,
    bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ratio: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosCommonBandwidthPackage.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    zone: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ed4ffc9df7dd6b386e55f6da0010e7b907d330d5cab6a6bcc2bb2f9a689ce28(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[CustomerGatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41836b525b4fdd47f169ca23f6289092939a978e3c8deae33ff00e62c4c16167(
    *,
    ip_address: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53b04f72ddc06c3fc7bc3e630015f7f42f6f276b44b1d010ec39d609f6ff8fa5(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Optional[typing.Union[DhcpOptionsSetProps, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c44c7ec07ab13b70f2a311a5aadc56c32aff50fd6ce61480cdcaea987a25901b(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[DhcpOptionsSetAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__322b72dba85d332a969fdccfd7b4c65dc1353274fcc1f514a661d672046fc26a(
    *,
    dhcp_options_set_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7962140a2ee0fdef8dae5b50a34006cbb74e7f0b4600cc680dd035cf6504d535(
    *,
    dhcp_options_set_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    dhcp_options_set_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    domain_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    domain_name_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ff19e43abb149fd4389bed00b60f25bdfa8290449d9a8c42fe5d1a87066c7d9(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[EIPAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aabfd773e7116ba656f39786fa81e728a7da3332e9380861c0d64d68b4f066c3(
    *,
    allocation_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    private_ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7923bc4ab772f0fb4b32fb0a0a746fd3be7573009d21b327a5fbb2e153e4e55(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Optional[typing.Union[EIPProProps, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba6a5ea1d7d7e5f0fd21fe504caf9408170fc3bb362c048a9f5c8c5407c082fe(
    *,
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    public_ip_address_pool_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_protection_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosEIPPro.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4d77b9c71cbc7b5efb39b7fae516e2ceb62f7036c7275728309fb06adfb6cc7(
    *,
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    public_ip_address_pool_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_protection_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosEIP.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    zone: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70f003c08ca4cff726622aa246d069641f3beb6170922d8da0544ab17c429663(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[EIPSegmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2739e9535eff5d4634fe9317a1c003a93ca87d1a854a0be98c3eab690f401c44(
    *,
    eip_mask: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa7d2f345cdb99d227c417d82a7a529fade4fec6dbd5e111cab299c66ca0cb2f(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Optional[typing.Union[EIPProps, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e1787aef508bbdd6294a74f7728a89def0149ed70b7f17a6d61f5661a2b699e(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[FlowLogProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d3805c55ee76adfcee5757a20ac08217577430cd26f67e7ca852ae01fde8bd7(
    *,
    log_store_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    project_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    resource_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    resource_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    flow_log_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0095dffd7d9a17a468e1da35040d2f06d15c6cbcd30f7cf5479d5dea3ea3ee5(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[ForwardEntryProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dee1a22df8e08251409ef20b5a0b059a3b61ca46cb4c1a501df39204259b4284(
    *,
    external_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    external_port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    forward_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    internal_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    internal_port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ip_protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    forward_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    port_break: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc5e7acf7e103f23314415ce58a42501bbda356be466306caab8346a51cd9149(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[GrantInstanceToCenProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2c894425053f8fcac01d8b3762db1b7b215d3008aea3e65a715149540181b48(
    *,
    cen_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    cen_owner_id: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    instance_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f067ddbdf40550b104ce04c23631c97abab19652eb14a46e018b167a26a3515(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[HaVipProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__226cc2a10bd9c44c3bdc87d37e69289c68f3eed71bca2980d315dcb6791192d4(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[HaVipAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d71b71099e9ab593d87a57afbc242b7c514531f64f6eba029bbd2087bd14fe21(
    *,
    ha_vip_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fe52a830e20ad17ebe20b98d123be8d8a51929d1dc4f101881ac1e5d32a0cc7(
    *,
    v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosHaVip.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__784943ddd818b6ff22967b40755677e85b1e6b74b0c21e3d62d6a7ad7c5e44c5(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[IpsecServerProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c77a8f7b76571c102512e977171a1e0a6ffd0d63dbb93c4bd02a07580487b5f(
    *,
    client_ip_pool: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosIpsecServer.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosIpsecServer.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_server_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    psk_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6969532d5e4aaa33652669e87413a9917b78e334836d4d474863a8a552161c4(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[Ipv4GatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81e8bb8e67a67ad7db5c144acba062ca394e729813d58742c41b437ad670e960(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ipv4_gateway_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipv4_gateway_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fcc2ff41d68d240159e2304d424be09d585a2a77ce772871480ff2384fab8c2a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[Ipv6GatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ce9c9c815de869188337cb28779ca7b2474464fa025844ce54c0e4376ea6a50(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spec: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosIpv6Gateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__990da0029ad1776984a5893753ea3892584958427c1a4ae0c80f566a44ff6cad(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[Ipv6InternetBandwidthProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b27eaba2447125f7450e2662e51fff76a2df79d154a7da787023c11b454e0ef6(
    *,
    bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ipv6_address_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ipv6_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c3321e6c02274d96c82db07f0ad8ce218e5ac02ac6ee04b1e0b94c9d348b68e(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[NatGatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__611d710e8cb59c4e6d950c4738dea7757a2a928aed21c8f2755baafd59025d8a(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_force: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    duration: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    eip_bind_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    icmp_reply_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nat_gateway_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nat_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_protection_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosNatGateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46efa3408ae5c979d075ab3eb1755b054450ce9624dcb86e778cf4a6e6c091b1(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[NatIpProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed669c924d01cdad192101a1dcd5ec9c8843b7a84d875b0334f756f6575d85cf(
    *,
    nat_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    nat_ip_cidr: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    nat_ip_description: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    nat_ip_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    nat_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nat_ip_cidr_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ff2dffe673ec52a0f618c924b41f51b2cfd06503bb4a611e56efc187ff3d912(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[NetworkAclProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1677ae8097256604efd36efad7299fcb3247ebab03f466908b392019134fc340(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[NetworkAclAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10735784a22c3bb11df8d25529deb11e276b4dc17b5b1056f447c956db59167b(
    *,
    network_acl_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    resources: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAclAssociation.ResourcesProperty, typing.Dict[builtins.str, typing.Any]]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c9b342f018e6c6c886ffda4b4084149e391fe891cc9c790d8c77efa54ef49ca(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    egress_acl_entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAcl.EgressAclEntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ingress_acl_entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAcl.IngressAclEntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    network_acl_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ded9e2786f79139c5e108fbcd4ffc395e4c759c85451bb2a1d8cffcfbbdb3d2(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[PeeringRouterInterfaceBindingProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f41cee50c699285a2e37ba23c8a455d0589fea1f9220e3306dc8ab39ebf5191(
    *,
    opposite_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    router_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    opposite_interface_owner_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_router_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__222e301b5335df247c7e55e452903e8bcd826e8557e0f5d91fca401d777a01a3(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[PeeringRouterInterfaceConnectionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9afea2e9a428a89f7f7fb51b223669c6c402140a9fc52b0ee89fb52a31afed6(
    *,
    opposite_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    router_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd25808369c91541b81f30bc9946232c767db94b53f8ad4b053eee2d868e4b88(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Optional[typing.Union[PrefixListProps, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fc2b2c3de2465e32834774d01eb54c130d8e82b257f5d1d9cf20f9f5234b1b3(
    *,
    entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosPrefixList.EntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ip_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    max_entries: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    prefix_list_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    prefix_list_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosPrefixList.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d08a1ce0bc8d9915a4f353fa821360e53f63da8ff2ed642a9292ec43ace36bf(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosAnycastEIPProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc3309c82f54a81763cd0f2dd30917817947535f5ff173e05b30d9a4b8e6e09b(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30c65c3b5be8f01714d138317b69d08ec3f7ee4eecdc47e4b3b881fe0b61d936(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63f6374f693bf08606ede72e31d10d5ec8c9c8b4886a3a8c6bd1449de8df2a7d(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1872bff0b9b185e947ae4c6ec3ad6574caffb001b6b9b256a6f9f9664e42596d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6154f7b0aff03ca1dcc387376c6467b293dfc81170af208afffe5bd1b6ba270c(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a5bd814b64ff1423dc5ad262e7af15efcdd23c116e114261478f2edbcd7d697(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51e19475720fc6d067d0a038869ebff6f6ce713e22382ecebb702d5140907573(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d7024ad96d2d46f637d79bc1c07080c1ae903d60fa54ef0f163cc3a8c0a8ab5(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d69ba89af7850f3b31f32d4967b7dd83bf2da597bc310b2f560b252cfea273f0(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosAnycastEIPAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10516f8f1b6d2b65f05991c1c480e0b9112791e02f10eca63c55e06672e4fb3d(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23fad66ca5f22ab5e4ff84632387162d33cf639023079813ebd62de8be08ee3b(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e2decd09dd25f2bfb40d8066746caa25cb8441a481d2b0064ee24c774182d49(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c6e2dc4e0c59398b5f3192ac32110221e7c7378bdfbd646a01c1f88f85342eb(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b8c603a96a753f9597f21173359cb0828c2bba4928e2dc5824076fca8a1bbae(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4bebe51f73a3863688cd6318104e3204449b0b0cc1c862a143758e9382f1bc3(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__052b060713c24b645d460ce8c1aa984556946e89bf1e377db26237fcd46ceeb5(
    *,
    anycast_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    bind_instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    bind_instance_region_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    bind_instance_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d145b65a6aa8ffb04d0d42eaca064e5368cae48dcf7cededba70a0cd407004f(
    *,
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    service_location: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__380cd4543899872e591b3a38d6ca0731e26072bfb342bc4a8ee089a994b9ae06(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosBgpGroupProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0d59124a0f9bb84c5ef622c01eb3c4fa2831d6962b0d7ee9b1dd7c5b24a2ad5(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb05aecad36ea57d3ebc62472f9e8d901691e09f4953b1e0517556a77b467b72(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7a723d5d1f37c8f7fe92432f10c2d2011f039326cea14a9e908dd190e08a187(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b661d51401c65a91649ec815e57f614caa932770df7cdf9f9fe7e0d85db8f7a9(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__603aa06a93cd58416ca04016abce714070090a2b238c139205cde30ec4a75c41(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b584b125d59da0908bb55009a836dca31d5984a3eb3cc4f666a1f24486274afc(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cace10e9a26ba148d9d6adbbb7e28610ee0e9c06b7c3d6193e5108392f5f7ba0(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__314d5152d02a2c0aa1fc0408aee7171f73868823ea92c74b2b77cf017b19198c(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8bd6d85fc3365cb281b9566eaecf34522d46042d6b1c7e8069b3d628ca6028d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be49551528d9ed589f6d1bfe8070a93effd3d4fb82e31b9c2d47aceec46b49fa(
    *,
    peer_asn: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auth_key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    is_fake_asn: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49ea13a336bd014d68f8f4404e98989aea1038d71a05e682eab50fb35df02ca3(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosBgpNetworkProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b55793fdab40a973318c7ee6523b96e377d2744558ddc4ea7d05fafb565ec47c(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cfba966a38e0840c8aaad53021c5c9721b5b93dd20c2f269d8d005ae9cab134(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48302144f383329b68a3c9c36d4c306ef1b514641ee959366b77c7af584c8d3a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c953470e07307c1eae897808180cc1820d489282ed6f3c6b267b4f9d2d7b817b(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b66f4ed59b4fec1c6f8286937a6d825d1b8c0ad5043db87bd49afb779ab7ed61(
    *,
    dst_cidr_block: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__349abe559b0b13bae8e4a05a2a1606dfe5d90c546e4d8d69310172e48386e62d(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosBgpPeerProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a05b0ac91e5bba33c2723483286bf45ebe5f20d1f55f9416fc99fcfd862e432(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__babecfc3769d3adff531311b62b85922a5a5cf46d44efdcbb18712f1b3823422(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__965a928397e4f307d8f97f93d280dd50394a45a7d1cb2ab8ccb70bf1ce61b291(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a062e146734f9e267a176a5261903fa665d533301a9bd600e6190a90a9806ee(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94aaf9b962c297edb5828f074e2401c4cf11471d735c0f6b7c7cf3ca0de5a7ba(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a64c8cb037f8481809bfd687722bee052c0f7ffa4e9fd8eb27e74df4face98db(
    *,
    bgp_group_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    enable_bfd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    peer_ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d5a5009fbd66a282f7de95018bf086215f6219cf82c024c6a50d89bbec07ffb(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosCommonBandwidthPackageProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88f42dd15c89843c35b17c86cc39c3708b93194b0099f0ef45bf959ad4c621b8(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e8a094f3d0ca62081b59c3d3921d62eea1a5b2700fe58f0fe3390b12bab8ae6(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d07340c3f670d7b178b72fadfd9a2d2d67a558ff20c677ae0d99d535c27178ca(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89bf2ea1bacd748b6ed7069b1ceb6bbf7e2ea0957f65d4c1f3643933fd8adfc9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__891e7946ab611fea2811f0378882e1c831b2847266ec3e1d2b4ab6ca921f1454(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e99d7ba1a90a73635b42da752a033c85366cd79dd209bd0abadfed98e3c65287(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e4ac322f53cf6c4387cc0808551ce4bf5aa63cd23917cb7ef6f9a2925e5e9c0(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5ce7baac34a185c17522bd27bfeb5f0ed664c3e2b838c71f92b321057ee0db9(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae80a41792dfb86f62b13443f7c8b279f8a4c65d3af3ca3d2901294cd6ab33d8(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c131f221060b9dd1383d688942cc3d33818c27ba091a977f07c5f01f8b1402b(
    value: typing.Optional[typing.List[RosCommonBandwidthPackage.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec690fc49ffb43a413e8787427c50c6e0ac561e079d505cf53042da2d4a3c553(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__208c0b114862a6fbaf3cbe41a9de81e50d3cb55c85c847c376aa9d2831eb9a30(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62b2503b13bb8def56e6b985d8f4b565aaac1c26f9a5d3ca3ffd0e8087426cc6(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosCommonBandwidthPackageIpProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b90471c205846e7428f8dddac0aaff419352e30ead706b4ada486f6b9f413bfd(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__668409e0f7892f8f1eaf08709bf0bca0f29ca4772c85a343678ca6e652bd444c(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__476e03c4b42c25fbf0441523b830c0cdb999bd0b8c34ff8f1aed53dd32698d92(
    value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosCommonBandwidthPackageIp.EipsProperty]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f002f268ec3810219479edf0dfa29b4a1e8a3873e1f17fb5e8f888c759a11ef8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82f33c23d43e8d81df1eec3a55e3fcc6dff5be0a526a46233f9671539b1e4e3d(
    *,
    allocation_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc096a1feb50a3e420f35d13df6f394aee6571eb6bbe561425065981cfdd9a2b(
    *,
    bandwidth_package_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    eips: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosCommonBandwidthPackageIp.EipsProperty, typing.Dict[builtins.str, typing.Any]]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__275aea8265a76d6dfd258393be48861cd9902f3f483455a3ddfea5289a1fe9db(
    *,
    bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ratio: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosCommonBandwidthPackage.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    zone: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8268b9e7356d8c9408540220bb8bedddd2378d18c20fb65d36a05079624d7302(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosCustomerGatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b668ddaab5a86a9cc3221c6bd00c00f2bd8037c1fecedc7e4e50b7be32efb1bb(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54f88e8cd7308e622e24ec83d2491e4879017ef1485675f279995d27cfa13fbf(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__510e805cbf7e812a851a7d9974bb50595b05c4bef4537e211c4646451bee69d4(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c842fb5eabb72d167b3b871bd19486be89e2f6b6a5d4c13bdb6be52af3ef005e(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c698380adbebc16dd65d7392479f693468346e82a95fde111c743fa484bf0fdb(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82db61b4d610d1371260ac51bc479a0edc81c4cf87209b2bc8c1178ca63607ba(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8fde3d2076cd33ee116bb069fdbca464e8ff4008db728d032f9d64dddc0e54d(
    *,
    ip_address: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98cb1ba8c8d84ce745184102c810adf30848432929fc557cd7cffc60ed0ae2ff(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosDhcpOptionsSetProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eca59fda4381b8c3b4ee507de3551dea449a56ddbd44ddda686402eae04c6b5b(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b6d3cf07b766d3019d41c25dbce73031cb30c88cc46d24573f4aa2754c0fc78(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10b5ecab82c5142fd3b2fbd225820d15280fd159142af1b5540efe9bac643050(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0b403140a3daa60a16b9a3073b902b063f5e823d31c10e42cb85eae0682be93(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52104aec5c1e59e003dfa1ab9cc3bc29ad0eba0917e76e8261ccc555f1b51424(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c640c5d0a8edc9290e9f544e81fbfc8f6849e9a1fbdec0ef547ca65c02c399e(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8837389209c4c49521ce072349a63e1c66946f0718a56f5ea14c38881d2cedfe(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosDhcpOptionsSetAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71550331e8827380c1b2c07157ab70549a996603a0a6b2e3a781c6d8c220f1a7(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__648a31797ec43153511c70af07363184ad989a4cadf48758052a704079a89645(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b794c962c649430be6dd8dff309578faa1b1a90ac229c860218a45d750ad76a2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b81267450d1139aa6a24a605e35988b71cd538f96799a953dfe94e559bda164b(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c48841f40457da5d2918a63bbcaa5539be0ab63bf0c1b4fba8791e2306ab766(
    *,
    dhcp_options_set_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ca0e0d617f4cd5c237b1487d927d8fc536201617f675172d903fb143a9a0859(
    *,
    dhcp_options_set_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    dhcp_options_set_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    domain_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    domain_name_servers: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73554efd336df81fe30f360e9eb32ea89eaf9a33a08abcb211dbf31ef438cf55(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosEIPProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0916bcf6a253ac784088ebe48b9f83cf498d58325b77072be57fcf6414b485ae(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba76fb724e06e1f9f2a33109c662605365fa0ecc3edee9fd1cea68af0857a91f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50611862e1658198486a1dab18b3e128c694c5b70f2be8596a91489a98902c2c(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e11a6893d039091ebe30ce1dee3de52a11fb05a8b9df8ce6760774289f9d1e2f(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebdd9e233a01d1d331721298637c3308a0eb00737c4b91b855202da912af3d44(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b8c4d77f32a8f762320762d0bb288712d8d5e678bc224f488640f7a805ed9ac(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef5925f854a29169bec9ab8780b74632217befb163fbee385a03aaea99eac2cd(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f5235cbb48f82e07dd412f3e8abcbcfd0da4f31f758689e4f69ec1e2e2416d9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ceb5774530605ccb36ffb70d90b6826732bdd7b801c668e562f80513c239bec0(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff5b9e5a9f88e3975f2ba37c301b8fc459fd93b5de2ff0446493695639ac6132(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a612682f27886afe1529ddc14626586b1f1e5c227a0e3068d27251df23db4141(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__612be7c7ebf30a6af8aef71caa8537ce3435898c8998b156dfef9ec4866c95ec(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__caf6d48739ffb5e0d66f9c6fb5681d982e35decccdc38f3cfde60c0321e5b89d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9df613e30b742e437a4d7ab955573c2fb52fb26a985e245efb76ff6757a24d8(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcc73044c0199cc0af81c603bf671320dc2396b61bef0cb6e6150fefa2b04e6d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8ad95f93bf288c1cd09889bcade82b02f03d3b9d431220aa0088c42ebf3e1e6(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55768bb7ff7c0beeb068deb027ca497a08df3bba9f8d245d917612143fdd632f(
    value: typing.Optional[typing.List[RosEIP.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb2407c5aad15e4a42094e80a054c968ab3ee419658e334649b72c572aaa64cf(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50105bff3f675e146417edf48a524a985a1345020c4cb45c143dd39a38d3ab28(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1be6a254c615f55980c7f48cb68c4f86318b3d3f5f8637d84eb4de20db6aa904(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosEIPAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a25c13e81df886185f9d66955c954335dcc25f8eb8e199d597ddfb9bb8356f4(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98d9722761b6c17bc7c7729b91960fac5a65f938166cd2326d6573a8e204ed32(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee8d3a8d9bc3b71101add1b9e760815c1c490a80af98627db25449a3880b67c4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b40232268ea887183cc2ca61527d88a21162a7cfef2b33388888cbc435b12dc(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23cc7a104446e33769d9896eafc3c82b40db4e3eaaf24c7afd10e3b95c678968(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__001630a7d890294ca8e0917c7eba716f0c325344075b60cd965d2285fcffd1b8(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e21ab0704007b4250e615b2437f387c77b965fbdb320efb6647fb34fe9d68588(
    *,
    allocation_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    private_ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b480723483b4d73e163e9812314dfe333c979553af3e5dbb381c1eb4df606e2a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosEIPProProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0949957fbf19683fc0e3363d14f9d69e3cef248c791a04e995909195faae9b3a(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__624a11fc3c328f1f06e66a6e95565232087dfb9962184aab48f1e5c1c59cf06a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5662b906bf59b2ff905053d19f8f7f556c0e4e4cf3814c6c4ec5682d3a13e79c(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba272802c47e0ace034d04b90c4384fed6b11ccbdd00c0a1ce14d2dbc7b78c88(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8362ac7698204404dbc5eaa1baae789176b5d289192feb556f4c8c905090b59a(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14efc38f7668594723a8e58b7ca210cd7aaba7a918dc8fcc731ac2cb02eacd3e(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__744e37697cfb1df820d3d2a760fb6c53080d50b718495d984495df06a7fb8633(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35d9a18603f554517ab26e6a7c32e55383c37c614428efc6b47883a36a2f9b64(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93c442ef8eed0f94f830e6b4fe26e68568cdf34148d9ca558d16ea3d1349a291(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad36afc7c779dbd7efd7cf27f40ed3e056194f37e56b7419a9cb4d203545d31c(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1744a049437a885c46b62af7b5010cfa86e09784cdc63982e3510f4f089dd133(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b95694b1fc396cdf85ba761b1bb820ef6aa22139cafc542944e166af577339f7(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__852c774544c5d362aca9260f432635ae15abb60de428fd45375aeccf90b742eb(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec25ef82a121d7b039c2614af8a906ecd92e0e081f8384af8018c55497a2edba(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5dbc3fdb1809c25e7e0bf120e64bffb2e5505e823d9240a2fbfbedab585f56c6(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdf4c5a47d251407cc814ff5c485a7d23a8c33a6f92c5a79ec2970c4fa3421b4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d508d2ebe015f82104b92ad4fa9d72f2b6af16c13de19c7b5077071fa53c6c9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b27234e65644caeb77d36bc9ccd25a392f3bccc189eb48a0ea4c0b7de7bce9a7(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__178a4b2247bea18d002ec950129cff45b0af71bbd2caf075b1b3aca00a7fea33(
    value: typing.Optional[typing.List[RosEIPPro.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__008c9a4e893f1708a936f6808d11f024f0f60c37e2dd3f5f87168b7aa4fbdbdc(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11c1a47fb3541189bdbef40dad102f398e6072dc8864b9d5330b6136762ac36f(
    *,
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    public_ip_address_pool_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_protection_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosEIPPro.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffb8d87828efcb0dd630cac4862d04dd7f6535acb098bddb303af4fe34663bb3(
    *,
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    isp: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    public_ip_address_pool_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_protection_types: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosEIP.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    zone: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f15dee7600cea13998fe273e86c5c21b93f34b1eeb1fb720c1ef2532499495e0(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosEIPSegmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46e821272f9c6a6c9731779951786d1eefb1e3b180f0ff56726ed3f4c403fa97(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9c2c8378cc5b6c0d9c67e2020456984bd7dfca59f877cb21176bc35f335f10b(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a9a493be669aa8ef1d220d8224025196cefd3bd75ae37c03f11d077b552ef07(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6601acc105eb50ca4c0d92b4da39013efc7098cb757bc766bf152e09660ace3c(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bd08dafeff0c89c846a5e648cd3f6a9185f49797c15d4e81067da8c9b38f2d3(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7828226c33ddc4d7d9c8258eb8a1a985de9ac5b601056b6b4bf7bd1f0e934587(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78f9e0e3954655b5978f8c3b2529d1259d4d6e9549c34cd3372ad8c19dc94bf9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d96b03ca91c39db58a7bdf39ea22e904dcb52c615da7ca794945df5ce5365a6(
    *,
    eip_mask: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    bandwidth: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    netmode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c211363d9d94f4817f513f0941eb8256c9042621ca4e101a5b157f90dc847cb(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosFlowLogProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0e52388f590ca79865c87917826aa78faac1045b550ba4146e42ad7849ee3d8(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8dea9bf287af08c136dc97f59e7ece94b88f88d4ffa530d54174f2006bb4537(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41344808d49d0204b75a4577f0f54ea5de86709a86ab5795f87446732c390a05(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ca41f46bd4c201a0f508f2d85216aadeec11fe69cdf628eb4370e69b0aeb6d5(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb77dfb0cdf25164b49d221ff0109dd10fa3216cba18ff0f6194cf41a0604f40(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe3bfe9fb5ed68e492bb600da09d987a1a8ec6fff67890c34f22a16d04fd800a(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1072fd3b0a2b669e590c600810f9c61340766d93887bf46224e5b9c266bfb13(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf1f50d750b781cd42dc37d81b2884ada11bbb16decbe19d6a57cce745e73e08(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09f3049d5573f7d1ff89d33488a352fd023fb8a9b9b23f637936c95499edd48d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e6cc77473c71302a63f1584ead5ec6a8ef182d24dc7a5cd421c66c705aa1a30(
    *,
    log_store_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    project_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    resource_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    resource_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    flow_log_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb1578cc9e01d28a2aa92f2ed8deb481cdb167daf1e046c494d2131db0cdec87(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosForwardEntryProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3268f3bdcaf6695fd04a944b0fc7e643c25c8ffba3eceab4068c54f7221a093(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73bb1dacb8389871ee9f942182d54b41f62c310a8cecc04d30772a36a1cd2083(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a529b372354ec97bd9b898d7b4d48a27be87b1b2fedc9c90bef4b7de4afb092(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80527b424eb543574db9ed4c09dca3d70d31ba431ca3ffdc5bbf54037243730e(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9be7d2f202fc75054c0037e0bc21f08470850b78b176cca39572e224ed1ca8c8(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be61f19befb833f81c24ac4bc3b085f2a93124193cdf49fffe9e28eb55cb9427(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd13ce6a74fb22e6662fe708077ba1d73845e397f63fa6bcacf5fb39c8e3e5bb(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fba41db38fad93d8aab24a1634d7f963ac26b043a2c7df85024e351e7a1b9b6e(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5e28d8f95ebad30cad4e149413dd42f81520a80ff7bbdf563d09f761b384eab(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13e82f28e23ca470610ebbbb61047baa280174c46b27ba05c0639bec42d9e868(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9b056877a641f807e08d771346821d8cc5905db404b92757e33f31d8fbba38b(
    *,
    external_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    external_port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    forward_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    internal_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    internal_port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ip_protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    forward_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    port_break: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee495d2f870b3cc5c0f7e856aeca68c9a2ab108f01b12bd0f326ca5ab29ddb08(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosGrantInstanceToCenProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d326b989a233e141aab9b414404fcae5510c87e013e8fa17107310ca4ce21b97(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0d7f37bb729daedb7e49c23c5574af0b49b307f43a7f7a099ab534774093346(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__337a3ee75b6ea36d1a71d7101d9b82f24797791f39b7bb3f345535124aa2b552(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c0896121d523f4767f2a61a51136d93d6d3d4e43e5ae9425f78e1f0a4c1dc43(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e179a342d45b9bfce080a70cf05b10afd14a4cecdc21759bac6f2f9e3fa499c8(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f68e02e64e6ff3b1bb01d204ce39aea79997aaa12066f4ebcbb4d211dc2b80fe(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12063dfd64a34d43f5e225740c5705fa3cae4c36c68ed25c5c254968de2361ba(
    *,
    cen_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    cen_owner_id: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    instance_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b364da372c3b3a744e5721a48e385b482a3aa9c611695427ed4f6211c89e3619(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosHaVipProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0fe0bf4e80b5e9207116edbd675dd9e8e9001929f6e8e9af2df8051907f0361(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c34e7e869733f922cb6c0ed1b0177a4bf025fb3280a7c767fbb8686a4944837(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c917e2fc6974e6fea62c3414d706823f1a1f4b12ac4b104895bb5769a7f136f8(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41c5bd1f4efb08ec43e8378d9c30241803b0a4ffb18c5674df93e1df0fa1e152(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2889a664c8abd77aa8b155834b694ace49d02e8be33aa74e0cdcb328f86f55e4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de57fe833ab254dbd1ce6fe7cae8ed4d7a28d20c40e587ad6385d508dfb712bc(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__726a1ca5aaaf52d80e2245aacfaa556e2aa105cfbae9a02d5c9cd025cb8c3391(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86c4f9bb83377f1476b2ed5340ec829fa7d158ba3159d7540231949368552724(
    value: typing.Optional[typing.List[RosHaVip.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6991bdda71cef19f1d719e1ea703dbbbaf5d7252cb9ebb69489db6451276c4d(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aea0bdaaf46be718f76dd7f5bfb6c028ea38d9b161b0be6aff109c1b336e4ccf(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosHaVipAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c68881fd0c2f840b156d0031f2fcb571e16ffa92ff8c9c48691c6cf1d018982(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41872567ba8243440589dc00d44bab55d99a9994b0d76aabab6eda1f7db7c0c2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42acc0c8cf216b327fbb0ed85228c653565a1bbfa52d1f0d0480f88114f040ac(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a45a386273934b4ac2f57d19244d503e389161b5434b25c3ba26197f15d7914a(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61fe75d4cec02a61640bf8b0970f226875231dcc1d74344785ff0b5dbbee271d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28f258f29fef26dd46ce90e85c7bbb28a6bc15f7192d99ef2e3ffa37cff90052(
    *,
    ha_vip_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    instance_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    instance_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16f18a0df4232174a25ecef05d5bbae64e438039d575cecc0438927919eba3d5(
    *,
    v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ip_address: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosHaVip.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__832ab52ab741cb60d4a892ef4cc770b54ee22c0ad9893a0eb0b2ba4510ef7e13(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosIpsecServerProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed8d306ee20b614ca544d03c733000376dda539c20d9ad166d9a24aa2bab568f(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__920ca49f5d074f3a61fac74a8019a147634d6fb400f34e258c7192b479c5889f(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eba68a3f6818fe177d465d02e255f3620b1729852ab28ae140dfaa5ab4619f55(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2d1204d48bd82147bebdc32313f7405c2fb2690af8f2cf3de2c9b0933a8719e(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c0dcf28c2712d58e58a158564a6aad598f3d565438718c99acd43b6a8e9f22c(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1639df04215cf227bf14bb10a5db76e3d22522a7e50c0e99a66d70655e420ea5(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f62769c32090e5355d0acd316ef88b902d0b71c0dec1476130461a25c8018cce(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosIpsecServer.IkeConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e9c0d7adfa04f65a2eda564a8dc3cb0f9b8dff2dbf75f762b7a8c851952bbe7(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosIpsecServer.IpsecConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05dfa566db18d18e7a08d877b39b81bb27bfb53b186b67506051f4feb17a2dcc(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05394fe0da3f5de751895a4469edbe9d30f743843c3880657c15995284b0a909(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__951f84f9a070ec3827fef6cd7908f315bcb944041eadab3997eecccebee70e79(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9c5aa5be45ec12dc8cbfe4749491ba5e338bd6a12c4e9ef7c7a821ff9c10aa3(
    *,
    ike_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8977765ef51ff27e2948207560a58befb936f7dcc7347f7f456e58228f8a3af8(
    *,
    ipsec_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5265535c03b31d0256fd6f8cbb96e8d7a6f1dae71e0dccb977dfd2bfa78f240c(
    *,
    client_ip_pool: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosIpsecServer.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosIpsecServer.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_server_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    psk_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6775d223fccfaf997b77ce974ba9934c751482737ded173733dea3f41be8593a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosIpv4GatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a42c34bb32a2fca3f221903f8810755c1640f2e938ed02b0d10d047fe3d0f7b9(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6573962f0bcf872bf3172e1557e3b28131edce500e790d7a510c1ed0797dffb(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c00212c13f21071adb3ba51341b1ac91375a4eb5a5a76fc4e9ad46b062d4be3b(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a2badab1ac1e74cc034b1bbac3762c1e6610d9a96b8bfc89e6f1f8596915de6(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f76e8b5b54afa6487172a388f8820a511dfd622044d4b7bff00ff9ddaded1000(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__661a0a9571e24ad24f8e3004e976f7545bc14ea345b7db4a0b5c4b146285b2d9(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ipv4_gateway_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipv4_gateway_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63e281c935efddb0cbf1939d7aca5364c563b57a6b862cdacd6887e96ebe1122(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosIpv6GatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7ec8e2d390d25044153bb17f17b45fd59f1550ebebcb156e646034d6c253d02(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b237fc03f147e3d384b572868c18079537819428838ddf3f4b34cd9442a50dc(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c96eb5c609681eb5eac00159ce2247c2fe16a44ed8239c19954979f21db68d76(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7fd3e6844422cdca212c8f91c09225b953a8cbdfae32ef56baf0cddc9b5b32bf(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c26c06d8d7bee01302f4a3a88d885b2374ad68cb08978463e2f469f90d3278b(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d4caba20e15974143e40af3b97b69d03dcc1909af8cb2e940d7c6b9b86a6704(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__636b76445d2bdc16b3144492fc47b8de9b94da622412e2a2ec1b3eb5fb78006d(
    value: typing.Optional[typing.List[RosIpv6Gateway.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__143280a758b403aa15601be0eef4ea22bcd2d76189b09693b3f9f1fe95f7e86f(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eba6f8115194022cca7a259645c031f8ec69365614d5d1c86034c1655e5b1521(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spec: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosIpv6Gateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75d94ae92b72e1f5d79493dc0be1c4be7d312087e2abec792245f9f612164b85(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosIpv6InternetBandwidthProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c2bf3318415bbad119f2d9200747793cdf6a63be3be1785ab47a99d50551aa1(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36cd44c994568ac0041206df2b2a1d19a4b4068d9c056c72a60cdb71196ffebd(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7783726b703d75e84c2781cf0c51292b5a83865a516310481547534ff59d62e(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d50d817dcf1a17abe4d8d55adaf73166961a6c5e0ec3dc6e1e53d217712de814(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__977804e151e952e3d250144953a1e295407e1e2b0c901dac4310bc0cea77cb93(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6cfcb36a5c1547cd413dc5444ef8a5ff9958ceb6e48c657da8084ea5e526cd4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6839650da0dcf6f69f533fedfdb73d40a5412ad4fde7a257ff3f7adb9a112719(
    *,
    bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    ipv6_address_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    ipv6_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3eeff1663dbd7f2dce25f8ef345418e4af3f54f7a2e58f60248324b73f0968e7(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosNatGatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59eeea60ac38b56a67f680a6118d46c185f2c699a8c1a5ac669c0f6d285f4677(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f559e0fac0e3f317dcab22e74aecf1a4d105e84e35bb6b0e896c64128798e121(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c994326d67a359aae6687dcb41509ab205facf56e20337c4e3f3139aeb74df54(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74ebf798e1a4b7518cc503f8e9dc01b0cacffc2ff709f5664bfa740d87775696(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e675700f7b5b99a35ae0c188b0f455960530a7b0d781f7b3ec797e5cb3e8a24(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5544fb8324d22421def5e61ab980355913823a7488b3447a253679d205fc62c(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7898f43b5512c17ea83be2fac9cf270c0b0b3514db494f951e1ff91923a70874(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5086b9a0d8d468850073d723bef8a4dc209c2d39bc7fdfdf07329a832a03f91(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__189978d070bc2cc13e9fba174160609446dfb32c9cd79de0fe4f20f2db6f5923(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d30f27bb3bfd287127c4edc5f8f665549e4872e02158cf2b50ab2d14c0f37cb6(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12091018861781a0a3a19e6bd92620ac5500b7ecb2016e43c5c7b8fabc5d860d(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a27a44562b4ba937b3b0626eca494357772cb1e7d24d51048d84b178926f342(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__526b64355e9e8ce4fca91f88cf769b9680875f4d0d6e0dce4077c7ad28308dbe(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbc21355824c992bb0d6e16aeaf6f0aaaad7e38bee3a4e7883889837574bd426(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e4f771a19b61af1fc7fc3214138e200704e06d2c69352605598eeaf28a7216a(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccee1062f7c3d86719979e5e2ac219135ac3c7337da79b2c2593f3da098acc58(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67eba9c67fbd58c4b7da58ecf1dfc79b5b1a76cd700f419e5a84e04ced2aa006(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9f2de05c73d678d01a15fd5a22e9dc0cb212ce9ab503bf042f99dc150f4c457(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df283d334859db1381fd76ca969362ba26ae9952317ce5009625ff0920680308(
    value: typing.Optional[typing.List[RosNatGateway.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f3a5242480f89ae8149b8638b2e65cde5c6dfe860d84e5baff2961e3ba61202(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aeedcf0fae3964ffd6c19c0f15745ca820a29691cdd258d3637ed72d31ceaa35(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_force: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    duration: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    eip_bind_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    icmp_reply_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    internet_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nat_gateway_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nat_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    security_protection_enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosNatGateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fd201909473a60d9f8f361c6a5b6c9e060b11d49f70b9cf433351e4cd82691b(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosNatIpProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__907f796efd4f0a10a932a4b55d802bf630f6ddfd782fc6be44f141c19f74fb98(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce05e7e00ab4e40e08618dbcd7a48ef7dbc5d80b995caebbd0476e7e7c5f06a9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__362e9d87f9194177a12e3882926c3c1e8efc3ddaef6d740c49a1ae4016d8f4d8(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2178666fe35874f2d61d5e8a7d81f61273765cd9c8818c9d67cb9408b7aa7688(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__488e511f10e83bd3551b1d22b0ed4e085a7326a1133384dfdc36fbbe66fbf020(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__470972f306e6efaa95d8804451eff78df671d5189f475901a2d56169beb66901(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11ed51250d681abcf59bc6a8f6e5d9b3871a69d188ad72793ec1bc15d4dd5a77(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__085af50101bb198f34f7d3df4a4726c3be5a39fc01dd63cd56e4cc4d4ccdf166(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fae6508c09acb591857026b4b896acc6332abfb0a66064ebf46fec0c22bea3c9(
    *,
    nat_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    nat_ip_cidr: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    nat_ip_description: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    nat_ip_name: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    nat_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    nat_ip_cidr_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__622c4f69a7f491ff7980c9d9abbf834934a8215b7192d49804d4965485f7949b(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosNetworkAclProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2303d4740563e970085a89714d1360406ca08e25aea9e80f4f673d1382aac9e7(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__687f07b2f042f8e6e4ad5d28e8929dd692438f7ce42b7d4b97df39c1233bad92(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd84706106546ccf920d2a8e9f3a23d21d026855e09ddcd1f1d0690cc947d386(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebab63dd08b4fe88937733d081709d741634142789c69d5ae7853efb54e26c66(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5580fec652b66f1131f4ef0e39047edf2454a7423907f42616564901863dc412(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAcl.EgressAclEntriesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b60f9d19a2dcfbd2cb7a0fe4e07eef6a1c6354b5dd19a30290a43cf366f7564(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAcl.IngressAclEntriesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__993c4c64e524b2b8ba1154b4284a80076c13eff849a9742fadd1635b90ab5dd5(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebb506b1a5e75f4cf80323e7251b722a8e98277db7f27cc4488d7081b5619fa7(
    *,
    policy: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    destination_cidr_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    entry_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    network_acl_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f25cf51554fa08fe4c797bd365412748c3d0b6c930828f1ade1810a548a9d58(
    *,
    policy: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    port: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    entry_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    network_acl_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_cidr_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8039de8df49b84f7883ece4b24fd67f0971f5328389c02248bd8a92499db338(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosNetworkAclAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74e296f9f655db9c8d83865e7aa2216c66967a180d860d763e2dcb73a9dad988(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__765b5c0cc418716e29f144b0754429c6cea7189a6afb4afe0de109295e886a13(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffc2d9dbb2437af9b732dcae2e2998138292252268c9a6d05c8e63c7e81cc2ca(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec6d19fb4afec95bb9c47398b6e13b548ad7d6507997444dc86e7da1314c86d1(
    value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosNetworkAclAssociation.ResourcesProperty]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0fd192e8362f9272c75caba5a9f2cc36599783380e1acd7d4c9fe4ba39dfa3b(
    *,
    resource_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    resource_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44d1347f2a778e3c517a98af32f7835d3ade79c67b079286e830f9a001186c70(
    *,
    network_acl_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    resources: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAclAssociation.ResourcesProperty, typing.Dict[builtins.str, typing.Any]]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa3beeaabc3f2dfeab5d23ecff8281136e9e77081cd76f5596b05b9755d327f6(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    egress_acl_entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAcl.EgressAclEntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ingress_acl_entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosNetworkAcl.IngressAclEntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    network_acl_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e1665849c32c5b6e7a6393e52a56b3e97e5597696cfe2a23e1868856df33e80(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosPeeringRouterInterfaceBindingProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bba5a5fbb286238d0e674162afe3b4858beb9c029babb6803c344c0077df5d1e(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f03fbf29d1c199a4fc8c0ada8d45570d11cbee0bb31c33a53cf8b375dd273e2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d5f4c911de936b9cbabafd0f95278dfb2f1af9ae0ad3faa86fb8829bd4b5379(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3579c235213a021e88d84b37c1cf07cb6bd278787935b54d897a4c1a7972e008(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b419770a58552171a6735890b526c25bf09b189368e98694ae90ec729a6bf194(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f68630a96a326e2e86f690fe939df722f04a6ad922fb708ddde1069840b86a3a(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1df84191911935a7ec43c18b4fd7d7e2d348c2f4f22795764638ee58ba802ff2(
    *,
    opposite_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    router_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    opposite_interface_owner_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_router_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44987bcfa8881c96364a50393025977b81586bc5994c2fb11ab8d0b75400c044(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosPeeringRouterInterfaceConnectionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dffed333b5496c34c44fe77999200ceb61f7029c219621863ecaf75cf2e02251(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8af356424acf408973557bf1c99ea83975b6a849de82b646669963bcb61d8b73(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0bd6de685b38a094283568c9097ddc7a7145631560506476efef94df08c2204(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb70baa7b925553d34ffb200ac619a100780e4aca99b4aca7824cc82646c5022(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c38589dc8a0481c1f9df83196bfb5965ff7fb938c0f6f4f0f5aa2290549b338(
    *,
    opposite_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    router_interface_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ec0d7a63b277f3e0aa707a671dd212e4597b30b065974b1ab43020953991e2b(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosPrefixListProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91f89452820776f65b4214d643e0b5dc4dff840bcaf4b17e4d87294b85dcb5c2(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a106ecced8fd28041ed2d306e9379e30278a458b392a368e9fba4c9271791fc(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__191b93214c05c74170002701b8adb8d8c2c6f26e8c9b52ee442371041206d4aa(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosPrefixList.EntriesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__320790e7862009fbbda2d09158c18bf16b0728d1b67d52244719a082fba89ed1(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f95cd11071a7502bbe262f8a96146d73a396c0417ffee6ced440f9740cb553cd(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18d67b830339f2737e74dd3b4931bfbdc29b04649eaf86ae2b303b18616b1349(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ee0e392c2022200b02734d320b50ab32518fda1b7e94726fbbfe6cc6b8bf9b4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edcb2c1193e3093ad17ad068e7a26a4658232c134f162c1bf85184364822ab70(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01af4571a0204bd67e53d8f0c85bdf49ace2ac82d462279bdcc52a55bdd0800c(
    value: typing.Optional[typing.List[RosPrefixList.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6df0a6005524d66a257e5a755f9db9c451e588c87cf35c0de5a46591d5d057dc(
    *,
    cidr: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f84115a7c06c086ff3540cf47e02a798cbdfb08ffb307699a9e0a5cad84f9b84(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7710791c91f209e1de5aff535dcf0cb04d0295fc235c20976e01f10ef5fdd1ec(
    *,
    entries: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosPrefixList.EntriesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ip_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    max_entries: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    prefix_list_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    prefix_list_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosPrefixList.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c983e5fa62c18a673ec2ac91cc2b03eda190f39d041227b336f1c605c23b08ab(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosRouteTableProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c50579c7181d2dda7d2f8e1941b3754de1918570cee38eab9f2744bfde13033a(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a7d1e0a29c5ae44cc88179d59c81145404c95c1e10d052b3020c610eb16400b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b3abf8fce028089276cd26de75ebc5fe61eed23a3b8da91546b31784ae349f5(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e59ffed103d9684219aaea9783015d8b8065553aa3788cb2be11b87368ec56b0(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13a836bdc828e1ccf1895c085166fdcb2e2d2ab785c0ffab023926b62cf4ac91(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64405493076495669b45f0d55fccc85bf66982e1e688e3755e2c0b510e7e462b(
    value: typing.Optional[typing.List[RosRouteTable.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de1e44f50cbea952f53669efa37796254c56cc63683bcc8f287bd79eea0ccb0b(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ecf003c09bfde4acc8a6d76b57416c5b66f9784f58ddb2c40e2cbb0de709266(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosRouteTableAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93f6d103376daedd78c8e595eaecd89a62dd56f31ba44fd65ddfe672e1340636(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1afb2df34db1c5f8b97d58c0c1481a0a76c67055f2cfa4c00ebb4854e61379e9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__667dbd07f4d3debda705c0b11540481f8b1595032df40e06c7cdf9cb57209754(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de8af07d8749130388e97c2ad8cc8c02c5e4d5cbdcaa1b08e47cea83179935eb(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45fcbc12cc0f5a391d0cc3b05e3652b0bba95e21d8aea015c01e5d458cd95765(
    *,
    route_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c89452327d71974ccd5b1d69027c2a30b2e8e59fbb181b3c27271316c9b9035c(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    route_table_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosRouteTable.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0172b4fe8788d7f2e2ec77329bc8fc6d9dba547567309178cf887d4939a35e7(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosRouterInterfaceProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b453b0c6eecebd94542509420c531b5485c80783416fffd08e868bc87c06c851(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e40099305693c4850acc558eb3f9574fcb8b557cf04e5817e05c0a12a56a81a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e29cb2efc7c93ec0e7fee6563b8789a7947bd3ad004ebe8070a4af6e7cd64fd3(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f45c6adf9fd5f340fc25d01c4e9d7c39c753c532cedfe07d5cd678a20c5248a3(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9260693a52272402bd07edc23c2c7b32273e201874ee04ecebe1f5bee8106d69(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14233a945f438c0b1e2334791f42e9959e9103d764d44f132649a6403b4df1d2(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2824d5dafae8d523292a03eb733de601834c1e01433a3da2f187170bb92ce08f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2f6d37eabfa145d22bbcbf5d962ff01a1dcc4cc863f13bec3b4ba1f547bf2c4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5031a49d1b421b2551331d6577126b27ab8043604633d4f8f1e950b925e29996(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87c219c02d0710711a029cc84c3eeee4d33ffc209fa59b021288754f7680a184(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af8d854aa5b7136ff2e8bee97803a1f16246657cd30456e4f39db2b6b1bcbb36(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc3d5fd4c379ef6ce626f77484fc2ab8db72d5e7d0647c0965afc672b5c4e71f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__180919bd10df0a75e82868e4f3c3e3edeb3f8273499b2605858b201c9532a5c0(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13ed9c7056a510efffff5d4fc36583d7bef36f783aebd198d13d3b1ed1b2dee1(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18ae85e63fc9e0a209e087fbc4f03ca4c9422835b0214ab8877097523aeb3b47(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f4b994e361ac251ff161e25a1b6b7a61149e5141f3d3acddfd5ce4f70c9b645(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c686b2ce39ef8727fa468d932106aeca83b27c78adb49b5c2e83f0c3ab45f877(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f4910a29f7b96ee34f1da9e7adbe3ddc39c26c2655488733e6b476e40654ea7(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81ba94aece005b4ca8f43d3c62debc0b4c7a7d2a4cf68deecdbf27c6928e4c6f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2fc6cd4e3eb494e5b0ea9396bcfdcf59ef442f3803caceda9dbabdbe2d6273b(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a656b98c1b9f6efd97ea8e796fcc33ae318630d9ab1e55a9240de7ccd568865b(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__341de5154ef1e750e1e8899deeb9deced0d0c25b4b577e27fdf45be0567cedec(
    *,
    role: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    access_point_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_source_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_target_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_access_point_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_interface_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_interface_owner_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_router_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_router_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    router_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spec: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a29c4c86acf16e2071a7122a1035b74679b83ea41e725f3c33ab39d015ff1dec(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosSnatEntryProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83ad12473b17ec7dbf6e1c7d0d67f119c81c62b0ba2fdd42ae1a514ae38355e5(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12883c19a92383afb95ddb0606f7e795f7bc3fd88fcef024b1c5051f839cbfe2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce77c957cd0b7613152702f62ca10dd1c590a9b9c0782d68926733620e01d639(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__537e4ac5aa3ed8553026b7b855f2123b8183f88523b8fc0b7b6c02d67c0e322d(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__810843085eb2f6959e8be080411d9ad3aebc2715a02f70325d7414e780170135(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d7e1672c0a8632d76ad3cc74a2faa08482587a404e16df04163439b066262b8(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__378f6bc2c7a2f274742a63620bb64092a33477009365a8d89fceac920f9e13a5(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f851a29102d15d13ec9f8992750126b6b74f49e45ee6fe69e325047800fffd9(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c7ce955789cfe72295d3e37f82c3c25976ddfd708f13c2211068342ebd5b9d4(
    *,
    snat_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    snat_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    eip_affinity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    snat_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_v_switch_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__004dec61a0e1b465207ccfb1f30938b893a9765f396099149f7e0c0b0793f9c5(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosSslVpnClientCertProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9794b1c126a18951d54cb1db8dac851b5e8a85c11f81c8be67071099e4566fe(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc240251efbb3bbfd997fd3a63b74b03cc76af11afbb06b6bcbb27177465ef85(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14c08a60bc7d90f0445506403bf1f1140d2b81efd79c9ce0dcac56fe0d523373(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab30938e3b86c61cec638589b3f5e988255f5ab569188400dfccb4ddf1052f3e(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__100476f5233363cf761fb887010f6118ca281652ff1b138d18fee5142dfca23b(
    *,
    ssl_vpn_server_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17e94676e406223e314936eb5da2f9e2f70632fb8aed72bea6b8f7299262c09b(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosSslVpnServerProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29d95908144e9a4955879330fe90d7692ce8533decb60668d246a731b0868625(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83ac0b43fbeb2a6abe5ac5dff3a3b8586649a2a392131dac86598f8bd05892ad(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7aff46ac7330d0ab6c7fd60811b3331e5af0cc5cb889bd81edc655d96d0e424(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71716a5e2778bdcc4bd29f196174c495a48aadb9a72c6b04f373229906824b17(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9e0a244626e1dc57daf1418e408f0f43776331fa4445554901591bb8b4da1e7(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adbb738bb09d3b5a728919f8611eb1ac0328b7339037925f1222236ee3ce8c87(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae3078718f8c9f606e2de05158ff63efdb8d938f61779cadefe8e41178ef1275(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1239ecf6e7d56ece02234b9c1c97b507a8f783e611661d65bbc14b0118419968(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adb3e9d6cb3989334f2571680623df0d2398854c2e0a22a496e9a3086f615a27(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e52e6679fbee877926d5ce90a8987f673f83579d4dc09b0b3cafaa2f6476a43(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a5d4b9c8bf49357bc26ce80aec9ee88bf55437a0e10ea13d9bbdcc36af42d23(
    *,
    client_ip_pool: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    cipher: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    compress: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    proto: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90860213fdf5a5ee1aa4db4dec3397837e7bf73ce156f94a77f755850ae8467a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosTrafficMirrorFilterProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c861ea396182d75101d01adfa868eda379aebae8348eff79f9353500ea6293d7(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__beb6261f3d63ef30a183ef5d0d69ab5f8be97d35f6fda0944364d76017b22b48(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29eb6c4b9c7645d4a8dd80158ae19db340c3150a284f38094e341a6b41e0c70b(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.EgressRulesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5dd6feed0a783f2c3439bae3f950538c5672d86f75d8eb1d47fa03595a0efa2e(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosTrafficMirrorFilter.IngressRulesProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a949154a08825770ff11a17b81aa628ff79ec14e947ce8199f2240287eb1e020(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66c2168abadd129ecce4d4bab1c569e36fa0bdcb866c7453834878d5076618ad(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5dc2bd744f6bf407dc46046d60ddd30911f669afe2996afe9e80e6f1c5ac9549(
    *,
    action: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    destination_cidr_block: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    destination_port_range: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    priority: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_cidr_block: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_port_range: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b22826ee5fd9c20dbd5e1282713fe9637f16969074522423111445785dfd532(
    *,
    action: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    protocol: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    destination_cidr_block: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    destination_port_range: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    priority: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_cidr_block: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_port_range: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d084b0cb62301a9ce20bcab1b4fd5817878b2b09c84db35808468413474283b4(
    *,
    egress_rules: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosTrafficMirrorFilter.EgressRulesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ingress_rules: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosTrafficMirrorFilter.IngressRulesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    traffic_mirror_filter_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    traffic_mirror_filter_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a938adb2e557843985b0558776db25d239754c877c1d817ed092791a760800cd(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosTrafficMirrorSessionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8b7f2b788db8c48a529c3015ed6bb8875b6274fc81c3345733a28becad04193(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__121aa9d93f01a24212187690202fe6cbb727b35a24ac6dde8256354d615d58c2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de84ac732217fdbd20744c7dc527c29077eba88a2d2da7d907707d77d67c8494(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f39408732a10859ebe3171c16b7c7e05831c84cfca85098e6e56284430a8960(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c020c9b058f9355d0392b04b80f006a2bea004a7c85b0f02ebfa8dda1169b645(
    value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__538283a5bfcb15675e5700433617206b8e857b1cb48069255ed781f511dd4ba9(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72f906e96d7f6670b25a3c8e6af7caa76fc643b8672455c90ef0a2e24363b76a(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__531c7d7b743cf560b0f55aebcdaa15e5406cedc6cde2c0812ad17f74837a08a5(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76aa6da3bc5c3f76edd326ae707460f2422cfcc823e9f70e650302b01bb553cf(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7807de63aa595e43f6793eb483ad64b0d95d467009be65aa89c7e0b80230c1b5(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfaea2d9d267aa2d110f06847b498bf5cf2a0ed601794038fcde70794f53aeae(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, _ros_cdk_core_7adfd82f.RosTag]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__603ff654620a07ec7c580d018ced2002a98654a6997ef68fccfc6500da641d10(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34b15d6d997652fc52f689353c2c6658c93db1a34c97286ff8ccbb33bc296db8(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__978d07a83fa2a200bc125e8092b6f27becb079e25fa3309f406b22bc097c714a(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79ad37e4fbcdb8c44bdd18dfd21a742bbad10d107315f75b0e63a9eae79373a2(
    *,
    key: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c55d075fc34721d8b6b1dfc9bd1faef1d051112dc8aad8d380eb7bf2cffedac8(
    *,
    priority: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_mirror_filter_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_mirror_source_ids: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    traffic_mirror_target_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_mirror_target_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    packet_length: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tag: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[_ros_cdk_core_7adfd82f.RosTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    traffic_mirror_session_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    traffic_mirror_session_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    virtual_network_id: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9d52017ebfda21175e16ba5292e7b84987cccb16f6a1e6817e10c9a1918ea72(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosTrafficMirrorSessionSourcesAdditionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61a3765017104a10136e69e405bbc79d98d1b7f2dc13ea34343fdb3ad13174fe(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__852893a63b01db314402792fec09c46df24ed09d320b395be01c15e6e31c85cc(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__572c041101c20681b4f0efa35adefe8d664cda9739577e465db884322052dd9f(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbac35c7a438cc82f3d0603f84baa2bc3cd63e7928929b00ff3fd6824c25eecc(
    value: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38c902af49c5b3bfbc7ca1916bb3c32daa878812a2b55966232d52c59f161d50(
    *,
    traffic_mirror_session_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_mirror_source_ids: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c63753b07470adbe636d5634390c4586a0bb089f47eb1f611f9395f5f9e2aaf(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosVirtualBorderRouterProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d213a55ed2f5189579f24075a6d2d2851fa94c3433c24fea5cf36c07df11962d(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2994d02cc406342fcd6efff7c7a54abf23fe69ee70df8f18e34f931b3fe1052d(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e3666b766584811fb55066fbdf833e28afc14f5d487a11be2301034316b3831(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84a8f14336c7d587a436f9947ddb52fdc2c3ca13271121bc19ce0bc60a46ffe6(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71f0bd3a2172dead36d2e5ff11a45f99015a08c2e33f8226bb1e487fcafff795(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86c38b806a1010087db3b24b3b902e83942c205338f914554824671de54151f9(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2b6a41299c56716fd7e4f81af3a18c9996d38bf0c1c85253d42141cad83f768(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5756e2e21717acb28073574884a32735dca317b53f944e7359e07b128314028(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3087bbe3eb170d0fc636c24bf556030977dbb92c4a5f36bc4dadf97233b5394f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f530449409282ad86b727fb11410ad4ef3fa6a94ed4c3407ab49be871fa44b06(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6c237c07b95b3a43fcecdfc13e77dec87d5603ad2d34fb9509a774591850b11(
    *,
    local_gateway_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    peer_gateway_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    peering_subnet_mask: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    physical_connection_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vlan_id: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    circuit_code: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8974cad520f2b085f065864fb1d51cc457b079b69fefbf0f10648ad1f8344ee(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosVpcPeerConnectionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bed53fefd9ff394e2041bb3a8d00f7ff6e40f341c90323afe98547093c633006(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb72ac418d8e8f0fc2a0967117455085b6a53bc42524410fd9afdad5ba30e637(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__411e257387a473985e9d11a7238f6b87c7e3a7d21b642ae2f67c33198e51489b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61e1fccd322f3d62f8a555ad593478e5c21a54b11333edf1362652559ecb2396(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d5e0e269fba554486d6a419282922c96ec1795cf8d4afcc653efd24e5ae25ea(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9026eadc828db9cca2b647edb912ab48be37c663def2e59f5474fdab04883bb8(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a62c7bc95ba02dad281780733b20a90357916c6f79932cf241ebb0d67f86247(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5af5d61322087420ec7da902ac105a56fee62c55dec4ba0ac80035bb6d86fca2(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75625182378103677aae966a14a575db8643b7747dca43049e7da05e71ed1d21(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f2c93304480b341b97edb164693d6eaef838a8a5750ff7cf6c429309964d817(
    *,
    accepting_vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    accepting_ali_uid: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    accepting_region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_force: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36c37407ff6cb0bd19e58ec97ac621c64242cf498880716e6e5ee5dd01a74348(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosVpnAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d30ce44413a9e627a132feff30cc0972330029651108e565f1ebed000b99fa3f(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12311299189231dcde6be12488ad0f69549a0a00cb5620261eca1dac375e58b3(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63ee0097f02737a40c9253586f11756484584c4211a6a7aefdc3d80196511197(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__611b14bb20358a066bd48bdfcdfe9307bc02675fe0e2d7724c2a0df2b692f2fe(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f1910544f14a43fb44d41108eee81f52cf5329d89c5ad9f4e153d4885a980b7(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c4cef3553bb396e5a70d00830f0c8208c9eddd84109617db3cbe0ad04b846b3(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3240b3e0e97a098d220786d11525ff5b147f450c594f7d821852eb39f5d2acfb(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.BgpConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__948a8f900b4079ab5ac5e2f3430a96f02945d1825a639b651499b4978fe5f0df(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0dc58f4bdc7e5e9e3c1670db03a4a1337f959ea6f1a88462b98316f22287b449(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8692830a580408ba2cff06ba898cab94a4daa7d2757e22cb5e3d7c72da12aa0(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__588c8cdd10220e11103a228ca1f4db213317b3900e5a233d7df50cd5e899e888(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.HealthCheckConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eed994f7a2b8e9bfe6a5cd2716431f2b8531e0ce9227f7c1b5dd1801f88d22c5(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IkeConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59087a7b41542e3fef22c5d38b4e5501ce7d816ece8586113cbebf4f6d12ed8e(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnAttachment.IpsecConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b952e06f2f5d9041babd2511fa428304335d9dcd2bf271693d0efd20e97051f1(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8690c5e6877b1666ce06007b03581c17d44e84f2baa156975688426e16da530f(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__714467ef84bc01d8b482be226f19fa90c2418f4fa9dea059108cb0779e7fcef6(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f813d82a18270f85c9cca21204a90d2ae8a962a65d6ec78070fa928a7c77e79(
    *,
    enable_bgp: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_bgp_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tunnel_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95f679d8e18e9f4ecd67794e336ef0da8037f8a3cc31c73d37f68bfe2bce08e6(
    *,
    dip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    interval: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    retry: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    sip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16b764251938487721b413a5cfcd84085024ad61b28c90c0f6c7caddb01f1e42(
    *,
    ike_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0729c17724e3226bb66d98445057f4e94d2e2c72aa813d6a8bb8997720e82838(
    *,
    ipsec_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__547b650b0b0960fce9a502d546f122faa7bb87955c65427feb7e1b496b2bc41c(
    *,
    customer_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    remote_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auto_config_route: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.BgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.HealthCheckConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_ca_cert: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3872d59216c7907048603c751ff9f971ed1c9e79957adc3da04606016090997d(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosVpnConnectionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7a2a539f3177548ac7085ac74354614333240cf3fe703796e9bda3b37d858a7(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0ea372e162db491831218393244bf1fb9e3935de6a63291811344e0f0d66683(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb0f9a51303120ff778015e15b39dc2954da6d3b998838aa0f3437019538a577(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33282f393380b866ed41de39794e96d838ab627e2bc2193d7c8aaae50224257c(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c0a95b3ff983ec19870e921b704efbc8c05bd7a7b8a502e4d6b5e7c7c7974cb(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a494114b53b1799b0fe3fac3b168e6d2a9d084fc1408f93cc1ae7334a00cc448(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eda04e6064cb5a0e83dfaf73de93f02c39d915ac3bb8fbac850ee4726d06da9f(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.BgpConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33a93db7dcb41c337781754a30d505f2a0c58d27a1c7b45ccd4f32f41510f680(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a877d3a454e0409f784c00b698df55cdfbac5ed83eb3846d9f05f5f6dfde19ef(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d71669d26aa26b537a98fa6d85171a24fa28d3638b19011c15cb34d982d015a5(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60de6e474d2d6c4d262141dc8d91231c112f361255b2a3157597da9a3a3c9f93(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a382729740405df4f3bc4878a9333ab70be55e69c4cea17d38be0f9da9c43c14(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d6e94e84fdf0552bb77967a632f70ca95639e20e9af5b6f37846e7428464bb9(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.HealthCheckConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__338690ebb0fb996d2ff6a7b7e83f0661101e8069037fe6e80493850029eafad2(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IkeConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25ebf454f853ec6b874d3e1b14bda3b6d434aee16b29062db8a2ccd538dfc6ad(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.IpsecConfigProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45035c568e16624c720543c238925aa341962724c4384e56c46a9744cb1eddc2(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c99e4292258c7fb608b181593a41fe3c9a862b29c2f0197ee3c3eb2620608e51(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__942c21eae4bc1e7515cf720984cc88931c73ba32a8126d5ae5c38c23342d20db(
    value: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.List[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, RosVpnConnection.TunnelOptionsSpecificationProperty]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a82a562a9c3a8618a46af978f7e6532be92a5f9f85f30402415a5125b80079f(
    *,
    enable_bgp: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_bgp_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tunnel_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11e27258538d4521e8893524ee144a5d365b63aaede8154c4f1ca67fcdd29c3f(
    *,
    dip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    interval: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    policy: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    retry: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    sip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17e8e6db1de3d7f27b249657fd5b566aa2240a10a6f4d4bf04b5d16e3c64210b(
    *,
    ike_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e73d2f883ca036313b49d62025580f8b7afb9c5d3c0aae0e444075c6e1b89252(
    *,
    ipsec_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65c691c3cb39b79d54384f064b45cdde8f8d96cc5976e4fe715b199375bb8d2b(
    *,
    local_asn: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_bgp_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tunnel_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5be189f3fe80ee84f5d7d664e3d2b255949a6ec2d6d49978932dc1b48e4e14d7(
    *,
    ike_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ike_version: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    local_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    psk: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4dcda3daa979b3e284b50ebd2a5371fb829e454309b6d4dc9768d41a425527ec(
    *,
    ipsec_auth_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_enc_alg: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_lifetime: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ipsec_pfs: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afc0b8cc0b749a73a090cae9d79228363d15a65b26b149e7c6c6906eb4ba3919(
    *,
    customer_gateway_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_ca_certificate: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    role: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tunnel_bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.TunnelBgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tunnel_ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.TunnelIkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tunnel_ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.TunnelIpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c07bef2a455b4ff902f477c74e0847a5fc2f67524dbdf5ad4fb6dc4a142ab8d2(
    *,
    local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    remote_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auto_config_route: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.BgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    customer_gateway_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_tunnels_bgp: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.HealthCheckConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_ca_certificate: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tunnel_options_specification: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.TunnelOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eae9f315680ca0399bec18869bd126d5aed6d544e5454fd2608e96001039ef08(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosVpnGatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ed6b67ec4fd4a2a5429c07998e0d4d48e8b0e048e31394c3e470da382c25529(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5239a3d8cbb8901c021c5adadc37a40928f8d2a1df989415ef9d97ae8b5fe08e(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e66efcc2afd6381bf5623ea53a4a514a0ff194a3af2a816841d17dec0efe121(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b586949fdfc77a17811a7ae35e6b0846dbb5adbffb2ed700c7ab9e36c52d93e4(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c054eb0f4c3716a4ee8dc0032356696bc7598242b45ecf8e10cfc2f19789243(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08850d626b6428d0bc1f3ce1e7e6551faf5b0ad8bc257fc193c28028a3e1f7f9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e028c466fdc142342f42bbcb6854a7c9cc3ec2a24f066b50113963312c2aa5b9(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db95aba88ee7f0e233942ecc8de5246c84ec8a5601836d632cca871845a9aa6b(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb89515c21a65a687a37e5b6623748411b971c4f458d55e8ae59f3c45c501f5d(
    value: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17899c0c049da93f1f50a7744bdb86e01ebb8933ebe593e40293c039300f1cbf(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf64680a92a2cc91db69dc066aee3723d13a39b8a6891c544cb5cbb4dccac5cd(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c067d28bcf9e11ddf4031fe88638fc179b34deb031364a47a4a4f341fe02a95d(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34878d3a3ab1359bc1ef1853a872a70f6c4fbc99a18c59f6b08b5242e55ed02d(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed2dafc0e095edfeab1826510b32decbff57f751ed5ad159efa87e7c2c9cf422(
    value: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f52211f3220057e51420e549ee27c885653e1c01cd4aebaaced0ff04566ddcf(
    value: typing.Optional[typing.List[RosVpnGateway.TagsProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__633678c40138fcd0239f1887fdccc815e6a7118ce9f6d7470c4d292f90d4312b(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf77ccf1bb76a0b2ff9eb01980aeaa3a4c172d3ba972abf8785c0ce012115a11(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12f9b4838b0f14300ae2b6516d930f4e2970a83dc5e8677351a0d10c15785565(
    *,
    key: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49087521e8677b8a339e79a6db272ebf17ae80b7afe23f5620af413f04696307(
    *,
    bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disaster_recovery_v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_ipsec: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_ssl: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ssl_connections: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosVpnGateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpn_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f60ef5946d39284f5a749bbdf04dcab02d4d222b31dd6a0ddcfbbc0e1011417b(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosVpnPbrRouteEntryProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48ac0b1c736f73135f5286c3ca5f8b422606d13207cce639aba2b5d56363c233(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f6a74d988b9841bbee473590b82bd56f4582195df0e931d1334603f05c8fe5b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ada0c9fede2ec8c7bbf156065e01030c4b92b921f0b5697663aecbac5c130b1c(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf0dcf7fa8b983f4c33a90ef57936fec7b0ecc3628db3cef44a2183ffbe5d849(
    value: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e831304443517a8cae3dc13e3da5f9250fd39ffe72a99aaba1c9ff49dd17da39(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcb5999c4d4d50a7e71f66f4196aa648cfdddf9b9252c5437e6aec39c7876ae9(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ddbd6887f84815e97d404ed58e7a9beb3e977e6169e412e75f55a85e8e5cba6(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c7ea2cdc0fee6efe2654cc661914cf91c77a55846ff272676a827b9e00ab419(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d46029aad4b7d51297604a6bd456d2b75ea23e53e8efdd76ef1f5d2be67245c4(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f206a887e99412d2d86aa158b639050676b54df314c2f805961ecaa6d2a41ae(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5519821cb9d1d2d9718681a376f572c31eea94be850661959f6bfc926c1fd017(
    *,
    next_hop: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    publish_vpc: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    route_dest: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    route_source: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    overlay_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af64cb9f65030562a4f6593525f5efc726c6a90340cf97c0214598735669f05f(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RosVpnRouteEntryProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__870e2556605fd5725a2ebd352de6cd9eca2b620f552dbb4f7f5ba2cb669c244b(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a897a0346327529e6903dd3fd63b9185d458c55247a03308abdff636e244cb2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a400b8e9bf17386b005ef88317de4d5d53dddf70c9453ee61fee2fdc91322b24(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5320b2dad33664e7f217a76593b3e1b8950b3aae25fbd44a50d0199871ed1540(
    value: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b445b952a122ccfcd97c7019d2d5b9be77230acf5abfa5d0d82036b723c2f3e0(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e85a37d48307082907d2bac1ccaecf110b5856e9c41f3997580482594d62e766(
    value: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee91327a98143c8678529d1e0cfc6643087133479be4d12dc210c4947fca62e4(
    value: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f329241f84df0f125821cebd89bd53e3499596c79f281d3c76bd2af0c67f923(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f645d5afa84fd628815418df8bdc923aa36164a6710464b0eb47321ca8d339b(
    value: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2dbfd9e82e97612ee14d4d6934d9b7946e9eed4d3dfc0ca778938deb91a5139(
    *,
    next_hop: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    publish_vpc: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    route_dest: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    overlay_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb8b046bb81ab7b694dce08c22c1db0c63932b94cb42cb58be18bb0070756dae(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RouteTableProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74db829651664507a05f08feba454dfaf152a8b9750f543f6d309a8ab5eb47a3(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RouteTableAssociationProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce1626791de7922aa0b909e8d14703c6bb04025f3ae5459e7accad7df40b7a6c(
    *,
    route_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    v_switch_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73fb5aecbf0881d7d9fbc1f39716c439c1c061229ef717da1b203c297d60e089(
    *,
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    route_table_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosRouteTable.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d88edaf8524326b6f60accf31a58b82e12acb2d8810bb58de8002682777e378c(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[RouterInterfaceProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd832dfc2d796baac3ce4d5cf992add1f084dac326049841fd8002bd78415d89(
    *,
    role: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    router_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    access_point_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_source_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_target_ip: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_access_point_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_interface_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_interface_owner_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_router_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    opposite_router_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    pricing_cycle: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    router_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    spec: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b3b3d8999976f00e35e33034605972fd400f901709cd21a14b642134ca0ee5a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[SnatEntryProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20c3a4ca9985f5a91cd47462b0da2510489cf5937cebd61309ba6ed25bec5233(
    *,
    snat_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    snat_table_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    eip_affinity: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    snat_entry_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_cidr: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    source_v_switch_ids: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a76526b36f8928eac8ea09df6cb1ce761a5ee0bcb98f63cc329d7c1e5821594c(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[SslVpnClientCertProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__546c17972d2a848da46028938b25b0080c7aeaeb17f2c75f5827fda2222a63c9(
    *,
    ssl_vpn_server_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7a434ddbc4ef2be51f5c635c78257a1bc63a5cdc584413d37a134215352be78(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[SslVpnServerProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51cdd9a696ae9679f9bd22e1edbf7bdd165b6336794fa196a29126667b6cf20c(
    *,
    client_ip_pool: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    cipher: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    compress: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    port: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    proto: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__131a1e0666b2b74708f9419a064e6556a9006ebe2112822870109d7339613740(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Optional[typing.Union[TrafficMirrorFilterProps, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b983335103beb9a9466f93a101c35c691f3d2b123e4e8ea508582bea0688e47(
    *,
    egress_rules: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosTrafficMirrorFilter.EgressRulesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ingress_rules: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosTrafficMirrorFilter.IngressRulesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    traffic_mirror_filter_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    traffic_mirror_filter_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af7d6f8aa393f21956211608da10c118a5b54fca065de3ac6d16a19fe791b0fb(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[TrafficMirrorSessionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18f1e23a81721c1ba6bf238036e7ded6bd30cf081df26d6dd7981da8fbfcf4cf(
    *,
    priority: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_mirror_filter_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_mirror_source_ids: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
    traffic_mirror_target_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_mirror_target_type: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    enabled: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    packet_length: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    resource_group_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tag: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[_ros_cdk_core_7adfd82f.RosTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    traffic_mirror_session_description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    traffic_mirror_session_name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    virtual_network_id: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71bb2456ecfecd1c97fb163fc54dbefe3c5dc60eabcdc8d5fda040ff2a32a18a(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[TrafficMirrorSessionSourcesAdditionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c906224e0920972bf8fa4ff13596976d733ab6540185eea1d70520dc2df9dbbf(
    *,
    traffic_mirror_session_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    traffic_mirror_source_ids: typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36118df4a6bc6bf1640093498d75bf5872bf27a91fb629af283f45bc87b911bd(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[VirtualBorderRouterProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e60407bab4403ff33b2d7c939917c4de8ebe4e6571428f7bda976a6553b1040(
    *,
    local_gateway_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    peer_gateway_ip: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    peering_subnet_mask: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    physical_connection_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vlan_id: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    circuit_code: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51e1b7216789c8257aadc0c43669adef693505c6906acf4dc42c32bb4138f9d2(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[VpcPeerConnectionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7badfe3561ac697868843036dc6b16e44d4f6149d51e904cd2f9f5272efea0f2(
    *,
    accepting_vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    accepting_ali_uid: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    accepting_region_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    deletion_force: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fb89eaec4c99fbec0442bd3d6b8a348f1f5ade3189ec7bfa685f087d927f7a8(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[VpnAttachmentProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27e399f8e7e324c722de23e12b815788ca9eed7a60893d37c0ad29a2e2f6c36f(
    *,
    customer_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    remote_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auto_config_route: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.BgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.HealthCheckConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnAttachment.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_ca_cert: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c18b129a6121c23e9ee1a0d7ed659ed0482d734661b0b681e6e5e60e0d2ea2d(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[VpnConnectionProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fddb5c172f8682726814311c1366b2b844444758c76bd1ce926173803170ee2(
    *,
    local_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    remote_subnet: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auto_config_route: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    bgp_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.BgpConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    customer_gateway_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    effect_immediately: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_dpd: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_nat_traversal: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_tunnels_bgp: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    health_check_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.HealthCheckConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ike_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.IkeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_config: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.IpsecConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    remote_ca_certificate: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tunnel_options_specification: typing.Optional[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Sequence[typing.Union[_ros_cdk_core_7adfd82f.IResolvable, typing.Union[RosVpnConnection.TunnelOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d76baaac194d14311626729070b9e922242e067a2174ed51fa16bbe0b453650c(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[VpnGatewayProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__506253f5be03d08b358b5d9ed35b5ba0559f3783788e2e9390e347123b6b7a45(
    *,
    bandwidth: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    vpc_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    auto_pay: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    disaster_recovery_v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_ipsec: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    enable_ssl: typing.Optional[typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    instance_charge_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    name: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    network_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    period: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    ssl_connections: typing.Optional[typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[RosVpnGateway.TagsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpn_type: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    v_switch_id: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__acd29d46027824b34e026c35d0f9ad9a3d0537828a642a2f07df17f91d1ee0c2(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[VpnPbrRouteEntryProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50d70d0eab7c97d009eefad6e644fb052a8f617f5453426e9889903c9cb04726(
    *,
    next_hop: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    publish_vpc: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    route_dest: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    route_source: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    overlay_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1eea84423f9a755f50cf4931757159cc2fe19b95900d6259607d2e0c53c3825(
    scope: _ros_cdk_core_7adfd82f.Construct,
    id: builtins.str,
    props: typing.Union[VpnRouteEntryProps, typing.Dict[builtins.str, typing.Any]],
    enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d4eb8964dafe4266c6c6780997855fba76d9971ae0433d15c3d71823bcb8372(
    *,
    next_hop: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    publish_vpc: typing.Union[builtins.bool, _ros_cdk_core_7adfd82f.IResolvable],
    route_dest: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    vpn_gateway_id: typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable],
    weight: typing.Union[jsii.Number, _ros_cdk_core_7adfd82f.IResolvable],
    description: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
    overlay_mode: typing.Optional[typing.Union[builtins.str, _ros_cdk_core_7adfd82f.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass
