"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Model = exports.ModelProperty = void 0;
const ros = require("@alicloud/ros-cdk-core");
const nlpautoml_generated_1 = require("./nlpautoml.generated");
Object.defineProperty(exports, "ModelProperty", { enumerable: true, get: function () { return nlpautoml_generated_1.RosModel; } });
/**
 * This class encapsulates and extends the ROS resource type `ALIYUN::NLPAUTOML::Model`, which is used to create a model.
 * @Note This class may have some new functions to facilitate development, so it is recommended to use this class instead of `RosModel`for a more convenient development experience.
 * See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-nlpautoml-model
 */
class Model extends ros.Resource {
    /**
     * Param scope - scope in which this resource is defined
     * Param id    - scoped id of the resource
     * Param props - resource properties
     */
    constructor(scope, id, props, enableResourcePropertyConstraint = true) {
        super(scope, id);
        const rosModel = new nlpautoml_generated_1.RosModel(this, id, {
            datasetIdList: props.datasetIdList,
            modelName: props.modelName,
            testDatasetIdList: props.testDatasetIdList,
            nepochs: props.nepochs,
            lr: props.lr,
            projectId: props.projectId,
            modelType: props.modelType,
        }, enableResourcePropertyConstraint && this.stack.enableResourcePropertyConstraint);
        this.resource = rosModel;
        this.attrModelId = rosModel.attrModelId;
        this.attrModelVersion = rosModel.attrModelVersion;
    }
}
exports.Model = Model;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtb2RlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw4Q0FBOEM7QUFDOUMsK0RBQWlEO0FBRTVCLDhGQUZaLDhCQUFRLE9BRWlCO0FBNkNsQzs7OztHQUlHO0FBQ0gsTUFBYSxLQUFNLFNBQVEsR0FBRyxDQUFDLFFBQVE7SUFZbkM7Ozs7T0FJRztJQUNILFlBQVksS0FBb0IsRUFBRSxFQUFVLEVBQUUsS0FBaUIsRUFBRSxtQ0FBMkMsSUFBSTtRQUM1RyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRWpCLE1BQU0sUUFBUSxHQUFHLElBQUksOEJBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFHO1lBQ3JDLGFBQWEsRUFBRSxLQUFLLENBQUMsYUFBYTtZQUNsQyxTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVM7WUFDMUIsaUJBQWlCLEVBQUUsS0FBSyxDQUFDLGlCQUFpQjtZQUMxQyxPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU87WUFDdEIsRUFBRSxFQUFFLEtBQUssQ0FBQyxFQUFFO1lBQ1osU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTO1lBQzFCLFNBQVMsRUFBRSxLQUFLLENBQUMsU0FBUztTQUM3QixFQUFFLGdDQUFnQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztRQUNwRixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7UUFDeEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztJQUN0RCxDQUFDO0NBQ0o7QUFqQ0Qsc0JBaUNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcm9zIGZyb20gJ0BhbGljbG91ZC9yb3MtY2RrLWNvcmUnO1xuaW1wb3J0IHsgUm9zTW9kZWwgfSBmcm9tICcuL25scGF1dG9tbC5nZW5lcmF0ZWQnO1xuLy8gR2VuZXJhdGVkIGZyb20gdGhlIEFsaUNsb3VkIFJPUyBSZXNvdXJjZSBTcGVjaWZpY2F0aW9uXG5leHBvcnQgeyBSb3NNb2RlbCBhcyBNb2RlbFByb3BlcnR5IH07XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgZGVmaW5pbmcgYSBgTW9kZWxgLlxuICogU2VlIGh0dHBzOi8vd3d3LmFsaWJhYmFjbG91ZC5jb20vaGVscC9yb3MvZGV2ZWxvcGVyLXJlZmVyZW5jZS9hbGl5dW4tbmxwYXV0b21sLW1vZGVsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxQcm9wcyB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSBkYXRhc2V0SWRMaXN0OiBUaGUgdXBsb2FkZWQgZGF0YXNldCBtdXN0IGJlIHVuZGVyIHRoZSBzYW1lIHByb2plY3QsIGFuZCB0aGUgdG90YWwgbnVtYmVyIG9mIG1hcmtlZCBkYXRhIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byA0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGRhdGFzZXRJZExpc3Q6IEFycmF5PG51bWJlciB8IHJvcy5JUmVzb2x2YWJsZT4gfCByb3MuSVJlc29sdmFibGU7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSBtb2RlbE5hbWU6IFRoZSBuYW1lIG9mIG1vZGVsLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IG1vZGVsTmFtZTogc3RyaW5nIHwgcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgbW9kZWxUeXBlOiBUaGUgdHlwZSBvZiBtb2RlbC4gUGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgcGFyYW1ldGVyIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGRpZmZlcmVudCB0eXBlcyBvZiBtb2RlbHMuXG4gICAgICogVXNpbmcgdGhlIHNwZWNpZmllZCBtb2RlbCB0eXBlIHVuZGVyIGRpZmZlcmVudCBwcm9qZWN0LCBhbmQgdGhlIGJhY2tlbmQgd2lsbCBkbyB0aGUgdmVyaWZpY2F0aW9uLiBJZiB0aGUgbW9kZWwgdHlwZSBkb2VzIG5vdCBleGlzdCB1bmRlciB0aGUgcHJvamVjdCwgaXQgd2lsbCBwcm9tcHQgdGhhdCB0aGUgYmFzZSBtb2RlbCBpcyBub3QgZm91bmRcbiAgICAgKi9cbiAgICByZWFkb25seSBtb2RlbFR5cGU6IHN0cmluZyB8IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IHByb2plY3RJZDogVGhlIHByb2plY3QgaWQgdG8gd2hpY2ggdGhlIG1vZGVsIGJlbG9uZ3NcbiAgICAgKi9cbiAgICByZWFkb25seSBwcm9qZWN0SWQ6IG51bWJlciB8IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IGxyOiBMZWFybmluZyByYXRlLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGxyPzogc3RyaW5nIHwgcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgbmVwb2NoczogTnVtYmVyIG9mIHRyYWluaW5nIGRhdGFzZXQgaXRlcmF0aW9uc1xuICAgICAqL1xuICAgIHJlYWRvbmx5IG5lcG9jaHM/OiBzdHJpbmcgfCByb3MuSVJlc29sdmFibGU7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSB0ZXN0RGF0YXNldElkTGlzdDogVGVzdCBzZXQgSUQgbGlzdC4gU29tZSBtb2RlbHMgdW5kZXIgdGV4dCBjbGFzc2lmaWNhdGlvbiBzdXBwb3J0IGFkZGluZyB0ZXN0IHNldCBkYXRhLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHRlc3REYXRhc2V0SWRMaXN0PzogQXJyYXk8bnVtYmVyIHwgcm9zLklSZXNvbHZhYmxlPiB8IHJvcy5JUmVzb2x2YWJsZTtcbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVuY2Fwc3VsYXRlcyBhbmQgZXh0ZW5kcyB0aGUgUk9TIHJlc291cmNlIHR5cGUgYEFMSVlVTjo6TkxQQVVUT01MOjpNb2RlbGAsIHdoaWNoIGlzIHVzZWQgdG8gY3JlYXRlIGEgbW9kZWwuXG4gKiBATm90ZSBUaGlzIGNsYXNzIG1heSBoYXZlIHNvbWUgbmV3IGZ1bmN0aW9ucyB0byBmYWNpbGl0YXRlIGRldmVsb3BtZW50LCBzbyBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIGBSb3NNb2RlbGBmb3IgYSBtb3JlIGNvbnZlbmllbnQgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZS5cbiAqIFNlZSBodHRwczovL3d3dy5hbGliYWJhY2xvdWQuY29tL2hlbHAvcm9zL2RldmVsb3Blci1yZWZlcmVuY2UvYWxpeXVuLW5scGF1dG9tbC1tb2RlbFxuICovXG5leHBvcnQgY2xhc3MgTW9kZWwgZXh0ZW5kcyByb3MuUmVzb3VyY2Uge1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlIE1vZGVsSWQ6IFRoZSBJRCBvZiBtb2RlbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgYXR0ck1vZGVsSWQ6IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZSBNb2RlbFZlcnNpb246IFRoZSB2ZXJzaW9uIG9mIG1vZGVsLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBhdHRyTW9kZWxWZXJzaW9uOiByb3MuSVJlc29sdmFibGU7XG5cbiAgICAvKipcbiAgICAgKiBQYXJhbSBzY29wZSAtIHNjb3BlIGluIHdoaWNoIHRoaXMgcmVzb3VyY2UgaXMgZGVmaW5lZFxuICAgICAqIFBhcmFtIGlkICAgIC0gc2NvcGVkIGlkIG9mIHRoZSByZXNvdXJjZVxuICAgICAqIFBhcmFtIHByb3BzIC0gcmVzb3VyY2UgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlOiByb3MuQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogTW9kZWxQcm9wcywgZW5hYmxlUmVzb3VyY2VQcm9wZXJ0eUNvbnN0cmFpbnQ6Ym9vbGVhbiA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgICAgICBjb25zdCByb3NNb2RlbCA9IG5ldyBSb3NNb2RlbCh0aGlzLCBpZCwgIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZExpc3Q6IHByb3BzLmRhdGFzZXRJZExpc3QsXG4gICAgICAgICAgICBtb2RlbE5hbWU6IHByb3BzLm1vZGVsTmFtZSxcbiAgICAgICAgICAgIHRlc3REYXRhc2V0SWRMaXN0OiBwcm9wcy50ZXN0RGF0YXNldElkTGlzdCxcbiAgICAgICAgICAgIG5lcG9jaHM6IHByb3BzLm5lcG9jaHMsXG4gICAgICAgICAgICBscjogcHJvcHMubHIsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHByb3BzLnByb2plY3RJZCxcbiAgICAgICAgICAgIG1vZGVsVHlwZTogcHJvcHMubW9kZWxUeXBlLFxuICAgICAgICB9LCBlbmFibGVSZXNvdXJjZVByb3BlcnR5Q29uc3RyYWludCAmJiB0aGlzLnN0YWNrLmVuYWJsZVJlc291cmNlUHJvcGVydHlDb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHJvc01vZGVsO1xuICAgICAgICB0aGlzLmF0dHJNb2RlbElkID0gcm9zTW9kZWwuYXR0ck1vZGVsSWQ7XG4gICAgICAgIHRoaXMuYXR0ck1vZGVsVmVyc2lvbiA9IHJvc01vZGVsLmF0dHJNb2RlbFZlcnNpb247XG4gICAgfVxufVxuIl19