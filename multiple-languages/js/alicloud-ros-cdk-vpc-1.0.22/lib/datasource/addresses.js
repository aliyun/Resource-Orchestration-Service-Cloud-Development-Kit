"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Addresses = exports.AddressesProperty = void 0;
const ros = require("@alicloud/ros-cdk-core");
const vpc_generated_1 = require("./vpc.generated");
Object.defineProperty(exports, "AddressesProperty", { enumerable: true, get: function () { return vpc_generated_1.RosAddresses; } });
/**
 * This class encapsulates and extends the ROS resource type `DATASOURCE::EIP::Addresses`, which is used to query the information about elastic IP addresses (EIPs).
 * @Note This class may have some new functions to facilitate development, so it is recommended to use this class instead of `RosAddresses`for a more convenient development experience.
 * See https://www.alibabacloud.com/help/ros/developer-reference/datasource-eip-addresses
 */
class Addresses extends ros.Resource {
    /**
     * Param scope - scope in which this resource is defined
     * Param id    - scoped id of the resource
     * Param props - resource properties
     */
    constructor(scope, id, props = {}, enableResourcePropertyConstraint = true) {
        super(scope, id);
        const rosAddresses = new vpc_generated_1.RosAddresses(this, id, {
            segmentInstanceId: props.segmentInstanceId,
            addressName: props.addressName,
            resourceGroupId: props.resourceGroupId,
            instanceId: props.instanceId,
            isp: props.isp,
            allocationId: props.allocationId,
            paymentType: props.paymentType,
            ipAddress: props.ipAddress,
            instanceType: props.instanceType,
        }, enableResourcePropertyConstraint && this.stack.enableResourcePropertyConstraint);
        this.resource = rosAddresses;
        this.attrAddresses = rosAddresses.attrAddresses;
        this.attrAllocationIds = rosAddresses.attrAllocationIds;
    }
}
exports.Addresses = Addresses;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkcmVzc2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYWRkcmVzc2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDhDQUE4QztBQUM5QyxtREFBK0M7QUFFdEIsa0dBRmhCLDRCQUFZLE9BRXFCO0FBeUUxQzs7OztHQUlHO0FBQ0gsTUFBYSxTQUFVLFNBQVEsR0FBRyxDQUFDLFFBQVE7SUFZdkM7Ozs7T0FJRztJQUNILFlBQVksS0FBb0IsRUFBRSxFQUFVLEVBQUUsUUFBd0IsRUFBRSxFQUFFLG1DQUEyQyxJQUFJO1FBQ3JILEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFakIsTUFBTSxZQUFZLEdBQUcsSUFBSSw0QkFBWSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUc7WUFDN0MsaUJBQWlCLEVBQUUsS0FBSyxDQUFDLGlCQUFpQjtZQUMxQyxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVc7WUFDOUIsZUFBZSxFQUFFLEtBQUssQ0FBQyxlQUFlO1lBQ3RDLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTtZQUM1QixHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUc7WUFDZCxZQUFZLEVBQUUsS0FBSyxDQUFDLFlBQVk7WUFDaEMsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO1lBQzlCLFNBQVMsRUFBRSxLQUFLLENBQUMsU0FBUztZQUMxQixZQUFZLEVBQUUsS0FBSyxDQUFDLFlBQVk7U0FDbkMsRUFBRSxnQ0FBZ0MsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7UUFDcEYsSUFBSSxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUM7UUFDN0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDO1FBQ2hELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxZQUFZLENBQUMsaUJBQWlCLENBQUM7SUFDNUQsQ0FBQztDQUNKO0FBbkNELDhCQW1DQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHJvcyBmcm9tICdAYWxpY2xvdWQvcm9zLWNkay1jb3JlJztcbmltcG9ydCB7IFJvc0FkZHJlc3NlcyB9IGZyb20gJy4vdnBjLmdlbmVyYXRlZCc7XG4vLyBHZW5lcmF0ZWQgZnJvbSB0aGUgQWxpQ2xvdWQgUk9TIFJlc291cmNlIFNwZWNpZmljYXRpb25cbmV4cG9ydCB7IFJvc0FkZHJlc3NlcyBhcyBBZGRyZXNzZXNQcm9wZXJ0eSB9O1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGRlZmluaW5nIGEgYEFkZHJlc3Nlc2AuXG4gKiBTZWUgaHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3Jvcy9kZXZlbG9wZXItcmVmZXJlbmNlL2RhdGFzb3VyY2UtZWlwLWFkZHJlc3Nlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3Nlc1Byb3BzIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IGFkZHJlc3NOYW1lOiBUaGUgbmFtZSBvZiB0aGUgRUlQLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGFkZHJlc3NOYW1lPzogc3RyaW5nIHwgcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgYWxsb2NhdGlvbklkOiBUaGUgSUQgb2YgdGhlIEVJUCB0aGF0IHlvdSB3YW50IHRvIHF1ZXJ5LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGFsbG9jYXRpb25JZD86IHN0cmluZyB8IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IGluc3RhbmNlSWQ6IFRoZSBJRCBvZiB0aGUgY2xvdWQgcmVzb3VyY2UuXG4gICAgICovXG4gICAgcmVhZG9ubHkgaW5zdGFuY2VJZD86IHN0cmluZyB8IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IGluc3RhbmNlVHlwZTogVGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgYm91bmQgaW5zdGFuY2UuXG4gICAgICogLSAqKkVjc0luc3RhbmNlKio6IGFuIEVDUyBpbnN0YW5jZSBvZiB0aGUgVlBDIHR5cGUuXG4gICAgICogLSAqKlNsYkluc3RhbmNlKio6IGFuIFNMQiBpbnN0YW5jZSBvZiB0aGUgVlBDIHR5cGUuXG4gICAgICogLSAqKk5hdCoqOk5BVCBnYXRld2F5LlxuICAgICAqIC0gKipIYVZpcCoqOiBhIGhpZ2hseSBhdmFpbGFibGUgdmlydHVhbCBJUCBhZGRyZXNzLlxuICAgICAqIC0gKipOZXR3b3JrSW50ZXJmYWNlKio6IFNlY29uZGFyeSBFTkkuXG4gICAgICovXG4gICAgcmVhZG9ubHkgaW5zdGFuY2VUeXBlPzogc3RyaW5nIHwgcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgaXBBZGRyZXNzOiBUaGUgSVAgYWRkcmVzcyBwb29sIHRvIHdoaWNoIHRoZSBFSVAgdGhhdCB5b3Ugd2FudCB0byBxdWVyeSBiZWxvbmdzLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGlwQWRkcmVzcz86IHN0cmluZyB8IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IGlzcDogVGhlIGxpbmUgdHlwZS4gVmFsaWQgdmFsdWVzOlxuICAgICAqIEJHUCAoZGVmYXVsdCk6IEJHUCAoTXVsdGktSVNQKSBsaW5lcy4gQWxsIHJlZ2lvbnMgc3VwcG9ydCBCR1AgKE11bHRpLUlTUCkgRUlQcy5cbiAgICAgKiBCR1BfUFJPOiBCR1AgKE11bHRpLUlTUCkgUHJvIGxpbmVzLiBcbiAgICAgKiBPbmx5IHRoZSBmb2xsb3dpbmcgcmVnaW9ucyBzdXBwb3J0IEJHUCAoTXVsdGktSVNQKSBQcm8gbGluZXM6IFxuICAgICAqIENoaW5hIChIb25nIEtvbmcpLCBTaW5nYXBvcmUsIE1hbGF5c2lhIChLdWFsYSBMdW1wdXIpLCBQaGlsaXBwaW5lcyAoTWFuaWxhKSwgSW5kb25lc2lhIChKYWthcnRhKSwgYW5kIFRoYWlsYW5kIChCYW5na29rKS5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBCR1AgKE11bHRpLUlTUCkgYW5kIEJHUCAoTXVsdGktSVNQKSBQcm8sIHNlZSBFSVAgbGluZSB0eXBlcy5cbiAgICAgKiBJZiB5b3UgYXJlIGFsbG93ZWQgdG8gdXNlIHNpbmdsZS1JU1AgYmFuZHdpZHRoLCB5b3UgY2FuIGFsc28gY2hvb3NlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAgICAgKiBDaGluYVRlbGVjb206IENoaW5hIFRlbGVjb21cbiAgICAgKiBDaGluYVVuaWNvbTogQ2hpbmEgVW5pY29tXG4gICAgICogQ2hpbmFNb2JpbGU6IENoaW5hIE1vYmlsZVxuICAgICAqIENoaW5hVGVsZWNvbV9MMjogQ2hpbmEgVGVsZWNvbSBMMlxuICAgICAqIENoaW5hVW5pY29tX0wyOiBDaGluYSBVbmljb20gTDJcbiAgICAgKiBDaGluYU1vYmlsZV9MMjogQ2hpbmEgTW9iaWxlIEwyXG4gICAgICogSWYgeW91ciBzZXJ2aWNlcyBhcmUgZGVwbG95ZWQgaW4gQ2hpbmEgRWFzdCAxIEZpbmFuY2UsIHlvdSBtdXN0IHNldCB0aGlzIHBhcmFtZXRlciB0byBCR1BfRmluYW5jZUNsb3VkLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGlzcD86IHN0cmluZyB8IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IHBheW1lbnRUeXBlOiBUaGUgYmlsbGluZyBtZXRob2Qgb2YgdGhlIEVJUC4gVmFsaWQgdmFsdWVzOiAgUHJlUGFpZDogc3Vic2NyaXB0aW9uIFBvc3RQYWlkOiBwYXktYXMteW91LWdvLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHBheW1lbnRUeXBlPzogc3RyaW5nIHwgcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgcmVzb3VyY2VHcm91cElkOiBUaGUgSUQgb2YgdGhlIHJlc291cmNlIGdyb3VwIHRvIHdoaWNoIHRoZSBFSVBzIGJlbG9uZy5cbiAgICAgKi9cbiAgICByZWFkb25seSByZXNvdXJjZUdyb3VwSWQ/OiBzdHJpbmcgfCByb3MuSVJlc29sdmFibGU7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSBzZWdtZW50SW5zdGFuY2VJZDogVGhlIElEIG9mIHRoZSBjb25zZWN1dGl2ZSBFSVBzLlxuICAgICAqIFRoaXMgcGFyYW1ldGVyIHZhbHVlIGlzIHJldHVybmVkIG9ubHkgaWYgdGhlIEVJUCBpcyBhIGNvbnRpbnVvdXMgRUlQLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNlZ21lbnRJbnN0YW5jZUlkPzogc3RyaW5nIHwgcm9zLklSZXNvbHZhYmxlO1xufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIGFuZCBleHRlbmRzIHRoZSBST1MgcmVzb3VyY2UgdHlwZSBgREFUQVNPVVJDRTo6RUlQOjpBZGRyZXNzZXNgLCB3aGljaCBpcyB1c2VkIHRvIHF1ZXJ5IHRoZSBpbmZvcm1hdGlvbiBhYm91dCBlbGFzdGljIElQIGFkZHJlc3NlcyAoRUlQcykuXG4gKiBATm90ZSBUaGlzIGNsYXNzIG1heSBoYXZlIHNvbWUgbmV3IGZ1bmN0aW9ucyB0byBmYWNpbGl0YXRlIGRldmVsb3BtZW50LCBzbyBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIGBSb3NBZGRyZXNzZXNgZm9yIGEgbW9yZSBjb252ZW5pZW50IGRldmVsb3BtZW50IGV4cGVyaWVuY2UuXG4gKiBTZWUgaHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3Jvcy9kZXZlbG9wZXItcmVmZXJlbmNlL2RhdGFzb3VyY2UtZWlwLWFkZHJlc3Nlc1xuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc2VzIGV4dGVuZHMgcm9zLlJlc291cmNlIHtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZSBBZGRyZXNzZXM6IFRoZSBkZXRhaWxzIGFib3V0IHRoZSBFSVBcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgYXR0ckFkZHJlc3Nlczogcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlIEFsbG9jYXRpb25JZHM6IFRoZSBsaXN0IG9mIGFsbG9jYXRpb24gSURzLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBhdHRyQWxsb2NhdGlvbklkczogcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW0gc2NvcGUgLSBzY29wZSBpbiB3aGljaCB0aGlzIHJlc291cmNlIGlzIGRlZmluZWRcbiAgICAgKiBQYXJhbSBpZCAgICAtIHNjb3BlZCBpZCBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKiBQYXJhbSBwcm9wcyAtIHJlc291cmNlIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzY29wZTogcm9zLkNvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEFkZHJlc3Nlc1Byb3BzID0ge30sIGVuYWJsZVJlc291cmNlUHJvcGVydHlDb25zdHJhaW50OmJvb2xlYW4gPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICAgICAgY29uc3Qgcm9zQWRkcmVzc2VzID0gbmV3IFJvc0FkZHJlc3Nlcyh0aGlzLCBpZCwgIHtcbiAgICAgICAgICAgIHNlZ21lbnRJbnN0YW5jZUlkOiBwcm9wcy5zZWdtZW50SW5zdGFuY2VJZCxcbiAgICAgICAgICAgIGFkZHJlc3NOYW1lOiBwcm9wcy5hZGRyZXNzTmFtZSxcbiAgICAgICAgICAgIHJlc291cmNlR3JvdXBJZDogcHJvcHMucmVzb3VyY2VHcm91cElkLFxuICAgICAgICAgICAgaW5zdGFuY2VJZDogcHJvcHMuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgIGlzcDogcHJvcHMuaXNwLFxuICAgICAgICAgICAgYWxsb2NhdGlvbklkOiBwcm9wcy5hbGxvY2F0aW9uSWQsXG4gICAgICAgICAgICBwYXltZW50VHlwZTogcHJvcHMucGF5bWVudFR5cGUsXG4gICAgICAgICAgICBpcEFkZHJlc3M6IHByb3BzLmlwQWRkcmVzcyxcbiAgICAgICAgICAgIGluc3RhbmNlVHlwZTogcHJvcHMuaW5zdGFuY2VUeXBlLFxuICAgICAgICB9LCBlbmFibGVSZXNvdXJjZVByb3BlcnR5Q29uc3RyYWludCAmJiB0aGlzLnN0YWNrLmVuYWJsZVJlc291cmNlUHJvcGVydHlDb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHJvc0FkZHJlc3NlcztcbiAgICAgICAgdGhpcy5hdHRyQWRkcmVzc2VzID0gcm9zQWRkcmVzc2VzLmF0dHJBZGRyZXNzZXM7XG4gICAgICAgIHRoaXMuYXR0ckFsbG9jYXRpb25JZHMgPSByb3NBZGRyZXNzZXMuYXR0ckFsbG9jYXRpb25JZHM7XG4gICAgfVxufVxuIl19