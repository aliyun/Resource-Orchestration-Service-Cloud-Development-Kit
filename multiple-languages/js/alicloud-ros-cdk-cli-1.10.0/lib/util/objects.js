"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepMerge = exports.deepSet = exports.deepGet = exports.makeObject = exports.mapObject = exports.deepClone = exports.isEmpty = exports.applyDefaults = void 0;
const types_1 = require("./types");
/**
 * Return a new object by adding missing keys into another object
 */
function applyDefaults(hash, defaults) {
    const result = {};
    Object.keys(hash).forEach((k) => (result[k] = hash[k]));
    Object.keys(defaults)
        .filter((k) => !(k in result))
        .forEach((k) => (result[k] = defaults[k]));
    return result;
}
exports.applyDefaults = applyDefaults;
/**
 * Return whether the given parameter is an empty object or empty list.
 */
function isEmpty(x) {
    if (x == null) {
        return false;
    }
    if ((0, types_1.isArray)(x)) {
        return x.length === 0;
    }
    return Object.keys(x).length === 0;
}
exports.isEmpty = isEmpty;
/**
 * Deep clone a tree of objects, lists or scalars
 *
 * Does not support cycles.
 */
function deepClone(x) {
    if (typeof x === 'undefined') {
        return undefined;
    }
    if (x === null) {
        return null;
    }
    if ((0, types_1.isArray)(x)) {
        return x.map(deepClone);
    }
    if ((0, types_1.isObject)(x)) {
        return makeObject(mapObject(x, (k, v) => [k, deepClone(v)]));
    }
    return x;
}
exports.deepClone = deepClone;
/**
 * Map over an object, treating it as a dictionary
 */
function mapObject(x, fn) {
    const ret = [];
    Object.keys(x).forEach((key) => {
        ret.push(fn(key, x[key]));
    });
    return ret;
}
exports.mapObject = mapObject;
/**
 * Construct an object from a list of (k, v) pairs
 */
function makeObject(pairs) {
    const ret = {};
    for (const pair of pairs) {
        ret[pair[0]] = pair[1];
    }
    return ret;
}
exports.makeObject = makeObject;
/**
 * Deep get a value from a tree of nested objects
 *
 * Returns undefined if any part of the path was unset or
 * not an object.
 */
function deepGet(x, path) {
    path = path.slice();
    while (path.length > 0 && (0, types_1.isObject)(x)) {
        const key = path.shift();
        x = x[key];
    }
    return path.length === 0 ? x : undefined;
}
exports.deepGet = deepGet;
/**
 * Deep set a value in a tree of nested objects
 *
 * Throws an error if any part of the path is not an object.
 */
function deepSet(x, path, value) {
    path = path.slice();
    if (path.length === 0) {
        throw new Error('Path may not be empty');
    }
    while (path.length > 1 && (0, types_1.isObject)(x)) {
        const key = path.shift();
        if (!(key in x)) {
            x[key] = {};
        }
        x = x[key];
    }
    if (!(0, types_1.isObject)(x)) {
        throw new Error(`Expected an object, got '${x}'`);
    }
    if (value !== undefined) {
        x[path[0]] = value;
    }
    else {
        delete x[path[0]];
    }
}
exports.deepSet = deepSet;
/**
 * Recursively merge objects together
 *
 * The leftmost object is mutated and returned. Arrays are not merged
 * but overwritten just like scalars.
 *
 * If an object is merged into a non-object, the non-object is lost.
 */
function deepMerge(...objects) {
    function mergeOne(target, source) {
        for (const key of Object.keys(source)) {
            const value = source[key];
            if ((0, types_1.isObject)(value)) {
                if (!(0, types_1.isObject)(target[key])) {
                    target[key] = {};
                } // Overwrite on purpose
                mergeOne(target[key], value);
            }
            else if (typeof value !== 'undefined') {
                target[key] = value;
            }
        }
    }
    const others = objects.filter((x) => x != null);
    if (others.length === 0) {
        return {};
    }
    const into = others.splice(0, 1)[0];
    others.forEach((other) => mergeOne(into, other));
    return into;
}
exports.deepMerge = deepMerge;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9iamVjdHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWlEO0FBRWpEOztHQUVHO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLElBQVMsRUFBRSxRQUFhO0lBQ3BELE1BQU0sTUFBTSxHQUFRLEVBQUUsQ0FBQztJQUV2QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV4RCxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztTQUNsQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUM7U0FDN0IsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTdDLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFWRCxzQ0FVQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLENBQU07SUFDNUIsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFO1FBQ2IsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELElBQUksSUFBQSxlQUFPLEVBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDZCxPQUFPLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0tBQ3ZCO0lBQ0QsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7QUFDckMsQ0FBQztBQVJELDBCQVFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFNBQVMsQ0FBQyxDQUFNO0lB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WDtJQUNELE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXBDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNqRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUF6QkQsOEJBeUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNBcnJheSwgaXNPYmplY3QsIE9iaiB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFJldHVybiBhIG5ldyBvYmplY3QgYnkgYWRkaW5nIG1pc3Npbmcga2V5cyBpbnRvIGFub3RoZXIgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRzKGhhc2g6IGFueSwgZGVmYXVsdHM6IGFueSkge1xuICBjb25zdCByZXN1bHQ6IGFueSA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKGhhc2gpLmZvckVhY2goKGspID0+IChyZXN1bHRba10gPSBoYXNoW2tdKSk7XG5cbiAgT2JqZWN0LmtleXMoZGVmYXVsdHMpXG4gICAgLmZpbHRlcigoaykgPT4gIShrIGluIHJlc3VsdCkpXG4gICAgLmZvckVhY2goKGspID0+IChyZXN1bHRba10gPSBkZWZhdWx0c1trXSkpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBhbiBlbXB0eSBvYmplY3Qgb3IgZW1wdHkgbGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoeDogYW55KSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4geC5sZW5ndGggPT09IDA7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHgpLmxlbmd0aCA9PT0gMDtcbn1cblxuLyoqXG4gKiBEZWVwIGNsb25lIGEgdHJlZSBvZiBvYmplY3RzLCBsaXN0cyBvciBzY2FsYXJzXG4gKlxuICogRG9lcyBub3Qgc3VwcG9ydCBjeWNsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUoeDogYW55KTogYW55IHtcbiAgaWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNBcnJheSh4KSkge1xuICAgIHJldHVybiB4Lm1hcChkZWVwQ2xvbmUpO1xuICB9XG4gIGlmIChpc09iamVjdCh4KSkge1xuICAgIHJldHVybiBtYWtlT2JqZWN0KG1hcE9iamVjdCh4LCAoaywgdikgPT4gW2ssIGRlZXBDbG9uZSh2KV0gYXMgW3N0cmluZywgYW55XSkpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG4vKipcbiAqIE1hcCBvdmVyIGFuIG9iamVjdCwgdHJlYXRpbmcgaXQgYXMgYSBkaWN0aW9uYXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBPYmplY3Q8VCwgVT4oeDogT2JqPFQ+LCBmbjogKGtleTogc3RyaW5nLCB2YWx1ZTogVCkgPT4gVSk6IFVbXSB7XG4gIGNvbnN0IHJldDogVVtdID0gW107XG4gIE9iamVjdC5rZXlzKHgpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHJldC5wdXNoKGZuKGtleSwgeFtrZXldKSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhbiBvYmplY3QgZnJvbSBhIGxpc3Qgb2YgKGssIHYpIHBhaXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT2JqZWN0PFQ+KHBhaXJzOiBBcnJheTxbc3RyaW5nLCBUXT4pOiBPYmo8VD4ge1xuICBjb25zdCByZXQ6IE9iajxUPiA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICByZXRbcGFpclswXV0gPSBwYWlyWzFdO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRGVlcCBnZXQgYSB2YWx1ZSBmcm9tIGEgdHJlZSBvZiBuZXN0ZWQgb2JqZWN0c1xuICpcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIGFueSBwYXJ0IG9mIHRoZSBwYXRoIHdhcyB1bnNldCBvclxuICogbm90IGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBHZXQoeDogYW55LCBwYXRoOiBzdHJpbmdbXSk6IGFueSB7XG4gIHBhdGggPSBwYXRoLnNsaWNlKCk7XG5cbiAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCAmJiBpc09iamVjdCh4KSkge1xuICAgIGNvbnN0IGtleSA9IHBhdGguc2hpZnQoKSE7XG4gICAgeCA9IHhba2V5XTtcbiAgfVxuICByZXR1cm4gcGF0aC5sZW5ndGggPT09IDAgPyB4IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERlZXAgc2V0IGEgdmFsdWUgaW4gYSB0cmVlIG9mIG5lc3RlZCBvYmplY3RzXG4gKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGFueSBwYXJ0IG9mIHRoZSBwYXRoIGlzIG5vdCBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwU2V0KHg6IGFueSwgcGF0aDogc3RyaW5nW10sIHZhbHVlOiBhbnkpIHtcbiAgcGF0aCA9IHBhdGguc2xpY2UoKTtcblxuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbWF5IG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMSAmJiBpc09iamVjdCh4KSkge1xuICAgIGNvbnN0IGtleSA9IHBhdGguc2hpZnQoKSE7XG4gICAgaWYgKCEoa2V5IGluIHgpKSB7XG4gICAgICB4W2tleV0gPSB7fTtcbiAgICB9XG4gICAgeCA9IHhba2V5XTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QoeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIG9iamVjdCwgZ290ICcke3h9J2ApO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB4W3BhdGhbMF1dID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHhbcGF0aFswXV07XG4gIH1cbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIHRvZ2V0aGVyXG4gKlxuICogVGhlIGxlZnRtb3N0IG9iamVjdCBpcyBtdXRhdGVkIGFuZCByZXR1cm5lZC4gQXJyYXlzIGFyZSBub3QgbWVyZ2VkXG4gKiBidXQgb3ZlcndyaXR0ZW4ganVzdCBsaWtlIHNjYWxhcnMuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIG1lcmdlZCBpbnRvIGEgbm9uLW9iamVjdCwgdGhlIG5vbi1vYmplY3QgaXMgbG9zdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNZXJnZSguLi5vYmplY3RzOiBBcnJheTxPYmo8YW55PiB8IHVuZGVmaW5lZD4pIHtcbiAgZnVuY3Rpb24gbWVyZ2VPbmUodGFyZ2V0OiBPYmo8YW55Piwgc291cmNlOiBPYmo8YW55Pikge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICB9IC8vIE92ZXJ3cml0ZSBvbiBwdXJwb3NlXG4gICAgICAgIG1lcmdlT25lKHRhcmdldFtrZXldLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvdGhlcnMgPSBvYmplY3RzLmZpbHRlcigoeCkgPT4geCAhPSBudWxsKSBhcyBBcnJheTxPYmo8YW55Pj47XG5cbiAgaWYgKG90aGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgaW50byA9IG90aGVycy5zcGxpY2UoMCwgMSlbMF07XG5cbiAgb3RoZXJzLmZvckVhY2goKG90aGVyKSA9PiBtZXJnZU9uZShpbnRvLCBvdGhlcikpO1xuICByZXR1cm4gaW50bztcbn1cbiJdfQ==