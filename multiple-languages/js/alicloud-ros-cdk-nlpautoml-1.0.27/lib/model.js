"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Model = exports.ModelProperty = void 0;
const ros = require("@alicloud/ros-cdk-core");
const nlpautoml_generated_1 = require("./nlpautoml.generated");
Object.defineProperty(exports, "ModelProperty", { enumerable: true, get: function () { return nlpautoml_generated_1.RosModel; } });
/**
 * This class encapsulates and extends the ROS resource type `ALIYUN::NLPAUTOML::Model`, which is used to create a model.
 * @Note This class may have some new functions to facilitate development, so it is recommended to use this class instead of `RosModel`for a more convenient development experience.
 * See https://www.alibabacloud.com/help/ros/developer-reference/aliyun-nlpautoml-model
 */
class Model extends ros.Resource {
    /**
     * Param scope - scope in which this resource is defined
     * Param id    - scoped id of the resource
     * Param props - resource properties
     */
    constructor(scope, id, props, enableResourcePropertyConstraint = true) {
        super(scope, id);
        this.scope = scope;
        this.id = id;
        this.props = props;
        this.enableResourcePropertyConstraint = enableResourcePropertyConstraint;
        const rosModel = new nlpautoml_generated_1.RosModel(this, id, {
            datasetIdList: props.datasetIdList,
            modelName: props.modelName,
            testDatasetIdList: props.testDatasetIdList,
            nepochs: props.nepochs,
            lr: props.lr,
            projectId: props.projectId,
            modelType: props.modelType,
        }, enableResourcePropertyConstraint && this.stack.enableResourcePropertyConstraint);
        this.resource = rosModel;
        this.attrModelId = rosModel.attrModelId;
        this.attrModelVersion = rosModel.attrModelVersion;
    }
}
exports.Model = Model;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtb2RlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw4Q0FBOEM7QUFDOUMsK0RBQWlEO0FBRTVCLDhGQUZaLDhCQUFRLE9BRWlCO0FBNkNsQzs7OztHQUlHO0FBQ0gsTUFBYSxLQUFNLFNBQVEsR0FBRyxDQUFDLFFBQVE7SUFnQm5DOzs7O09BSUc7SUFDSCxZQUFZLEtBQW9CLEVBQUUsRUFBVSxFQUFFLEtBQWlCLEVBQUUsbUNBQTJDLElBQUk7UUFDNUcsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUNiLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxnQ0FBZ0MsQ0FBQztRQUV6RSxNQUFNLFFBQVEsR0FBRyxJQUFJLDhCQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRztZQUNyQyxhQUFhLEVBQUUsS0FBSyxDQUFDLGFBQWE7WUFDbEMsU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTO1lBQzFCLGlCQUFpQixFQUFFLEtBQUssQ0FBQyxpQkFBaUI7WUFDMUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxPQUFPO1lBQ3RCLEVBQUUsRUFBRSxLQUFLLENBQUMsRUFBRTtZQUNaLFNBQVMsRUFBRSxLQUFLLENBQUMsU0FBUztZQUMxQixTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVM7U0FDN0IsRUFBRSxnQ0FBZ0MsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7UUFDcEYsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUM7SUFDdEQsQ0FBQztDQUNKO0FBekNELHNCQXlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHJvcyBmcm9tICdAYWxpY2xvdWQvcm9zLWNkay1jb3JlJztcbmltcG9ydCB7IFJvc01vZGVsIH0gZnJvbSAnLi9ubHBhdXRvbWwuZ2VuZXJhdGVkJztcbi8vIEdlbmVyYXRlZCBmcm9tIHRoZSBBbGlDbG91ZCBST1MgUmVzb3VyY2UgU3BlY2lmaWNhdGlvblxuZXhwb3J0IHsgUm9zTW9kZWwgYXMgTW9kZWxQcm9wZXJ0eSB9O1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGRlZmluaW5nIGEgYE1vZGVsYC5cbiAqIFNlZSBodHRwczovL3d3dy5hbGliYWJhY2xvdWQuY29tL2hlbHAvcm9zL2RldmVsb3Blci1yZWZlcmVuY2UvYWxpeXVuLW5scGF1dG9tbC1tb2RlbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsUHJvcHMge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgZGF0YXNldElkTGlzdDogVGhlIHVwbG9hZGVkIGRhdGFzZXQgbXVzdCBiZSB1bmRlciB0aGUgc2FtZSBwcm9qZWN0LCBhbmQgdGhlIHRvdGFsIG51bWJlciBvZiBtYXJrZWQgZGF0YSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gNC5cbiAgICAgKi9cbiAgICByZWFkb25seSBkYXRhc2V0SWRMaXN0OiBBcnJheTxudW1iZXIgfCByb3MuSVJlc29sdmFibGU+IHwgcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgbW9kZWxOYW1lOiBUaGUgbmFtZSBvZiBtb2RlbC5cbiAgICAgKi9cbiAgICByZWFkb25seSBtb2RlbE5hbWU6IHN0cmluZyB8IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IG1vZGVsVHlwZTogVGhlIHR5cGUgb2YgbW9kZWwuIFBsZWFzZSByZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIHBhcmFtZXRlciB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBkaWZmZXJlbnQgdHlwZXMgb2YgbW9kZWxzLlxuICAgICAqIFVzaW5nIHRoZSBzcGVjaWZpZWQgbW9kZWwgdHlwZSB1bmRlciBkaWZmZXJlbnQgcHJvamVjdCwgYW5kIHRoZSBiYWNrZW5kIHdpbGwgZG8gdGhlIHZlcmlmaWNhdGlvbi4gSWYgdGhlIG1vZGVsIHR5cGUgZG9lcyBub3QgZXhpc3QgdW5kZXIgdGhlIHByb2plY3QsIGl0IHdpbGwgcHJvbXB0IHRoYXQgdGhlIGJhc2UgbW9kZWwgaXMgbm90IGZvdW5kXG4gICAgICovXG4gICAgcmVhZG9ubHkgbW9kZWxUeXBlOiBzdHJpbmcgfCByb3MuSVJlc29sdmFibGU7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSBwcm9qZWN0SWQ6IFRoZSBwcm9qZWN0IGlkIHRvIHdoaWNoIHRoZSBtb2RlbCBiZWxvbmdzXG4gICAgICovXG4gICAgcmVhZG9ubHkgcHJvamVjdElkOiBudW1iZXIgfCByb3MuSVJlc29sdmFibGU7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSBscjogTGVhcm5pbmcgcmF0ZS5cbiAgICAgKi9cbiAgICByZWFkb25seSBscj86IHN0cmluZyB8IHJvcy5JUmVzb2x2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IG5lcG9jaHM6IE51bWJlciBvZiB0cmFpbmluZyBkYXRhc2V0IGl0ZXJhdGlvbnNcbiAgICAgKi9cbiAgICByZWFkb25seSBuZXBvY2hzPzogc3RyaW5nIHwgcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgdGVzdERhdGFzZXRJZExpc3Q6IFRlc3Qgc2V0IElEIGxpc3QuIFNvbWUgbW9kZWxzIHVuZGVyIHRleHQgY2xhc3NpZmljYXRpb24gc3VwcG9ydCBhZGRpbmcgdGVzdCBzZXQgZGF0YS5cbiAgICAgKi9cbiAgICByZWFkb25seSB0ZXN0RGF0YXNldElkTGlzdD86IEFycmF5PG51bWJlciB8IHJvcy5JUmVzb2x2YWJsZT4gfCByb3MuSVJlc29sdmFibGU7XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgYW5kIGV4dGVuZHMgdGhlIFJPUyByZXNvdXJjZSB0eXBlIGBBTElZVU46Ok5MUEFVVE9NTDo6TW9kZWxgLCB3aGljaCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1vZGVsLlxuICogQE5vdGUgVGhpcyBjbGFzcyBtYXkgaGF2ZSBzb21lIG5ldyBmdW5jdGlvbnMgdG8gZmFjaWxpdGF0ZSBkZXZlbG9wbWVudCwgc28gaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiBgUm9zTW9kZWxgZm9yIGEgbW9yZSBjb252ZW5pZW50IGRldmVsb3BtZW50IGV4cGVyaWVuY2UuXG4gKiBTZWUgaHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3Jvcy9kZXZlbG9wZXItcmVmZXJlbmNlL2FsaXl1bi1ubHBhdXRvbWwtbW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGVsIGV4dGVuZHMgcm9zLlJlc291cmNlIHtcbiAgICBwcm90ZWN0ZWQgc2NvcGU6IHJvcy5Db25zdHJ1Y3Q7XG4gICAgcHJvdGVjdGVkIGlkOiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIHByb3BzOiBNb2RlbFByb3BzO1xuICAgIHByb3RlY3RlZCBlbmFibGVSZXNvdXJjZVByb3BlcnR5Q29uc3RyYWludDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZSBNb2RlbElkOiBUaGUgSUQgb2YgbW9kZWwuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGF0dHJNb2RlbElkOiByb3MuSVJlc29sdmFibGU7XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGUgTW9kZWxWZXJzaW9uOiBUaGUgdmVyc2lvbiBvZiBtb2RlbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgYXR0ck1vZGVsVmVyc2lvbjogcm9zLklSZXNvbHZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW0gc2NvcGUgLSBzY29wZSBpbiB3aGljaCB0aGlzIHJlc291cmNlIGlzIGRlZmluZWRcbiAgICAgKiBQYXJhbSBpZCAgICAtIHNjb3BlZCBpZCBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKiBQYXJhbSBwcm9wcyAtIHJlc291cmNlIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzY29wZTogcm9zLkNvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IE1vZGVsUHJvcHMsIGVuYWJsZVJlc291cmNlUHJvcGVydHlDb25zdHJhaW50OmJvb2xlYW4gPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlLCBpZCk7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuZW5hYmxlUmVzb3VyY2VQcm9wZXJ0eUNvbnN0cmFpbnQgPSBlbmFibGVSZXNvdXJjZVByb3BlcnR5Q29uc3RyYWludDtcblxuICAgICAgICBjb25zdCByb3NNb2RlbCA9IG5ldyBSb3NNb2RlbCh0aGlzLCBpZCwgIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZExpc3Q6IHByb3BzLmRhdGFzZXRJZExpc3QsXG4gICAgICAgICAgICBtb2RlbE5hbWU6IHByb3BzLm1vZGVsTmFtZSxcbiAgICAgICAgICAgIHRlc3REYXRhc2V0SWRMaXN0OiBwcm9wcy50ZXN0RGF0YXNldElkTGlzdCxcbiAgICAgICAgICAgIG5lcG9jaHM6IHByb3BzLm5lcG9jaHMsXG4gICAgICAgICAgICBscjogcHJvcHMubHIsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHByb3BzLnByb2plY3RJZCxcbiAgICAgICAgICAgIG1vZGVsVHlwZTogcHJvcHMubW9kZWxUeXBlLFxuICAgICAgICB9LCBlbmFibGVSZXNvdXJjZVByb3BlcnR5Q29uc3RyYWludCAmJiB0aGlzLnN0YWNrLmVuYWJsZVJlc291cmNlUHJvcGVydHlDb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHJvc01vZGVsO1xuICAgICAgICB0aGlzLmF0dHJNb2RlbElkID0gcm9zTW9kZWwuYXR0ck1vZGVsSWQ7XG4gICAgICAgIHRoaXMuYXR0ck1vZGVsVmVyc2lvbiA9IHJvc01vZGVsLmF0dHJNb2RlbFZlcnNpb247XG4gICAgfVxufVxuIl19